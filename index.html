<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Mapa de Clientes - Google Maps</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>游늸</text></svg>">

<!-- Material Icons -->
<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

<style>
    :root {
        --primary-color: #4285f4;
        --success-color: #34a853;
        --warning-color: #fbbc04;
        --error-color: #ea4335;
        --bg-overlay: rgba(0, 0, 0, 0.5);
        --shadow-sm: 0 2px 6px rgba(0,0,0,0.3);
        --shadow-lg: 0 4px 12px rgba(0,0,0,0.4);
    }

    body, html {
        margin: 0;
        padding: 0;
        height: 100%;
        width: 100%;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        overflow: hidden;
    }

    #map {
        height: 100%;
        width: 100%;
        position: absolute;
        top: 0;
        left: 0;
        opacity: 0;
        transition: opacity 0.5s ease-in-out;
        /* GPU acceleration para melhor performance */
        transform: translateZ(0);
        will-change: transform, opacity;
        backface-visibility: hidden;
        -webkit-font-smoothing: antialiased;
    }

    #map.loaded {
        opacity: 1;
        will-change: auto; /* Remove will-change ap칩s carregamento */
    }

    /* ===========================
       LOADING SCREEN
       =========================== */
    #loading-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        transition: opacity 0.5s ease-in-out, visibility 0.5s;
    }

    #loading-screen.hidden {
        opacity: 0;
        visibility: hidden;
    }

    .loading-content {
        text-align: center;
        color: white;
    }

    .spinner {
        width: 60px;
        height: 60px;
        margin: 0 auto 24px;
        position: relative;
    }

    .spinner::before {
        content: '';
        box-sizing: border-box;
        position: absolute;
        top: 50%;
        left: 50%;
        width: 60px;
        height: 60px;
        margin-top: -30px;
        margin-left: -30px;
        border-radius: 50%;
        border: 4px solid rgba(255, 255, 255, 0.2);
        border-top-color: white;
        animation: spinner 0.8s linear infinite;
    }

    @keyframes spinner {
        to { transform: rotate(360deg); }
    }

    .loading-text {
        font-size: 18px;
        font-weight: 600;
        margin-bottom: 8px;
        animation: pulse-text 2s ease-in-out infinite;
    }

    .loading-subtext {
        font-size: 14px;
        opacity: 0.9;
        font-weight: 400;
    }

    @keyframes pulse-text {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.6; }
    }

    /* ===========================
       CONTROLES DO MAPA
       =========================== */
    .map-control {
        position: fixed;
        top: 90px;
        right: 20px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        z-index: 9999;
        opacity: 0;
        transform: translateX(100px);
        transition: opacity 0.5s ease-in-out 0.3s, transform 0.5s ease-in-out 0.3s;
    }

    .map-control.visible {
        opacity: 1;
        transform: translateX(0);
    }

    .control-btn {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        border: none;
        background: white;
        box-shadow: var(--shadow-sm);
        font-size: 18px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        position: relative;
        color: #333;
        /* Centralizar 칤cone perfeitamente */
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0;
        line-height: 1;
    }

    .control-btn:hover {
        box-shadow: var(--shadow-lg);
        transform: translateY(-2px);
    }

    .control-btn:active {
        transform: translateY(0) scale(0.95);
    }

    .control-btn.active {
        background: var(--primary-color);
        color: white;
    }

    .control-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none !important;
    }

    /* Bot칚o Parar Navega칞칚o */
    .stop-navigation-btn {
        position: fixed;
        bottom: 100px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 1000;
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 12px 20px;
        background: linear-gradient(135deg, #ea4335 0%, #c5221f 100%);
        color: white;
        border: none;
        border-radius: 30px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(234, 67, 53, 0.4);
        transition: all 0.3s ease;
        animation: pulseNav 2s infinite;
    }

    .stop-navigation-btn:hover {
        transform: translateX(-50%) scale(1.05);
        box-shadow: 0 6px 20px rgba(234, 67, 53, 0.5);
    }

    .stop-navigation-btn:active {
        transform: translateX(-50%) scale(0.98);
    }

    .stop-nav-icon {
        font-size: 16px;
        font-weight: bold;
    }

    @keyframes pulseNav {
        0%, 100% { box-shadow: 0 4px 15px rgba(234, 67, 53, 0.4); }
        50% { box-shadow: 0 4px 25px rgba(234, 67, 53, 0.6); }
    }

    /* Indicador de carregamento no bot칚o */
    .control-btn.loading::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 20px;
        height: 20px;
        margin-top: -10px;
        margin-left: -10px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-top-color: white;
        border-radius: 50%;
        animation: spinner 0.6s linear infinite;
    }

    .control-btn.loading {
        color: transparent;
    }

    /* ===========================
       MARCADOR DA LOCALIZA칂츾O (Estilo Google Maps)
       =========================== */
    .location-marker {
        position: relative;
        width: 22px;
        height: 22px;
    }

    /* Anel de precis칚o/accuracy (c칤rculo azul claro pulsante) */
    .location-marker-pulse {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 80px;
        height: 80px;
        background: rgba(66, 133, 244, 0.15);
        border-radius: 50%;
        z-index: 1;
    }

    /* Bolinha azul principal (estilo Google Maps) */
    .location-marker-dot {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 18px;
        height: 18px;
        background: #4285F4;
        border: 3px solid white;
        border-radius: 50%;
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
        z-index: 3;
    }

    /* Anima칞칚o do anel de precis칚o */
    @keyframes pulse {
        0% {
            transform: translate(-50%, -50%) scale(0.5);
            opacity: 1;
        }
        100% {
            transform: translate(-50%, -50%) scale(1.2);
            opacity: 0.4;
        }
    }

    .location-marker.active .location-marker-pulse {
        animation: pulse 2s ease-out infinite;
    }

    /* ===========================
       BOT츾O DE CENTRALIZAR LOCALIZA칂츾O (Estilo Google Maps)
       =========================== */
    .gps-center-button {
        background-color: #fff;
        border: 0;
        border-radius: 2px;
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
        cursor: pointer;
        width: 40px;
        height: 40px;
        padding: 0;
        margin: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.2s ease;
    }

    .gps-center-button:hover {
        background-color: #f5f5f5;
    }

    .gps-center-button:active {
        background-color: #e8e8e8;
    }

    .gps-center-button .material-icons {
        color: #666;
        font-size: 20px;
    }

    .gps-center-button.active .material-icons {
        color: #4285F4;
    }

    /* ===========================
       SISTEMA DE NOTIFICA칂칏ES
       =========================== */
    #toast-container {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10001;
        display: flex;
        flex-direction: column;
        gap: 10px;
        max-width: 90%;
        width: 400px;
    }

    .toast {
        background: white;
        padding: 16px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        display: flex;
        align-items: center;
        gap: 12px;
        animation: slideDown 0.3s ease-out;
        border-left: 4px solid var(--primary-color);
    }

    .toast.success { border-left-color: var(--success-color); }
    .toast.warning { border-left-color: var(--warning-color); }
    .toast.error { border-left-color: var(--error-color); }

    @keyframes slideDown {
        from {
            opacity: 0;
            transform: translateY(-20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .toast.hiding {
        animation: slideUp 0.3s ease-out forwards;
    }

    @keyframes slideUp {
        from {
            opacity: 1;
            transform: translateY(0);
        }
        to {
            opacity: 0;
            transform: translateY(-20px);
        }
    }

    .toast-icon {
        font-size: 20px;
        flex-shrink: 0;
    }

    .toast-content {
        flex: 1;
    }

    .toast-title {
        font-weight: 600;
        margin-bottom: 4px;
        color: #333;
    }

    .toast-message {
        font-size: 14px;
        color: #666;
    }

    /* ===========================
       STATUS BAR
       =========================== */
    #status-bar {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        padding: 12px 20px;
        border-radius: 24px;
        box-shadow: var(--shadow-sm);
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 14px;
        color: #333;
        z-index: 9999;
        opacity: 0;
        transition: opacity 0.3s ease;
    }

    #status-bar.visible {
        opacity: 1;
    }

    .status-indicator {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: var(--success-color);
        animation: blink 2s infinite;
    }

    @keyframes blink {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.3; }
    }

    .status-indicator.inactive {
        background: #ccc;
        animation: none;
    }

    /* ===========================
       BOT츾O ADICIONAR CLIENTE
       =========================== */
    #btn-add-client {
        position: fixed;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%);
        background: var(--primary-color);
        color: white;
        border: none;
        padding: 16px 32px;
        border-radius: 30px;
        font-size: 16px;
        font-weight: 600;
        box-shadow: var(--shadow-lg);
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 10px;
        z-index: 9999;
        opacity: 0;
        transition: all 0.3s ease;
    }

    #btn-add-client.visible {
        opacity: 1;
    }

    #btn-add-client:hover {
        transform: translateX(-50%) translateY(-3px);
        box-shadow: 0 6px 20px rgba(66, 133, 244, 0.4);
    }

    #btn-add-client:active {
        transform: translateX(-50%) translateY(-1px);
    }

    /* ===========================
       BOT츾O CADASTRO R츼PIDO
       =========================== */
    #btn-quick-register {
        position: fixed;
        bottom: 145px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, #00b894 0%, #00cec9 100%);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 25px;
        font-size: 14px;
        font-weight: 600;
        box-shadow: var(--shadow-lg);
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 8px;
        z-index: 9999;
        opacity: 0;
        transition: all 0.3s ease;
    }

    #btn-quick-register.visible {
        opacity: 1;
    }

    #btn-quick-register:hover {
        transform: translateX(-50%) translateY(-3px);
        box-shadow: 0 6px 20px rgba(0, 184, 148, 0.4);
    }

    #btn-quick-register:active {
        transform: translateX(-50%) translateY(-1px);
    }

    .dark #btn-quick-register {
        background: linear-gradient(135deg, #00a884 0%, #00b8b0 100%);
    }

    /* Modo Cadastro R치pido - esconder campos de nome e telefone */
    .modal-overlay.quick-mode #input-name,
    .modal-overlay.quick-mode #input-phone,
    .modal-overlay.quick-mode label[for="input-name"],
    .modal-overlay.quick-mode label[for="input-phone"] {
        display: none !important;
    }

    /* Esconder os form-groups de nome e telefone inteiros */
    .modal-overlay.quick-mode .form-group:has(#input-name),
    .modal-overlay.quick-mode .form-group:has(#input-phone) {
        display: none !important;
    }

    /* Esconder apenas o bot칚o Salvar no modo r치pido */
    .modal-overlay.quick-mode #btn-save {
        display: none !important;
    }

    /* Manter o bot칚o de ajustar localiza칞칚o vis칤vel no modo r치pido */
    .modal-overlay.quick-mode #btn-adjust-location {
        display: flex !important;
    }

    .modal-overlay.quick-mode .modal-header {
        background: linear-gradient(135deg, #00b894 0%, #00cec9 100%);
    }

    /* ===========================
       MODAL ADICIONAR CLIENTE
       =========================== */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: var(--bg-overlay);
        z-index: 10004;
        display: none;
        align-items: center;
        justify-content: center;
        opacity: 0;
        transition: opacity 0.3s ease;
    }

    .modal-overlay.active {
        display: flex;
        opacity: 1;
    }

    .modal-container {
        background: white;
        border-radius: 16px;
        width: 95%;
        max-width: 500px;
        max-height: 85vh;
        overflow-y: auto;
        box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        transform: scale(0.9);
        transition: transform 0.3s ease;
        margin: 10px;
    }

    /* Ajustes para mobile */
    @media (max-width: 480px) {
        .modal-container {
            width: 100%;
            max-height: 100vh;
            height: 100vh;
            margin: 0;
            border-radius: 0;
        }

        .modal-body {
            padding: 16px;
            padding-bottom: 100px; /* Espa칞o para o footer fixo */
        }

        .form-footer {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: white;
            padding: 12px 16px;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
            z-index: 10;
        }

        .dark .form-footer {
            background: #1e1e1e;
        }

        .qr-camera-container {
            height: 150px !important;
            min-height: 150px !important;
        }

        .qr-camera-container video,
        .qr-camera-container canvas {
            height: 150px !important;
        }

        .custom-dropdown-list {
            max-height: 200px !important;
        }

        .form-group {
            margin-bottom: 12px;
        }

        .form-label {
            font-size: 13px;
            margin-bottom: 4px;
        }

        .form-input {
            padding: 10px 12px;
            font-size: 16px; /* Evita zoom no iOS */
        }

        .btn-adjust-location {
            padding: 10px 14px;
            font-size: 13px;
        }
    }

    .modal-overlay.active .modal-container {
        transform: scale(1);
    }

    .modal-close {
        width: 32px;
        height: 32px;
        border: none;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 50%;
        font-size: 18px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
        box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        flex-shrink: 0;
    }

    .modal-close:hover {
        background: white;
        transform: rotate(90deg);
    }

    .modal-body {
        padding: 24px;
    }

    /* Custom Dropdown para Sele칞칚o de Endere칞o */
    .custom-dropdown {
        position: relative;
        width: 100%;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }

    .custom-dropdown-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 14px;
        background: #fff;
        border: 2px solid #e0e0e0;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-size: 14px;
        color: #333;
    }

    .dark .custom-dropdown-header {
        background: #2d2d2d;
        border-color: #444;
        color: #e0e0e0;
    }

    .custom-dropdown-header:hover {
        border-color: #4285f4;
    }

    .custom-dropdown.open .custom-dropdown-header {
        border-color: #4285f4;
        border-bottom-left-radius: 0;
        border-bottom-right-radius: 0;
    }

    .dropdown-placeholder {
        color: #888;
    }

    .dropdown-arrow {
        font-size: 10px;
        color: #666;
        transition: transform 0.2s ease;
    }

    .custom-dropdown.open .dropdown-arrow {
        transform: rotate(180deg);
    }

    .custom-dropdown-list {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        max-height: 250px;
        overflow-y: auto;
        background: #fff;
        border: 2px solid #4285f4;
        border-top: none;
        border-radius: 0 0 8px 8px;
        display: none;
        z-index: 1000;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }

    .dark .custom-dropdown-list {
        background: #2d2d2d;
        border-color: #4285f4;
    }

    .custom-dropdown.open .custom-dropdown-list {
        display: block;
    }

    .dropdown-item {
        display: flex;
        align-items: flex-start;
        padding: 10px 14px;
        cursor: pointer;
        border-bottom: 1px solid #f0f0f0;
        transition: background 0.15s ease;
        gap: 10px;
    }

    .dark .dropdown-item {
        border-bottom-color: #3d3d3d;
    }

    .dropdown-item:last-child {
        border-bottom: none;
    }

    .dropdown-item:hover {
        background: #f5f8ff;
    }

    .dark .dropdown-item:hover {
        background: #3a3a4a;
    }

    .dropdown-item-number {
        font-weight: 700;
        color: #EA4335;
        font-size: 14px;
        min-width: 28px;
        flex-shrink: 0;
    }

    .dropdown-item-address {
        flex: 1;
        font-size: 13px;
        color: #333;
        line-height: 1.4;
    }

    .dark .dropdown-item-address {
        color: #e0e0e0;
    }

    .dropdown-item-empty {
        padding: 16px 14px;
        text-align: center;
        color: #888;
        font-style: italic;
        font-size: 13px;
    }

    .dropdown-item-success {
        color: #34A853;
        font-weight: 500;
    }

    /* Scrollbar customizada para a lista */
    .custom-dropdown-list::-webkit-scrollbar {
        width: 6px;
    }

    .custom-dropdown-list::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 3px;
    }

    .custom-dropdown-list::-webkit-scrollbar-thumb {
        background: #c1c1c1;
        border-radius: 3px;
    }

    .custom-dropdown-list::-webkit-scrollbar-thumb:hover {
        background: #a1a1a1;
    }

    .dark .custom-dropdown-list::-webkit-scrollbar-track {
        background: #3d3d3d;
    }

    .dark .custom-dropdown-list::-webkit-scrollbar-thumb {
        background: #666;
    }

    /* QR Code Scanner */
    .qr-scanner-section {
        margin-bottom: 24px;
    }

    .scanner-title {
        font-size: 14px;
        font-weight: 600;
        color: #666;
        margin-bottom: 12px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .qr-camera-container {
        position: relative;
        width: 100%;
        max-width: 400px;
        margin: 0 auto;
        background: #000;
        border-radius: 12px;
        overflow: hidden;
        display: none;
    }

    .qr-camera-container.active {
        display: block;
    }

    #qr-video {
        width: 100%;
        height: auto;
        max-height: 300px;
        min-height: 200px;
        object-fit: cover;
        display: block;
        background: #000;
    }

    #qr-video:not([src]) {
        opacity: 0.3;
    }

    /* V칤deo do scanner de pacotes - mesmos estilos */
    #qr-package-video {
        width: 100%;
        height: auto;
        max-height: 300px;
        min-height: 200px;
        object-fit: cover;
        display: block;
        background: #000;
    }

    #qr-package-video:not([src]) {
        opacity: 0.3;
    }

    #qr-canvas,
    #qr-package-canvas {
        display: none;
    }

    .qr-overlay {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 200px;
        height: 200px;
        border: 2px solid rgba(255, 255, 255, 0.5);
        border-radius: 12px;
        pointer-events: none;
    }

    .qr-overlay::before,
    .qr-overlay::after {
        content: '';
        position: absolute;
        width: 20px;
        height: 20px;
        border: 3px solid white;
    }

    .qr-overlay::before {
        top: -3px;
        left: -3px;
        border-right: none;
        border-bottom: none;
    }

    .qr-overlay::after {
        top: -3px;
        right: -3px;
        border-left: none;
        border-bottom: none;
    }

    .qr-overlay-bottom-left::before,
    .qr-overlay-bottom-right::after {
        content: '';
        position: absolute;
        width: 20px;
        height: 20px;
        border: 3px solid white;
    }

    .qr-overlay-bottom-left::before {
        bottom: -3px;
        left: -3px;
        border-right: none;
        border-top: none;
    }

    .qr-overlay-bottom-right::after {
        bottom: -3px;
        right: -3px;
        border-left: none;
        border-top: none;
    }

    .scanning-line {
        position: absolute;
        width: 100%;
        height: 2px;
        background: linear-gradient(90deg, transparent, var(--success-color), transparent);
        top: 50%;
        animation: scan 2s linear infinite;
        pointer-events: none;
    }

    @keyframes scan {
        0% { top: 25%; opacity: 0; }
        50% { opacity: 1; }
        100% { top: 75%; opacity: 0; }
    }

    .camera-controls {
        position: absolute;
        bottom: 12px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 10px;
        z-index: 10;
    }

    .camera-btn {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        border: none;
        background: rgba(255, 255, 255, 0.9);
        color: #333;
        font-size: 18px;
        cursor: pointer;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        transition: all 0.2s ease;
    }

    .camera-btn:hover {
        background: white;
        transform: scale(1.1);
    }

    .camera-btn:active {
        transform: scale(0.95);
    }

    .address-display {
        margin-bottom: 24px;
        padding: 16px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 12px;
        color: white;
        display: none;
        animation: slideIn 0.3s ease-out;
    }

    .address-display.active {
        display: block;
    }

    @keyframes slideIn {
        from {
            opacity: 0;
            transform: translateY(-10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    @keyframes highlight-pulse {
        0% {
            background: #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transform: scale(1);
        }
        50% {
            background: #e3f2fd;
            box-shadow: 0 4px 12px rgba(33,150,243,0.3);
            transform: scale(1.02);
        }
        100% {
            background: #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transform: scale(1);
        }
    }

    .address-label {
        font-size: 12px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        opacity: 0.9;
        margin-bottom: 8px;
    }

    .address-text {
        font-size: 15px;
        font-weight: 500;
        line-height: 1.5;
    }

    .address-icon {
        font-size: 20px;
        margin-right: 8px;
    }

    .qr-status {
        position: absolute;
        top: 12px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 6px 12px;
        border-radius: 16px;
        font-size: 12px;
        font-weight: 500;
        z-index: 10;
        white-space: nowrap;
    }

    .qr-status.success {
        background: rgba(52, 168, 83, 0.9);
    }

    .qr-result {
        margin-top: 12px;
        padding: 12px;
        background: #e8f5e9;
        border-left: 4px solid var(--success-color);
        border-radius: 4px;
        display: none;
    }

    .qr-result.active {
        display: block;
    }

    .qr-result-text {
        font-size: 13px;
        color: #2e7d32;
        word-break: break-all;
    }

    /* ===========================
       MARCADOR ARRAST츼VEL NO MAPA PRINCIPAL
       =========================== */

    /* Barra de instru칞칚o flutuante no topo do mapa */
    .location-picker-bar {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 12px 16px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        z-index: 10003;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        transform: translateY(-100%);
        transition: transform 0.3s ease;
    }

    .location-picker-bar.active {
        transform: translateY(0);
    }

    .location-picker-bar-content {
        display: flex;
        align-items: center;
        gap: 10px;
        flex: 1;
    }

    .location-picker-bar-icon {
        font-size: 24px;
        animation: bounce-pin 1s ease infinite;
    }

    @keyframes bounce-pin {
        0%, 100% { transform: translateY(0); }
        50% { transform: translateY(-5px); }
    }

    .location-picker-bar-text {
        display: flex;
        flex-direction: column;
    }

    .location-picker-bar-title {
        font-weight: 700;
        font-size: 14px;
    }

    .location-picker-bar-hint {
        font-size: 12px;
        opacity: 0.9;
    }

    .location-picker-bar-coords {
        font-family: 'Roboto Mono', monospace;
        font-size: 11px;
        background: rgba(255, 255, 255, 0.2);
        padding: 4px 8px;
        border-radius: 4px;
        margin-left: auto;
    }

    /* Mira central fixa (estilo Uber/99) */
    .location-picker-crosshair {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -100%);
        z-index: 10003;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s ease, transform 0.15s ease;
    }

    .location-picker-crosshair.active {
        opacity: 1;
    }

    .location-picker-crosshair.dragging {
        transform: translate(-50%, -115%) scale(1.1);
    }

    /* Ponto central no ch칚o (onde o pin aponta) */
    .location-picker-dot {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 8px;
        height: 8px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 50%;
        z-index: 10002;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s ease;
    }

    .location-picker-dot.active {
        opacity: 1;
    }

    /* Bot칚o confirmar localiza칞칚o */
    .location-picker-confirm-btn {
        position: fixed;
        bottom: 100px;
        left: 50%;
        transform: translateX(-50%) scale(0);
        background: linear-gradient(135deg, #34a853 0%, #1e8e3e 100%);
        color: white;
        border: none;
        padding: 14px 28px;
        border-radius: 30px;
        font-size: 15px;
        font-weight: 700;
        cursor: pointer;
        box-shadow: 0 4px 20px rgba(52, 168, 83, 0.4);
        z-index: 10003;
        display: flex;
        align-items: center;
        gap: 8px;
        transition: all 0.3s ease;
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
    }

    .location-picker-confirm-btn.active {
        transform: translateX(-50%) scale(1);
        opacity: 1;
        visibility: visible;
        pointer-events: auto;
    }

    .location-picker-confirm-btn.active:hover {
        transform: translateX(-50%) scale(1.05);
        box-shadow: 0 6px 25px rgba(52, 168, 83, 0.5);
    }

    .location-picker-confirm-btn.active:active {
        transform: translateX(-50%) scale(0.98);
    }

    .location-picker-confirm-btn .material-icons {
        font-size: 20px;
    }

    /* Bot칚o cancelar sele칞칚o */
    .location-picker-cancel-btn {
        position: fixed;
        bottom: 100px;
        left: 20px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        border: none;
        width: 48px;
        height: 48px;
        border-radius: 50%;
        font-size: 20px;
        cursor: pointer;
        z-index: 10003;
        display: flex;
        align-items: center;
        justify-content: center;
        transform: scale(0);
        transition: all 0.3s ease;
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
    }

    .location-picker-cancel-btn.active {
        transform: scale(1);
        opacity: 1;
        visibility: visible;
        pointer-events: auto;
    }

    .location-picker-cancel-btn.active:hover {
        background: rgba(234, 67, 53, 0.9);
    }

    /* Overlay semi-transparente nas bordas durante sele칞칚o */
    .location-picker-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: none;
        z-index: 10002;
        opacity: 0;
        transition: opacity 0.3s ease;
        box-shadow: inset 0 0 100px rgba(102, 126, 234, 0.3);
    }

    .location-picker-overlay.active {
        opacity: 1;
    }

    /* Bot칚o de ajustar localiza칞칚o no modal */
    .btn-adjust-location {
        width: 100%;
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 14px 16px;
        background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        border: 2px dashed #4285f4;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-size: 14px;
        font-weight: 600;
        color: #333;
    }

    .btn-adjust-location:hover {
        background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
        border-style: solid;
        transform: translateY(-1px);
    }

    .btn-adjust-location:active {
        transform: translateY(0);
    }

    .btn-adjust-location .material-icons {
        font-size: 24px;
        color: #4285f4;
    }

    .btn-adjust-location .location-status {
        margin-left: auto;
        font-size: 11px;
        font-weight: 500;
        padding: 4px 10px;
        border-radius: 12px;
        background: rgba(66, 133, 244, 0.1);
        color: #4285f4;
    }

    .btn-adjust-location .location-status.adjusted {
        background: rgba(52, 168, 83, 0.1);
        color: #34a853;
    }

    .dark .btn-adjust-location {
        background: linear-gradient(135deg, #2d2d2d 0%, #3d3d3d 100%);
        color: #e0e0e0;
        border-color: #4285f4;
    }

    .dark .btn-adjust-location:hover {
        background: linear-gradient(135deg, #3a3a4a 0%, #4a4a5a 100%);
    }

    /* Formul치rio */
    .form-group {
        margin-bottom: 20px;
    }

    .form-label {
        display: block;
        font-size: 14px;
        font-weight: 600;
        color: #333;
        margin-bottom: 8px;
    }

    .form-input {
        width: 100%;
        padding: 12px 16px;
        border: 1px solid #ddd;
        border-radius: 8px;
        font-size: 16px;
        font-family: inherit;
        transition: all 0.2s ease;
        box-sizing: border-box;
    }

    .form-input:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 3px rgba(66, 133, 244, 0.1);
    }

    .form-input:disabled {
        background: #f5f5f5;
        color: #999;
        cursor: not-allowed;
    }

    .form-input::placeholder {
        color: #999;
    }

    .form-textarea {
        min-height: 80px;
        resize: vertical;
        font-family: inherit;
    }

    .form-footer {
        padding: 16px 24px;
        border-top: 1px solid #e0e0e0;
        display: flex;
        gap: 12px;
        justify-content: flex-end;
    }

    .btn {
        padding: 12px 24px;
        border: none;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .btn-secondary {
        background: #f5f5f5;
        color: #666;
    }

    .btn-secondary:hover {
        background: #e0e0e0;
    }

    .btn-primary {
        background: var(--primary-color);
        color: white;
    }

    .btn-primary:hover {
        background: #3367d6;
    }

    .btn-primary:disabled {
        background: #ccc;
        cursor: not-allowed;
    }

    /* Loading no modal */
    .btn.loading {
        position: relative;
        color: transparent;
    }

    .btn.loading::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 16px;
        height: 16px;
        margin-top: -8px;
        margin-left: -8px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-top-color: white;
        border-radius: 50%;
        animation: spinner 0.6s linear infinite;
    }

    /* ===========================
       MENU LATERAL (SIDEBAR)
       =========================== */
    .sidebar {
        position: fixed;
        top: 0;
        left: -400px;
        width: 400px;
        height: 100%;
        background: white;
        box-shadow: 2px 0 12px rgba(0,0,0,0.15);
        z-index: 10003;
        transition: left 0.3s ease;
        display: flex;
        flex-direction: column;
    }

    .sidebar.open {
        left: 0;
    }

    .sidebar-header {
        padding: 20px;
        border-bottom: 2px solid #e0e0e0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
    }

    .sidebar-title {
        font-size: 20px;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .sidebar-close {
        width: 32px;
        height: 32px;
        border: none;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 50%;
        color: white;
        font-size: 18px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
    }

    .sidebar-close:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: rotate(90deg);
    }

    .sidebar-search {
        padding: 16px;
        border-bottom: 1px solid #e0e0e0;
    }

    .search-container {
        position: relative;
        display: flex;
        gap: 8px;
        align-items: center;
    }

    .search-input-wrapper {
        position: relative;
        flex: 1;
    }

    .search-icon {
        position: absolute;
        left: 12px;
        top: 50%;
        transform: translateY(-50%);
        font-size: 18px;
        color: #999;
        pointer-events: none;
    }

    .search-input {
        width: 100%;
        padding: 12px 12px 12px 42px;
        border: 2px solid #e0e0e0;
        border-radius: 24px;
        font-size: 15px;
        font-family: inherit;
        transition: all 0.2s ease;
        box-sizing: border-box;
    }

    .search-input:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 3px rgba(66, 133, 244, 0.1);
    }

    .search-input::placeholder {
        color: #999;
    }

    .btn-scan-package {
        background: var(--primary-color);
        color: white;
        border: none;
        border-radius: 50%;
        width: 44px;
        height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        cursor: pointer;
        transition: all 0.2s ease;
        flex-shrink: 0;
        box-shadow: 0 2px 4px rgba(0,0,0,0.15);
    }

    .btn-scan-package:hover {
        background: #1976D2;
        transform: scale(1.05);
        box-shadow: 0 3px 6px rgba(33,150,243,0.4);
    }

    .btn-scan-package:active {
        transform: scale(0.95);
    }

    /* Resultado do scanner de pacotes */
    .scan-result {
        display: none;
        margin-top: 20px;
        padding: 16px;
        background: #f5f5f5;
        border-radius: 8px;
    }

    .scan-result.active {
        display: block;
    }

    .scan-result-label {
        font-weight: 600;
        color: #333;
        margin-bottom: 8px;
    }

    .scan-result-text {
        color: #666;
    }

    /* Upload de Planilha */
    .upload-area {
        border: 2px dashed #ccc;
        border-radius: 12px;
        padding: 40px 20px;
        text-align: center;
        cursor: pointer;
        transition: all 0.3s ease;
        background: #fafafa;
    }

    .upload-area:hover {
        border-color: var(--primary-color);
        background: #f0f7ff;
    }

    .upload-area.dragover {
        border-color: var(--primary-color);
        background: #e3f2fd;
        transform: scale(1.02);
    }

    .upload-icon {
        font-size: 48px;
        margin-bottom: 12px;
    }

    .upload-text {
        font-size: 16px;
        font-weight: 600;
        color: #333;
        margin-bottom: 4px;
    }

    .upload-subtext {
        font-size: 14px;
        color: #666;
        margin-bottom: 8px;
    }

    .upload-formats {
        font-size: 12px;
        color: #999;
    }

    .upload-progress {
        text-align: center;
        padding: 20px;
    }

    .progress-bar-container {
        width: 100%;
        height: 8px;
        background: #e0e0e0;
        border-radius: 4px;
        overflow: hidden;
        margin-bottom: 12px;
    }

    .progress-bar {
        height: 100%;
        background: linear-gradient(90deg, var(--primary-color), #1976D2);
        width: 0%;
        transition: width 0.3s ease;
        animation: progress-pulse 1.5s ease-in-out infinite;
    }

    @keyframes progress-pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
    }

    .progress-text {
        font-size: 14px;
        color: #666;
    }

    .upload-result {
        text-align: center;
        padding: 20px;
    }

    .result-icon {
        font-size: 48px;
        margin-bottom: 12px;
    }

    .result-text {
        font-size: 16px;
        font-weight: 600;
        margin-bottom: 8px;
    }

    .result-details {
        font-size: 14px;
        color: #666;
        margin-top: 10px;
        line-height: 1.6;
    }

    .sidebar-content {
        flex: 1;
        overflow-y: auto;
        padding: 16px;
    }

    .clients-list {
        display: flex;
        flex-direction: column;
        gap: 12px;
    }

    .client-card {
        background: white;
        border: 1px solid #e0e0e0;
        border-radius: 12px;
        padding: 16px;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .client-card:hover {
        border-color: var(--primary-color);
        box-shadow: 0 2px 8px rgba(66, 133, 244, 0.15);
        transform: translateY(-2px);
    }

    .client-card-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 8px;
        gap: 8px;
    }

    .client-name {
        font-size: 16px;
        font-weight: 600;
        color: #333;
        display: flex;
        align-items: center;
        gap: 8px;
        flex: 1;
    }

    .client-actions {
        display: flex;
        gap: 8px;
        opacity: 1;
    }

    .client-action-btn {
        background: none;
        border: none;
        padding: 6px 10px;
        cursor: pointer;
        font-size: 20px;
        border-radius: 6px;
        transition: all 0.2s ease;
        line-height: 1;
        min-width: 38px;
        min-height: 38px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .client-action-btn:hover {
        background: #f0f0f0;
        transform: scale(1.1);
    }

    .client-action-btn.navigate-btn:hover {
        background: #e8f5e9;
    }

    .client-action-btn.edit-btn:hover {
        background: #e3f2fd;
    }

    .client-action-btn.delete-btn:hover {
        background: #ffebee;
    }

    .client-info {
        font-size: 14px;
        color: #666;
        margin-bottom: 4px;
        display: flex;
        align-items: flex-start;
        gap: 8px;
    }

    .client-info.phone-info {
        align-items: center;
        justify-content: space-between;
    }

    .client-info-icon {
        font-size: 14px;
        opacity: 0.7;
        flex-shrink: 0;
        margin-top: 2px;
    }

    .phone-actions {
        display: flex;
        gap: 12px;
        margin-left: auto;
    }

    .phone-action-btn {
        border: none;
        padding: 0;
        cursor: pointer;
        border-radius: 50%;
        transition: all 0.2s ease;
        text-decoration: none;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 38px;
        height: 38px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.15);
    }

    .phone-action-btn svg {
        width: 20px;
        height: 20px;
    }

    .phone-action-btn svg {
        transition: all 0.2s ease;
    }

    /* Classes para estado resetado - for칞a re-render */
    .phone-action-btn.btn-reset {
        pointer-events: auto !important;
        outline: none !important;
    }

    .phone-action-btn.call-btn {
        background: #2196F3;
        box-shadow: 0 2px 4px rgba(0,0,0,0.15);
        transform: scale(1);
    }

    .phone-action-btn.call-btn:link,
    .phone-action-btn.call-btn:visited,
    .phone-action-btn.call-btn:focus,
    .phone-action-btn.call-btn:active,
    .phone-action-btn.call-btn:focus-visible {
        background: #2196F3;
        box-shadow: 0 2px 4px rgba(0,0,0,0.15);
        transform: scale(1);
    }

    /* Hover apenas em desktop - n칚o em touch */
    @media (hover: hover) and (pointer: fine) {
        .phone-action-btn.call-btn:hover:not(:active) {
            background: #1976D2;
            transform: scale(1.1);
            box-shadow: 0 3px 6px rgba(33,150,243,0.4);
        }
    }

    .phone-action-btn.whatsapp-btn {
        background: #25D366;
        box-shadow: 0 2px 4px rgba(0,0,0,0.15);
        transform: scale(1);
    }

    .phone-action-btn.whatsapp-btn:link,
    .phone-action-btn.whatsapp-btn:visited,
    .phone-action-btn.whatsapp-btn:focus,
    .phone-action-btn.whatsapp-btn:active,
    .phone-action-btn.whatsapp-btn:focus-visible {
        background: #25D366;
        box-shadow: 0 2px 4px rgba(0,0,0,0.15);
        transform: scale(1);
    }

    /* Hover apenas em desktop - n칚o em touch */
    @media (hover: hover) and (pointer: fine) {
        .phone-action-btn.whatsapp-btn:hover:not(:active) {
            background: #128C7E;
            transform: scale(1.1);
            box-shadow: 0 3px 6px rgba(37,211,102,0.4);
        }
    }

    .empty-state {
        text-align: center;
        padding: 40px 20px;
        color: #999;
    }

    .empty-state-icon {
        font-size: 48px;
        margin-bottom: 16px;
        opacity: 0.5;
    }

    .empty-state-text {
        font-size: 16px;
        font-weight: 500;
        margin-bottom: 8px;
    }

    .empty-state-subtext {
        font-size: 14px;
    }

    .sidebar-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 10002;
        display: none;
        opacity: 0;
        transition: opacity 0.3s ease;
    }

    .sidebar-overlay.active {
        display: block;
        opacity: 1;
    }

    .client-count {
        display: inline-block;
        background: rgba(255, 255, 255, 0.2);
        padding: 4px 10px;
        border-radius: 12px;
        font-size: 13px;
        font-weight: 600;
    }

    /* ===========================
       RESPONSIVO
       =========================== */
    @media (max-width: 768px) {
        .map-control {
            top: 70px;
            right: 10px;
        }

        .control-btn {
            width: 44px;
            height: 44px;
            font-size: 16px;
        }

        #toast-container {
            width: calc(100% - 40px);
        }

        .toast {
            padding: 12px 16px;
        }

        .loading-text {
            font-size: 16px;
        }

        .loading-subtext {
            font-size: 13px;
        }

        #status-bar {
            bottom: 10px;
            font-size: 13px;
            padding: 10px 16px;
        }

        #btn-add-client {
            bottom: 60px;
            padding: 14px 24px;
            font-size: 15px;
        }

        /* Ajustes para mobile - bot칫es maiores */
        .phone-action-btn {
            width: 42px;
            height: 42px;
        }

        .phone-action-btn svg {
            width: 22px;
            height: 22px;
        }

        .phone-actions {
            gap: 14px;
        }

        .client-action-btn {
            font-size: 22px;
            min-width: 42px;
            min-height: 42px;
            padding: 8px 12px;
        }

        .client-actions {
            gap: 10px;
        }

        /* Desabilitar hover em mobile - evitar estados persistentes */
        .phone-action-btn {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        .phone-action-btn.call-btn,
        .phone-action-btn.call-btn:link,
        .phone-action-btn.call-btn:visited,
        .phone-action-btn.call-btn:focus,
        .phone-action-btn.call-btn:active,
        .phone-action-btn.call-btn:focus-visible,
        .phone-action-btn.call-btn:hover {
            background: #2196F3;
            box-shadow: 0 2px 4px rgba(0,0,0,0.15);
            transform: scale(1);
        }

        .phone-action-btn.whatsapp-btn,
        .phone-action-btn.whatsapp-btn:link,
        .phone-action-btn.whatsapp-btn:visited,
        .phone-action-btn.whatsapp-btn:focus,
        .phone-action-btn.whatsapp-btn:active,
        .phone-action-btn.whatsapp-btn:focus-visible,
        .phone-action-btn.whatsapp-btn:hover {
            background: #25D366;
            box-shadow: 0 2px 4px rgba(0,0,0,0.15);
            transform: scale(1);
        }

        .modal-container {
            width: 95%;
            max-height: 95vh;
        }

        .modal-body {
            padding: 20px;
        }

        .scanner-title {
            font-size: 13px;
        }

        .modal-close {
            width: 28px;
            height: 28px;
            font-size: 16px;
        }

        .qr-camera-container {
            max-width: 100%;
        }

        #qr-video,
        #qr-package-video {
            max-height: 250px;
        }

        .qr-overlay {
            width: 180px;
            height: 180px;
        }

        .qr-upload-area {
            padding: 24px;
        }

        .qr-icon {
            font-size: 40px;
        }

        .form-footer {
            padding: 12px 20px;
            flex-direction: column-reverse;
        }

        .btn {
            width: 100%;
        }

        .sidebar {
            width: 100%;
            left: -100%;
        }

        .sidebar.open {
            left: 0;
        }

        .sidebar-title {
            font-size: 18px;
        }

        .sidebar-content {
            padding: 12px;
        }

        .client-card {
            padding: 14px;
        }
    }

    /* Esconder o bot칚o X padr칚o do Google Maps InfoWindow */
    .gm-style-iw-chr {
        display: none !important;
    }

    .gm-ui-hover-effect {
        display: none !important;
    }
</style>
</head>
<body>

<!-- Loading Screen -->
<div id="loading-screen">
    <div class="loading-content">
        <div class="spinner"></div>
        <div class="loading-text" id="loading-text">Inicializando mapa...</div>
        <div class="loading-subtext" id="loading-subtext">Aguarde um momento</div>
    </div>
</div>

<!-- Mapa -->
<div id="map"></div>

<!-- Controles -->
<div class="map-control">
    <button id="btnToggle3D" class="control-btn" title="Alternar visualiza칞칚o 3D">3D</button>
    <button id="btnToggleRoute" class="control-btn" title="Planejar rota de entrega">游뚱</button>
    <button id="btnClearRoute" class="control-btn" title="Limpar rotas e marcadores" style="display: none;">游딈勇</button>
    <button id="btnOpenSidebar" class="control-btn" title="Ver lista de clientes">游논</button>
    <button id="btnUploadSpreadsheet" class="control-btn" title="Atualizar planilha do dia">游늵</button>
    <button id="btnToggleClients" class="control-btn" title="Mostrar/Ocultar clientes no mapa">游녻</button>
    <button id="btnShowMatchedClients" class="control-btn" title="Mostrar clientes identificados na planilha">游늸</button>
</div>

<!-- Bot칚o Parar Navega칞칚o (flutuante) -->
<button id="btnStopNavigation" class="stop-navigation-btn" style="display: none;">
    <span class="stop-nav-icon">九</span>
    <span class="stop-nav-text">Parar Navega칞칚o</span>
</button>

<!-- Container de Notifica칞칫es -->
<div id="toast-container"></div>

<!-- UI de Sele칞칚o de Localiza칞칚o (mira fixa estilo Uber/99) -->
<div class="location-picker-overlay" id="location-picker-overlay"></div>

<!-- Mira/Pin fixo no centro da tela -->
<div class="location-picker-crosshair" id="location-picker-crosshair">
    <svg width="48" height="60" viewBox="0 0 48 60" xmlns="http://www.w3.org/2000/svg">
        <defs>
            <linearGradient id="crosshairPinGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:#4285F4;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#1a73e8;stop-opacity:1" />
            </linearGradient>
        </defs>
        <path d="M24 0 C10.745 0 0 10.745 0 24 C0 42 24 58 24 58 S48 42 48 24 C48 10.745 37.255 0 24 0 Z"
              fill="url(#crosshairPinGradient)"
              stroke="#FFFFFF"
              stroke-width="3"/>
        <circle cx="24" cy="24" r="10" fill="#FFFFFF"/>
        <circle cx="24" cy="24" r="5" fill="#4285F4"/>
    </svg>
</div>
<div class="location-picker-dot" id="location-picker-dot"></div>

<div class="location-picker-bar" id="location-picker-bar">
    <div class="location-picker-bar-content">
        <span class="location-picker-bar-icon">游늸</span>
        <div class="location-picker-bar-text">
            <span class="location-picker-bar-title">Arraste o mapa</span>
            <span class="location-picker-bar-hint">Posicione a mira no local exato</span>
        </div>
    </div>
    <span class="location-picker-bar-coords" id="picker-coords-display">---, ---</span>
</div>
<button class="location-picker-confirm-btn" id="btn-confirm-location">
    <span class="material-icons">check</span>
    Confirmar Local
</button>
<button class="location-picker-cancel-btn" id="btn-cancel-location">九</button>

<!-- Status Bar -->
<div id="status-bar">
    <div class="status-indicator" id="status-indicator"></div>
    <span id="status-text">Rastreando localiza칞칚o</span>
</div>

<!-- Bot칚o Cadastro R치pido -->
<button id="btn-quick-register">
    <span>丘</span>
    <span>Cadastro R치pido</span>
</button>

<!-- Bot칚o Adicionar Cliente -->
<button id="btn-add-client">
    <span>俱</span>
    <span>Adicionar Cliente</span>
</button>

<!-- Sidebar - Menu Lateral -->
<div class="sidebar-overlay" id="sidebar-overlay"></div>

<div class="sidebar" id="sidebar">
    <div class="sidebar-header">
        <div class="sidebar-title">
            <span>游논</span>
            <span>Clientes</span>
            <span class="client-count" id="client-count">0</span>
        </div>
        <button class="sidebar-close" id="sidebar-close">九</button>
    </div>

    <div class="sidebar-search">
        <div class="search-container">
            <div class="search-input-wrapper">
                <span class="search-icon">游댌</span>
                <input
                    type="text"
                    class="search-input"
                    id="search-input"
                    placeholder="Buscar por nome, endere칞o ou telefone..."
                >
            </div>
            <button class="btn-scan-package" id="btn-scan-package" title="Escanear c칩digo QR do pacote">游닍</button>
        </div>
    </div>

    <div class="sidebar-content">
        <div class="clients-list" id="clients-list">
            <!-- Lista de clientes ser치 inserida aqui -->
            <div class="empty-state">
                <div class="empty-state-icon">游늶</div>
                <div class="empty-state-text">Nenhum cliente cadastrado</div>
                <div class="empty-state-subtext">Adicione clientes para v칡-los aqui</div>
            </div>
        </div>
    </div>
</div>

<!-- Modal Adicionar Cliente -->
<div class="modal-overlay" id="modal-add-client">
    <div class="modal-container">
        <div class="modal-body">
            <!-- Scanner QR Code -->
            <div class="qr-scanner-section">
                <div class="scanner-title">
                    <span>游닞 Aponte a c칙mera para o QR Code</span>
                    <button class="modal-close" id="modal-close">九</button>
                </div>

                <div class="qr-camera-container active" id="qr-camera-container">
                    <video id="qr-video" autoplay playsinline></video>
                    <canvas id="qr-canvas"></canvas>

                    <div class="qr-overlay">
                        <div class="qr-overlay-bottom-left"></div>
                        <div class="qr-overlay-bottom-right"></div>
                    </div>

                    <div class="scanning-line"></div>

                    <div class="qr-status" id="qr-status">Procurando QR Code...</div>

                    <div class="camera-controls">
                        <button class="camera-btn" id="btn-stop-camera" title="Fechar c칙mera">九</button>
                        <button class="camera-btn" id="btn-switch-camera" title="Trocar c칙mera">游댃</button>
                    </div>
                </div>
            </div>

            <!-- Display do Endere칞o -->
            <div class="address-display" id="address-display">
                <div class="address-label">游늸 Endere칞o do Cliente</div>
                <div class="address-text" id="address-text"></div>
            </div>

            <!-- Formul치rio -->
            <form id="form-add-client">

                <div class="form-group">
                    <label class="form-label" for="input-name">Nome do Cliente *</label>
                    <input
                        type="text"
                        class="form-input"
                        id="input-name"
                        placeholder="Digite o nome do cliente"
                        required
                    >
                </div>

                <div class="form-group">
                    <label class="form-label" for="input-phone">Telefone</label>
                    <input
                        type="tel"
                        class="form-input"
                        id="input-phone"
                        placeholder="(91)9 9942-1942"
                        maxlength="16"
                    >
                </div>

                <!-- Dropdown para selecionar endere칞o manualmente -->
                <div class="form-group">
                    <label class="form-label">游늶 Selecionar Endere칞o Manualmente</label>

                    <!-- Dropdown Customizado -->
                    <div class="custom-dropdown" id="address-dropdown">
                        <div class="custom-dropdown-header" id="dropdown-header">
                            <span class="dropdown-placeholder">-- Escolha um endere칞o da planilha --</span>
                            <span class="dropdown-arrow">郊</span>
                        </div>
                        <div class="custom-dropdown-list" id="dropdown-list">
                            <!-- Itens ser칚o inseridos via JS -->
                        </div>
                    </div>

                    <div class="address-list-hint" style="font-size: 11px; color: #666; margin-top: 4px;">
                        游눠 Use quando n칚o for poss칤vel ler o QR Code
                    </div>
                </div>

                <!-- Bot칚o para ajustar localiza칞칚o no mapa -->
                <div class="form-group">
                    <label class="form-label">游늸 Localiza칞칚o do Cliente</label>
                    <button type="button" class="btn-adjust-location" id="btn-adjust-location">
                        <span class="material-icons">edit_location_alt</span>
                        <span>Ajustar no Mapa</span>
                        <span class="location-status" id="location-status">GPS atual</span>
                    </button>
                    <div class="location-hint" style="font-size: 11px; color: #666; margin-top: 4px;">
                        游눠 Arraste o marcador no mapa para posi칞칚o exata
                    </div>
                </div>
            </form>
        </div>

        <div class="form-footer">
            <button type="button" class="btn btn-secondary" id="btn-cancel">Cancelar</button>
            <button type="submit" class="btn btn-primary" id="btn-save" form="form-add-client">Salvar Cliente</button>
        </div>
    </div>
</div>

<!-- Modal Scanner de Pacotes -->
<div class="modal-overlay" id="modal-scan-package">
    <div class="modal-container">
        <div class="modal-body">
            <!-- Scanner QR Code -->
            <div class="qr-scanner-section">
                <div class="scanner-title">
                    <span>游닍 Escanear C칩digo do Pacote</span>
                    <button class="modal-close" id="modal-scan-close">九</button>
                </div>

                <div class="qr-camera-container" id="qr-package-camera-container">
                    <video id="qr-package-video" autoplay playsinline></video>
                    <canvas id="qr-package-canvas"></canvas>

                    <div class="qr-overlay">
                        <div class="qr-overlay-bottom-left"></div>
                        <div class="qr-overlay-bottom-right"></div>
                    </div>

                    <div class="scanning-line"></div>

                    <div class="qr-status" id="qr-package-status">Procurando c칩digo QR...</div>

                    <div class="camera-controls">
                        <button class="camera-btn" id="btn-package-stop-camera" title="Fechar c칙mera">九</button>
                        <button class="camera-btn" id="btn-package-switch-camera" title="Trocar c칙mera">游댃</button>
                    </div>
                </div>
            </div>

            <!-- Resultado da busca -->
            <div class="scan-result" id="scan-result">
                <div class="scan-result-label">游늶 Cliente Encontrado:</div>
                <div class="scan-result-text" id="scan-result-text"></div>
            </div>
        </div>

        <div class="form-footer">
            <button type="button" class="btn btn-secondary" id="btn-package-close">Fechar</button>
        </div>
    </div>
</div>

<!-- Modal Upload de Planilha -->
<div class="modal-overlay" id="modal-upload-spreadsheet">
    <div class="modal-container">
        <div class="modal-body">
            <div class="scanner-title">
                <span>游늵 Atualizar Planilha do Dia</span>
                <button class="modal-close" id="modal-upload-close">九</button>
            </div>

            <div class="upload-info" style="background: #fff3cd; padding: 12px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #ffc107;">
                <div style="font-weight: 600; color: #856404; margin-bottom: 4px;">丘멆잺 Aten칞칚o</div>
                <div style="font-size: 13px; color: #856404;">
                    Ao fazer upload de uma nova planilha, todos os dados anteriores ser칚o substitu칤dos e a roteiriza칞칚o ser치 resetada.
                </div>
            </div>

            <div class="upload-area" id="upload-area">
                <div class="upload-icon">游늵</div>
                <div class="upload-text">Arraste a planilha aqui</div>
                <div class="upload-subtext">ou clique para selecionar</div>
                <div class="upload-formats">Formatos: Excel (.xlsx, .xls) ou CSV (.csv)</div>
                <input type="file" id="file-input" accept=".xlsx,.xls,.csv" style="display: none;">
            </div>

            <div class="upload-progress" id="upload-progress" style="display: none;">
                <div class="progress-bar-container">
                    <div class="progress-bar" id="progress-bar"></div>
                </div>
                <div class="progress-text" id="progress-text">Processando planilha...</div>
            </div>

            <div class="upload-result" id="upload-result" style="display: none;">
                <div class="result-icon" id="result-icon"></div>
                <div class="result-text" id="result-text"></div>
                <div class="result-details" id="result-details"></div>
            </div>
        </div>
    </div>
</div>

<!-- SheetJS - Biblioteca para processamento de Excel -->
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

<!-- Tween.js - Biblioteca para anima칞칫es fluidas -->
<script src="https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@23.1.3/dist/tween.umd.js"></script>

<!-- Supabase -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<!-- jsQR - Carregado sob demanda via Lazy Loading -->

<script>
    const SUPABASE_URL = "https://dctlgztkqtktxnmiuqgr.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRjdGxnenRrcXRrdHhubWl1cWdyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ2MzMwNDIsImV4cCI6MjA4MDIwOTA0Mn0.Ctlx8A4QBFxa7Iu6fObw_OthHfA2XrzY47UiMMIhbIU";

    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    // Dados da planilha Excel - Mapeamento de QR codes para endere칞os
    const addressDatabase = {
  "BR2548334621214": {
    "address": "Alameda Moraes, 246, Rua ao lado do Conselho tutela\nBairro: Praia Grande (Mosqueiro)\nBel칠m - 66914-090",
    "latitude": -1.1424655,
    "longitude": -48.4652878,
    "city": "Bel칠m",
    "zipcode": "66914-090",
    "sequence": 1
  },
  "BR258090515239N": {
    "address": "Alameda Moraes, 246, Rua ao lado do Conselho tutela\nBairro: Praia Grande (Mosqueiro)\nBel칠m - 66914-090",
    "latitude": -1.1424655,
    "longitude": -48.4652878,
    "city": "Bel칠m",
    "zipcode": "66914-090",
    "sequence": 2
  },
  "BR2543386241922": {
    "address": "Alameda Moraes, 246\nBairro: Praia Grande (Mosqueiro)\nBel칠m - 66914-090",
    "latitude": -1.1424655,
    "longitude": -48.4652878,
    "city": "Bel칠m",
    "zipcode": "66914-090",
    "sequence": 3
  },
  "BR257485707468Y": {
    "address": "Alameda Moraes, 246\nBairro: Praia Grande (Mosqueiro)\nBel칠m - 66914-090",
    "latitude": -1.1424655,
    "longitude": -48.4652878,
    "city": "Bel칠m",
    "zipcode": "66914-090",
    "sequence": 4
  },
  "BR2590650161019": {
    "address": "Alameda Petr칩polis, 42, Casa branca com muro baixinho\nBairro: Praia Grande (Mosqueiro)\nBel칠m - 66914-100",
    "latitude": -1.1432,
    "longitude": -48.4659004,
    "city": "Bel칠m",
    "zipcode": "66914-100",
    "sequence": 5
  },
  "BR259792298200M": {
    "address": "Alameda Ribamar Santos, 15, Ao lado da LR mat. De constru칞\nBairro: Praia Grande\nBel칠m - 66911-120",
    "latitude": -1.1438776,
    "longitude": -48.4640884,
    "city": "Bel칠m",
    "zipcode": "66911-120",
    "sequence": 6
  },
  "BR255026824340N": {
    "address": "Avenida Beira-Mar - Rua: Dos Escoteiros Pr칩ximo A Rua: Alameda Moraes, 1657, Condominio prive do farol, Bel칠m, Par치, 66910150\nBel칠m - 66910150",
    "latitude": -1.1451693,
    "longitude": -48.4655266,
    "city": "Bel칠m",
    "zipcode": "66910150",
    "sequence": 7
  },
  "BR255669520013M": {
    "address": "Passagem S칚o Domingos, 33, Pr칩ximo  Rua das Mangueiras\nBairro: Praia Grande (Mosqueiro)\nBel칠m - 66914-080",
    "latitude": -1.1456899,
    "longitude": -48.4648368,
    "city": "Bel칠m",
    "zipcode": "66914-080",
    "sequence": 8
  },
  "BR2532092523217": {
    "address": "Rua Raimundo Cintra, 39, Entre S칚o Domingos e Santa Ter\nBairro: Mangueiras (Mosqueiro)\nBel칠m - 66912-220",
    "latitude": -1.1466,
    "longitude": -48.462101,
    "city": "Bel칠m",
    "zipcode": "66912-220",
    "sequence": 9
  },
  "BR252457049287C": {
    "address": "Rua Raimundo Cintra, 12\nBairro: Mangueiras (Mosqueiro)\nBel칠m - 66912-220",
    "latitude": -1.1470315,
    "longitude": -48.4626465,
    "city": "Bel칠m",
    "zipcode": "66912-220",
    "sequence": 10
  },
  "BR257080667441M": {
    "address": "Passg Santa Rita De Kace, 31\nBairro: Ariramba (Mosqueiro)\nBel칠m - 66914-110",
    "latitude": -1.1463585,
    "longitude": -48.4638905,
    "city": "Bel칠m",
    "zipcode": "66914-110",
    "sequence": 11
  },
  "BR259832570656I": {
    "address": "Passg Santa Rita De Kace, 31\nBairro: Ariramba (Mosqueiro)\nBel칠m - 66914-110",
    "latitude": -1.1463585,
    "longitude": -48.4638905,
    "city": "Bel칠m",
    "zipcode": "66914-110",
    "sequence": 12
  },
  "BR2555419499636": {
    "address": "Passagem Mirim, 2, Av. Beira Mar\nBairro: Praia grande mosqueiro\nBel칠m - 66914-510",
    "latitude": -1.15,
    "longitude": -48.4671,
    "city": "Bel칠m",
    "zipcode": "66914-510",
    "sequence": 13
  },
  "BR2510739661481": {
    "address": "Rua do Carmo, 83, Casa\nBairro: Praia Grande (Mosqueiro)\nBel칠m - 66914-040",
    "latitude": -1.1504477,
    "longitude": -48.4675026,
    "city": "Bel칠m",
    "zipcode": "66914-040",
    "sequence": 14
  },
  "BR256427341903Q": {
    "address": "Rua Quinze de Novembro, 39, Praia grande casa verde\nBairro: Vila (Mosqueiro)\nBel칠m - 66910-000",
    "latitude": -1.1509,
    "longitude": -48.4693985,
    "city": "Bel칠m",
    "zipcode": "66910-000",
    "sequence": 15
  },
  "BR252765984646G": {
    "address": "Rua Quinze de Novembro, 39, Praia grande casa verde\nBairro: Vila (Mosqueiro)\nBel칠m - 66910-000",
    "latitude": -1.1509,
    "longitude": -48.4693985,
    "city": "Bel칠m",
    "zipcode": "66910-000",
    "sequence": 16
  },
  "BR2508214594606": {
    "address": "Alameda Fran칞a, 33\nBairro: Praia Grande (Mosqueiro)\nBel칠m - 66914-230",
    "latitude": -1.151652,
    "longitude": -48.4677925,
    "city": "Bel칠m",
    "zipcode": "66914-230",
    "sequence": 17
  },
  "BR257708180761F": {
    "address": "Avenida Beira-Mar, 1076, Proximo a barraca carioquinha\nBairro: Vila (Mosqueiro)\nBel칠m - 66910-150",
    "latitude": -1.1522,
    "longitude": -48.4702988,
    "city": "Bel칠m",
    "zipcode": "66910-150",
    "sequence": 18
  },
  "BR2570195095799": {
    "address": "Rua Coronel Jos칠 do 칍, 137, Pr칩ximo a alameda Raimunda\nBairro: Vila (Mosqueiro)\nBel칠m - 66910-010",
    "latitude": -1.1536975,
    "longitude": -48.4707031,
    "city": "Bel칠m",
    "zipcode": "66910-010",
    "sequence": 19
  },
  "BR252206059319K": {
    "address": "Travessa Lauro Sodr칠, 198 a\nBairro: Vila (Mosqueiro)\nBel칠m - 66910-170",
    "latitude": -1.154588,
    "longitude": -48.4708481,
    "city": "Bel칠m",
    "zipcode": "66910-170",
    "sequence": 20
  },
  "BR258463997845D": {
    "address": "Travessa Lauro Sodr칠, 156, Pr칩ximo ao Hospital Municipal\nBairro: Vila (Mosqueiro)\nBel칠m - 66910-170",
    "latitude": -1.154617,
    "longitude": -48.470768,
    "city": "Bel칠m",
    "zipcode": "66910-170",
    "sequence": 21
  },
  "BR250808162475E": {
    "address": "Travessa Lauro Sodr칠, 235, Ao lado do hospital geral\nBairro: Vila (Mosqueiro)\nBel칠m - 66910-170",
    "latitude": -1.1545,
    "longitude": -48.4700012,
    "city": "Bel칠m",
    "zipcode": "66910-170",
    "sequence": 22
  },
  "BR250622958347D": {
    "address": "Rua Quinze de Novembro, 728\nBairro: Vila (Mosqueiro)\nBel칠m - 66910-000",
    "latitude": -1.1571,
    "longitude": -48.4695015,
    "city": "Bel칠m",
    "zipcode": "66910-000",
    "sequence": 23
  },
  "BR253698799515E": {
    "address": "Rua Quinze de Novembro, 688, Entre o hospital e as 5 bocas\nBairro: Vila (Mosqueiro)\nBel칠m - 66910-000",
    "latitude": -1.1568567,
    "longitude": -48.4692841,
    "city": "Bel칠m",
    "zipcode": "66910-000",
    "sequence": 24
  },
  "BR257375048849G": {
    "address": "Rua Quinze de Novembro, 830\nBairro: Vila (Mosqueiro)\nBel칠m - 66910-000",
    "latitude": -1.1584749,
    "longitude": -48.4690933,
    "city": "Bel칠m",
    "zipcode": "66910-000",
    "sequence": 25
  },
  "BR2570810926273": {
    "address": "Travessa Coronel Jos칠 Mota, 263, Proximidade da Av 16 de Novemb\nBairro: Vila (Mosqueiro)\nBel칠m - 66910-680",
    "latitude": -1.1585106,
    "longitude": -48.4683007,
    "city": "Bel칠m",
    "zipcode": "66910-680",
    "sequence": 26
  },
  "BR2589228991775": {
    "address": "Rua Quinze de Novembro, 18, Passagem sao sebastiao\nBairro: Vila (Mosqueiro)\nBel칠m - 66910-000",
    "latitude": -1.1597145,
    "longitude": -48.469059,
    "city": "Bel칠m",
    "zipcode": "66910-000",
    "sequence": 27
  },
  "BR255892110928M": {
    "address": "Rua Quinze de Novembro, 18, Passagem sao sebastiao\nBairro: Vila (Mosqueiro)\nBel칠m - 66910-000",
    "latitude": -1.1597145,
    "longitude": -48.469059,
    "city": "Bel칠m",
    "zipcode": "66910-000",
    "sequence": 28
  },
  "BR254165660090X": {
    "address": "Rua Quinze de Novembro, 18, Ao lado da NutriPets ra칞칫es\nBairro: Vila (Mosqueiro)\nBel칠m - 66910-000",
    "latitude": -1.1597145,
    "longitude": -48.469059,
    "city": "Bel칠m",
    "zipcode": "66910-000",
    "sequence": 29
  },
  "BR255864217202N": {
    "address": "Rua Quinze de Novembro, 18, Ao lado da NutriPets ra칞칫es\nBairro: Vila (Mosqueiro)\nBel칠m - 66910-000",
    "latitude": -1.1597145,
    "longitude": -48.469059,
    "city": "Bel칠m",
    "zipcode": "66910-000",
    "sequence": 30
  },
  "BR2559482212905": {
    "address": "Rua Quinze de Novembro, 1021, Entre cinco bocas e Get칰lio\nBairro: Vila (Mosqueiro)\nBel칠m - 66910-000",
    "latitude": -1.1600853,
    "longitude": -48.4689713,
    "city": "Bel칠m",
    "zipcode": "66910-000",
    "sequence": 31
  },
  "BR257588309119A": {
    "address": "Rua Quinze de Novembro, 121, Pr칩ximo as cinco bocas\nBairro: Vila (Mosqueiro)\nBel칠m - 66910-000",
    "latitude": -1.1589,
    "longitude": -48.4688988,
    "city": "Bel칠m",
    "zipcode": "66910-000",
    "sequence": 32
  },
  "BR256931637480Z": {
    "address": "Rua Quinze de Novembro, 10, Alemeda terra prometida, Bel칠m, Par치, 66910000\nBel칠m - 66910000",
    "latitude": -1.1587799,
    "longitude": -48.4689636,
    "city": "Bel칠m",
    "zipcode": "66910000",
    "sequence": 33
  },
  "BR2558435081671": {
    "address": "Avenida Dezesseis de Novembro, 2909, Em frente ao quiosque ki gosto\nBairro: Vila (Mosqueiro)\nBel칠m - 66910-140",
    "latitude": -1.1566,
    "longitude": -48.467701,
    "city": "Bel칠m",
    "zipcode": "66910-140",
    "sequence": 34
  },
  "BR258040408902Y": {
    "address": "Rua Padre Manoel Raiol, 220, Muro amarelo com telhas vermel\nBairro: Vila (Mosqueiro)\nBel칠m - 66910-040",
    "latitude": -1.1570348,
    "longitude": -48.467514,
    "city": "Bel칠m",
    "zipcode": "66910-040",
    "sequence": 35
  },
  "BR257612403013T": {
    "address": "Avenida Dezesseis de Novembro, 72, Em frente dep칩sito Xavier ao lado Jo칚o motos\nBairro: Vila (Mosqueiro)\nBel칠m - 66910-140",
    "latitude": -1.1532554,
    "longitude": -48.466176,
    "city": "Bel칠m",
    "zipcode": "66910-140",
    "sequence": 36
  },
  "BR258316357232J": {
    "address": "Avenida Dezesseis de Novembro, 72, Em frente dep칩sito Xavier ao lado Jo칚o motos\nBairro: Vila (Mosqueiro)\nBel칠m - 66910-140",
    "latitude": -1.1532554,
    "longitude": -48.466176,
    "city": "Bel칠m",
    "zipcode": "66910-140",
    "sequence": 37
  },
  "BR2553020039350": {
    "address": "Avenida Dezesseis de Novembro, 72, Em frente dep칩sito Xavier ao lado Jo칚o motos\nBairro: Vila (Mosqueiro)\nBel칠m - 66910-140",
    "latitude": -1.1532554,
    "longitude": -48.466176,
    "city": "Bel칠m",
    "zipcode": "66910-140",
    "sequence": 38
  },
  "BR257648789028P": {
    "address": "Avenida Dezesseis de Novembro, 72, Em frente dep칩sito Xavier ao lado Jo칚o motos\nBairro: Vila (Mosqueiro)\nBel칠m - 66910-140",
    "latitude": -1.1532554,
    "longitude": -48.466176,
    "city": "Bel칠m",
    "zipcode": "66910-140",
    "sequence": 39
  },
  "BR258126401029R": {
    "address": "Avenida Dezesseis de Novembro, 72\nBairro: Vila (Mosqueiro)\nBel칠m - 66910-140",
    "latitude": -1.1532554,
    "longitude": -48.466176,
    "city": "Bel칠m",
    "zipcode": "66910-140",
    "sequence": 40
  },
  "BR2531457461885": {
    "address": "Avenida Dezesseis de Novembro, 72, Em frente deposito Xavier ao lado Jo칚o motos\nBairro: Vila (Mosqueiro)\nBel칠m - 66910-140",
    "latitude": -1.1532554,
    "longitude": -48.466176,
    "city": "Bel칠m",
    "zipcode": "66910-140",
    "sequence": 41
  },
  "BR253333999131P": {
    "address": "Avenida Dezesseis de Novembro, 2391, Ao lado da barbearia adryan\nBairro: Vila (Mosqueiro)\nBel칠m - 66910-140",
    "latitude": -1.1524897,
    "longitude": -48.4659386,
    "city": "Bel칠m",
    "zipcode": "66910-140",
    "sequence": 42
  },
  "BR253625124030V": {
    "address": "Passagem Atl칙ntida, 03, Em frente ao Cantinho Azulino\nBairro: Vila (Mosqueiro)\nBel칠m - 66910-520",
    "latitude": -1.1530946,
    "longitude": -48.4672508,
    "city": "Bel칠m",
    "zipcode": "66910-520",
    "sequence": 43
  },
  "BR257518523148D": {
    "address": "Alameda Ferreira, 28, Ao lado do comercial Ant칪nio\nBairro: Vila (Mosqueiro)\nBel칠m - 66910-050",
    "latitude": -1.1531883,
    "longitude": -48.466831,
    "city": "Bel칠m",
    "zipcode": "66910-050",
    "sequence": 44
  },
  "BR259312148009G": {
    "address": "Passagem Atl칙ntida, 03, Ao lado da  antena\nBairro: Vila (Mosqueiro)\nBel칠m - 66910-520",
    "latitude": -1.1530946,
    "longitude": -48.4672508,
    "city": "Bel칠m",
    "zipcode": "66910-520",
    "sequence": 45
  },
  "BR256031024378C": {
    "address": "Alameda Bela Vista, 6, 16 de novembro/ Camilo salgado\nBairro: Vila (Mosqueiro)\nBel칠m - 66910-390",
    "latitude": -1.1538,
    "longitude": -48.4674988,
    "city": "Bel칠m",
    "zipcode": "66910-390",
    "sequence": 46
  },
  "BR252838900075R": {
    "address": "Travessa Bela Vista, 2, Pr칩ximo ao hospital geral\nBairro: Praia Grande\nBel칠m - 66912-140",
    "latitude": -1.1538016,
    "longitude": -48.4650497,
    "city": "Bel칠m",
    "zipcode": "66912-140",
    "sequence": 47
  },
  "BR250305017276D": {
    "address": "Rua Sandro Carvalho, 68-A, Paquet치\nBairro: Mangueiras (Mosqueiro)\nBel칠m - 66912-180",
    "latitude": -1.1528,
    "longitude": -48.4622993,
    "city": "Bel칠m",
    "zipcode": "66912-180",
    "sequence": 48
  },
  "BR259426316988F": {
    "address": "Rua Sandro Carvalho, 68-A, Paquet치\nBairro: Mangueiras (Mosqueiro)\nBel칠m - 66912-180",
    "latitude": -1.1528,
    "longitude": -48.4622993,
    "city": "Bel칠m",
    "zipcode": "66912-180",
    "sequence": 49
  },
  "BR2573946235544": {
    "address": "Rua Bariloche, 30, Casa\nBairro: Mangueiras (Mosqueiro)\nBel칠m - 66912-130",
    "latitude": -1.1523347,
    "longitude": -48.4615555,
    "city": "Bel칠m",
    "zipcode": "66912-130",
    "sequence": 50
  },
  "BR258040312070F": {
    "address": "Rua Bariloche, 30, Casa\nBairro: Mangueiras (Mosqueiro)\nBel칠m - 66912-130",
    "latitude": -1.1523347,
    "longitude": -48.4615555,
    "city": "Bel칠m",
    "zipcode": "66912-130",
    "sequence": 52
  },
  "BR2561235030362": {
    "address": "Alameda Paquet치, 4, pr칩ximo ao comercial Caroline\nBairro: Mangueiras (Mosqueiro)\nBel칠m - 66912-210",
    "latitude": -1.1530893,
    "longitude": -48.4613724,
    "city": "Bel칠m",
    "zipcode": "66912-210",
    "sequence": 53
  },
  "BR252010309093W": {
    "address": "Alameda Paquet치, 4, pr칩ximo ao comercial Caroline\nBairro: Mangueiras (Mosqueiro)\nBel칠m - 66912-210",
    "latitude": -1.1530893,
    "longitude": -48.4613724,
    "city": "Bel칠m",
    "zipcode": "66912-210",
    "sequence": 54
  },
  "BR2512319420247": {
    "address": "Travessa Santa Helena, O1, Atr치s da loja Dluna Beach\nBairro: Mangueiras (Mosqueiro)\nBel칠m - 66912-200",
    "latitude": -1.1548012,
    "longitude": -48.4614143,
    "city": "Bel칠m",
    "zipcode": "66912-200",
    "sequence": 55
  },
  "BR254841014012P": {
    "address": "Pra칞a do carmo, 27, Bar do seu bene\nBairro: Cidade velha\nBel칠m - 66912-230",
    "latitude": -1.1591978,
    "longitude": -48.4569525,
    "city": "Bel칠m",
    "zipcode": "66912-230",
    "sequence": 56
  },
  "BR258670218678R": {
    "address": "Travessa Bela Vista, 87\nBairro: Mangueiras (Mosqueiro)\nBel칠m - 66912-140",
    "latitude": -1.1542,
    "longitude": -48.4594002,
    "city": "Bel칠m",
    "zipcode": "66912-140",
    "sequence": 57
  },
  "BR254442724443V": {
    "address": "Alameda Paquet치, 900, Final do asfalto lado direito\nBairro: Mangueiras (Mosqueiro)\nBel칠m - 66912-210",
    "latitude": -1.1533793,
    "longitude": -48.4588051,
    "city": "Bel칠m",
    "zipcode": "66912-210",
    "sequence": 58
  },
  "BR257300548797C": {
    "address": "Rua Bahamas, 26\nBairro: Mangueiras (Mosqueiro)\nBel칠m - 66912-120",
    "latitude": -1.1521145,
    "longitude": -48.4601555,
    "city": "Bel칠m",
    "zipcode": "66912-120",
    "sequence": 59
  },
  "BR255604031541B": {
    "address": "Alameda do Carmo, 33, Pr칩ximo a igreja Reis dos Reis\nBairro: Mangueiras (Mosqueiro)\nBel칠m - 66912-230",
    "latitude": -1.1513,
    "longitude": -48.4594002,
    "city": "Bel칠m",
    "zipcode": "66912-230",
    "sequence": 60
  },
  "BR258852981488Q": {
    "address": "Rua Nova, 255\nBairro: Mangueiras (Mosqueiro)\nBel칠m - 66912-080",
    "latitude": -1.1500554,
    "longitude": -48.461853,
    "city": "Bel칠m",
    "zipcode": "66912-080",
    "sequence": 61
  },
  "BR2530998956863": {
    "address": "Avenida Camilo Salgado Filho, 612, Centro Educacional L치pis na M칚\nBairro: Mangueiras (Mosqueiro)\nBel칠m - 66912-250",
    "latitude": -1.1501131,
    "longitude": -48.4624329,
    "city": "Bel칠m",
    "zipcode": "66912-250",
    "sequence": 62
  },
  "BR2556101372242": {
    "address": "Rua do Carmo, 26\nBairro: Praia Grande (Mosqueiro)\nBel칠m - 66914-040",
    "latitude": -1.151163,
    "longitude": -48.4636841,
    "city": "Bel칠m",
    "zipcode": "66914-040",
    "sequence": 63
  },
  "BR257690813744P": {
    "address": "Rua Raimundo Cintra, 33, Atraz da panificadora Martinez\nBairro: Mangueiras (Mosqueiro)\nBel칠m - 66912-220",
    "latitude": -1.1497903,
    "longitude": -48.4638405,
    "city": "Bel칠m",
    "zipcode": "66912-220",
    "sequence": 64
  },
  "BR251048356165R": {
    "address": "Rua Bariloche, 17, Acesso pela sta terezinha\nBairro: Mangueiras (Mosqueiro)\nBel칠m - 66912-130",
    "latitude": -1.1482842,
    "longitude": -48.4596596,
    "city": "Bel칠m",
    "zipcode": "66912-130",
    "sequence": 65
  },
  "BR251297883486O": {
    "address": "Rua Bariloche, 17, Acesso pela rua santa Terezinh\nBairro: Mangueiras (Mosqueiro)\nBel칠m - 66912-130",
    "latitude": -1.1482842,
    "longitude": -48.4596596,
    "city": "Bel칠m",
    "zipcode": "66912-130",
    "sequence": 66
  },
  "BR2502916709275": {
    "address": "Ria nova, 195\nBairro: Mangueiras (Mosqueiro)\nBel칠m - 66912-060",
    "latitude": -1.1469001,
    "longitude": -48.4600983,
    "city": "Bel칠m",
    "zipcode": "66912-060",
    "sequence": 67
  },
  "BR250880859719J": {
    "address": "Avenida Principal, 14, Rua ao lado do varej칚o do cime\nBairro: Mangueiras (Mosqueiro)\nBel칠m - 66912-040",
    "latitude": -1.1448848,
    "longitude": -48.4607849,
    "city": "Bel칠m",
    "zipcode": "66912-040",
    "sequence": 68
  },
  "BR258628300510C": {
    "address": "Avenida Principal, 14, Rua ao lado do varej칚o do cime\nBairro: Mangueiras (Mosqueiro)\nBel칠m - 66912-040",
    "latitude": -1.1448848,
    "longitude": -48.4607849,
    "city": "Bel칠m",
    "zipcode": "66912-040",
    "sequence": 69
  },
  "BR257630269023H": {
    "address": "Avenida Principal, 14, Rua ao lado do varej칚o do cime\nBairro: Mangueiras (Mosqueiro)\nBel칠m - 66912-040",
    "latitude": -1.1448848,
    "longitude": -48.4607849,
    "city": "Bel칠m",
    "zipcode": "66912-040",
    "sequence": 70
  },
  "BR252728742822U": {
    "address": "Alameda Teres칩polis, 182, Rua da creche\nBairro: Mangueiras (Mosqueiro)\nBel칠m - 66912-060",
    "latitude": -1.143436,
    "longitude": -48.4600372,
    "city": "Bel칠m",
    "zipcode": "66912-060",
    "sequence": 71
  },
  "BR255642613681K": {
    "address": "Alameda Petr칩polis, 1000, Casa amarela con rosa\nBairro: Praia Grande (Mosqueiro)\nBel칠m - 66914-100",
    "latitude": -1.1434402,
    "longitude": -48.4619141,
    "city": "Bel칠m",
    "zipcode": "66914-100",
    "sequence": 72
  },
  "BR251146466899J": {
    "address": "Avenida Dezesseis de Novembro, 1220, Mundo dos colch칫es ao lado do\nBairro: Vila (Mosqueiro)\nBel칠m - 66910-140",
    "latitude": -1.1423743,
    "longitude": -48.461216,
    "city": "Bel칠m",
    "zipcode": "66910-140",
    "sequence": 73
  },
  "BR256373097735V": {
    "address": "Avenida Dezesseis de Novembro, 1220, Mundo dos colch칫es ao lado do\nBairro: Vila (Mosqueiro)\nBel칠m - 66910-140",
    "latitude": -1.1423743,
    "longitude": -48.461216,
    "city": "Bel칠m",
    "zipcode": "66910-140",
    "sequence": 74
  }
};
</script>

<!-- Google Maps -->
<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyApaDb9rSw2sNTaY7fjBqmrgjWYD9xwjcU&loading=async&callback=initMap&v=beta&libraries=places,geometry,marker,maps3d"></script>

<script>
'use strict';

/* ===========================
   GLOBAL VARIABLES
   =========================== */
let map;
let is3D = false;
let routeMode = false;
let currentInfoWindow = null;

// Legacy global variables (mantidas para compatibilidade)
let userLocationMarker = null;
let watchId = null;
let _animating3D = false;
let locationAccuracy = null;
let deliveryMarkers = {};
let directionsService = null;
let directionsRenderer = null;
let currentTween = null;
let markerCoords = { lat: 0, lng: 0 };

// IMPORTANTE: Inicializar array de polylines globalmente
if (!window.routePolylines) {
    window.routePolylines = [];
}

// ===========================
// FUN칂츾O DE DEBOUNCE (OTIMIZA칂츾O DE PERFORMANCE)
// ===========================
// Evita executar fun칞칫es m칰ltiplas vezes durante intera칞칫es do mapa (drag, zoom, etc)
function debounce(func, wait = 500) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// ===========================
// MODO DE NAVEGA칂츾O EM TEMPO REAL
// ===========================
let navigationMode = {
    active: false,
    destination: null,
    destinationName: '',
    destinationMarker: null,
    destinationInfoWindow: null,
    lastHeading: 0,
    lastPosition: null,
    followInterval: null,
    lastRerouteTime: null, // Para controlar frequ칡ncia de rec치lculo de rota
    userInteracting: false, // Flag para detectar intera칞칚o do usu치rio
    lastUserInteraction: null, // Timestamp da 칰ltima intera칞칚o
    autoResumeTimeout: null, // Timeout para retomar controle autom치tico
    systemUpdating: false // Flag para ignorar eventos quando o sistema est치 atualizando
};

// Retomar navega칞칚o com centraliza칞칚o suave (Google Maps style)
function forceCenterOnGPS() {
    if (!navigationMode.active || !map) return;

    // Obter posi칞칚o atual do GPS
    let currentPos = null;
    if (gpsTracker && gpsTracker.marker) {
        const pos = gpsTracker.marker.position || (gpsTracker.marker.getPosition && gpsTracker.marker.getPosition());
        if (pos) {
            currentPos = { lat: pos.lat, lng: pos.lng };
        }
    } else if (userLocationMarker) {
        const pos = userLocationMarker.position || (userLocationMarker.getPosition && userLocationMarker.getPosition());
        if (pos) {
            currentPos = { lat: pos.lat, lng: pos.lng };
        }
    }

    if (!currentPos) return;

    // Marcar que o SISTEMA est치 atualizando (n칚o o usu치rio) - EVITAR LOOP
    navigationMode.systemUpdating = true;

    // Usar o MESMO heading que est치 sendo usado na navega칞칚o cont칤nua (movementHeading)
    const targetHeading = navigationMode.lastHeading || 0;

    // CENTRALIZA칂츾O ID칅NTICA  navega칞칚o normal
    map.panTo(currentPos);

    if (map.setHeading) {
        map.setHeading(targetHeading);
    }

    // Manter zoom adequado para navega칞칚o (MESMA L칍GICA)
    const currentZoom = map.getZoom();
    if (currentZoom < 17) {
        map.setZoom(17);
    } else if (currentZoom > 19) {
        map.setZoom(18);
    }

    // Manter inclina칞칚o 3D para navega칞칚o (MESMA L칍GICA)
    if (map.setTilt && map.getTilt() === 0) {
        map.setTilt(45);
    }

    // Resetar flag ap칩s um pequeno delay
    setTimeout(() => {
        navigationMode.systemUpdating = false;
    }, 100);

    console.log('游댃 Retomando controle autom치tico - centraliza칞칚o instant칙nea');
}

// Detectar quando usu치rio interage com o mapa durante navega칞칚o
function setupNavigationMapInteraction() {
    if (!map) return;

    // Eventos que indicam intera칞칚o do usu치rio
    const interactionEvents = ['drag', 'zoom_changed', 'heading_changed', 'tilt_changed'];

    interactionEvents.forEach(eventName => {
        map.addListener(eventName, () => {
            // IGNORAR eventos quando o sistema est치 atualizando (evita loop)
            if (navigationMode.systemUpdating) {
                return;
            }

            if (navigationMode.active) {
                // Marcar que usu치rio est치 interagindo
                navigationMode.userInteracting = true;
                navigationMode.lastUserInteraction = Date.now();

                // Limpar timeout anterior
                if (navigationMode.autoResumeTimeout) {
                    clearTimeout(navigationMode.autoResumeTimeout);
                }

                console.log('九 Usu치rio interagiu - pausando navega칞칚o autom치tica');

                // Retomar controle autom치tico ap칩s 8 segundos sem intera칞칚o
                navigationMode.autoResumeTimeout = setTimeout(() => {
                    navigationMode.userInteracting = false;
                    console.log('游댃 Retomando controle autom치tico');

                    // For칞ar centraliza칞칚o
                    forceCenterOnGPS();
                }, 8000); // 8 segundos
            }
        });
    });
}

// Calcular heading (dire칞칚o) entre duas posi칞칫es
function calculateHeading(from, to) {
    const lat1 = from.lat * Math.PI / 180;
    const lat2 = to.lat * Math.PI / 180;
    const dLng = (to.lng - from.lng) * Math.PI / 180;

    const y = Math.sin(dLng) * Math.cos(lat2);
    const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLng);

    let heading = Math.atan2(y, x) * 180 / Math.PI;
    heading = (heading + 360) % 360; // Normalizar para 0-360

    return heading;
}

// Calcular dist칙ncia entre duas posi칞칫es em metros
function calculateDistanceMeters(from, to) {
    const R = 6371000; // Raio da Terra em metros
    const lat1 = from.lat * Math.PI / 180;
    const lat2 = to.lat * Math.PI / 180;
    const dLat = (to.lat - from.lat) * Math.PI / 180;
    const dLng = (to.lng - from.lng) * Math.PI / 180;

    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1) * Math.cos(lat2) *
              Math.sin(dLng/2) * Math.sin(dLng/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

    return R * c;
}

// Iniciar modo de navega칞칚o
function startNavigationMode(destination, destinationName, marker = null, infoWindow = null, clientData = null) {
    navigationMode.active = true;
    navigationMode.destination = destination;
    navigationMode.destinationName = destinationName;
    navigationMode.destinationMarker = marker;
    navigationMode.destinationInfoWindow = infoWindow;
    navigationMode.clientData = clientData; // Armazenar dados do cliente
    navigationMode.lastPosition = null;

    console.log('游빐 Modo de navega칞칚o iniciado:', destinationName);

    // Fechar InfoWindow atual
    if (currentInfoWindow) {
        currentInfoWindow.close();
        currentInfoWindow = null;
    }

    // Mostrar bot칚o de parar navega칞칚o
    const btnStopNav = document.getElementById('btnStopNavigation');
    if (btnStopNav) {
        btnStopNav.style.display = 'flex';
    }

    // Ocultar bot칚o adicionar cliente
    const btnAddClient = document.getElementById('btn-add-client');
    if (btnAddClient) {
        btnAddClient.style.display = 'none';
    }

    // Mostrar toast informativo
    showToast(
        '游빐 Navega칞칚o ativa',
        'O mapa seguir치 seu ve칤culo automaticamente',
        'info',
        4000
    );

    // Iniciar acompanhamento
    if (navigationMode.followInterval) {
        clearInterval(navigationMode.followInterval);
    }

    navigationMode.followInterval = setInterval(() => {
        updateNavigationView();
    }, 200); // Atualizar a cada 200ms para acompanhar em tempo real
}

// Parar modo de navega칞칚o
function stopNavigationMode() {
    navigationMode.active = false;
    navigationMode.destination = null;
    navigationMode.destinationName = '';
    navigationMode.userInteracting = false; // Resetar flag de intera칞칚o

    if (navigationMode.followInterval) {
        clearInterval(navigationMode.followInterval);
        navigationMode.followInterval = null;
    }

    // Limpar timeout de retomada autom치tica
    if (navigationMode.autoResumeTimeout) {
        clearTimeout(navigationMode.autoResumeTimeout);
        navigationMode.autoResumeTimeout = null;
    }

    // Esconder bot칚o de parar navega칞칚o
    const btnStopNav = document.getElementById('btnStopNavigation');
    if (btnStopNav) {
        btnStopNav.style.display = 'none';
    }

    // Mostrar bot칚o adicionar cliente novamente
    const btnAddClient = document.getElementById('btn-add-client');
    if (btnAddClient) {
        btnAddClient.style.display = 'flex';
    }

    // Limpar linha azul do trajeto
    if (window.routePolylines && window.routePolylines.length > 0) {
        window.routePolylines.forEach(polyline => {
            if (polyline && polyline.setMap) {
                polyline.setMap(null);
            }
        });
        window.routePolylines = [];
    }

    // Resetar rota칞칚o e inclina칞칚o do mapa
    if (map) {
        if (map.setHeading) {
            map.setHeading(0);
        }
        if (map.setTilt) {
            map.setTilt(0);
        }
    }

    console.log('游띔 Modo de navega칞칚o encerrado');

    showToast(
        '游띔 Navega칞칚o encerrada',
        'Modo de acompanhamento desativado',
        'info',
        3000
    );
}

// ===========================
// MARCAR COMO N츾O ENTREGUE
// ===========================

async function markAsNotDelivered(marker, client, notDeliveredBtn = null) {
    if (!marker) return;

    console.log('仇 Marcando como n칚o entregue:', client);
    console.log('游댌 Marker:', marker);
    console.log('游댌 Marker.deliveries:', marker.deliveries);
    console.log('游댌 Marker.originalState:', marker.originalState);

    try {
        // Obter os IDs das entregas associadas a este marcador
        let deliveryIds = [];
        let deliveries = [];

        if (marker.originalState && marker.originalState.deliveries) {
            deliveries = marker.originalState.deliveries;
            deliveryIds = deliveries.map(d => d.id);
            console.log('九 Usando marker.originalState.deliveries:', deliveryIds);
        } else if (marker.deliveries) {
            deliveries = marker.deliveries;
            deliveryIds = deliveries.map(d => d.id);
            console.log('九 Usando marker.deliveries:', deliveryIds);

            // 游댠 Salvar estado original se ainda n칚o existe
            if (!marker.originalState) {
                // Determinar se 칠 verde ou vermelho
                const isGreen = marker.content && marker.content.querySelector('div')?.style.background?.includes('4CAF50');

                marker.originalState = {
                    deliveries: deliveries,
                    client: client,
                    coordKey: null,
                    isGreen: isGreen
                };
            }
        } else {
            console.error('仇 Marcador n칚o possui deliveries!');
        }

        if (deliveryIds.length > 0) {
            // Atualizar status no Supabase para cada entrega
            // Apenas status, sem not_delivered_at (coluna pode n칚o existir)
            const { data, error } = await supabase
                .from('delivery_data')
                .update({
                    status: 'not_delivered'
                })
                .in('id', deliveryIds)
                .select(); // Adicionar select() para retornar os dados atualizados

            if (error) {
                console.error('仇 ERRO ao atualizar Supabase (not_delivered):', error);
                console.error('仇 Mensagem:', error.message);
                console.error('仇 Detalhes:', error.details);
                console.error('仇 Hint:', error.hint);
                showToast(
                    '仇 Erro ao salvar',
                    error.message || 'N칚o foi poss칤vel salvar no banco',
                    'error',
                    5000
                );
                throw error;
            }

            console.log(`九 ${deliveryIds.length} entrega(s) marcada(s) como n칚o entregue no banco de dados`);
            console.log('九 Dados retornados do Supabase:', data);
        } else {
            console.warn('丘멆잺 Nenhum delivery ID encontrado no marcador!');
            showToast(
                '丘멆잺 Aviso',
                'Marcador n칚o possui entregas associadas',
                'warning',
                3000
            );
            return;
        }

        // Marcar o marcador como n칚o entregue
        marker.isNotDelivered = true;
        marker.notDeliveredTimestamp = Date.now();

        // Criar overlay com X vermelho sobre o marcador
        addNotDeliveredOverlay(marker);

        // Deixar cinza igual ao entregue (apenas o X vermelho diferencia)
        if (marker.content) {
            marker.content.style.opacity = '0.4'; // Mesma opacidade do entregue
            marker.content.style.filter = 'grayscale(100%)'; // Cinza total igual ao entregue
        }

        // 游댠 Transformar bot칚o em "Desfazer" (laranja)
        if (notDeliveredBtn) {
            notDeliveredBtn.innerHTML = ' Desfazer';
            notDeliveredBtn.style.background = '#FF9800'; // Laranja

            // Remover eventos antigos
            notDeliveredBtn.removeEventListener('mouseenter', notDeliveredBtn._hoverIn);
            notDeliveredBtn.removeEventListener('mouseleave', notDeliveredBtn._hoverOut);

            // Adicionar novos eventos de hover para laranja
            notDeliveredBtn._hoverIn = () => { notDeliveredBtn.style.background = '#e68900'; };
            notDeliveredBtn._hoverOut = () => { notDeliveredBtn.style.background = '#FF9800'; };
            notDeliveredBtn.addEventListener('mouseenter', notDeliveredBtn._hoverIn);
            notDeliveredBtn.addEventListener('mouseleave', notDeliveredBtn._hoverOut);
        }

        // Toast removido - a칞칚o visual j치 indica o status
    } catch (error) {
        console.error('Erro ao marcar como n칚o entregue:', error);
    }
}

// Adicionar overlay de X vermelho no marcador
function addNotDeliveredOverlay(marker) {
    if (!marker || !marker.content) return;

    // Criar div do X vermelho
    const xOverlay = document.createElement('div');
    xOverlay.className = 'not-delivered-x';
    xOverlay.style.position = 'absolute';
    xOverlay.style.top = '-5px';
    xOverlay.style.left = '-5px';
    xOverlay.style.width = '42px';
    xOverlay.style.height = '42px';
    xOverlay.style.display = 'flex';
    xOverlay.style.alignItems = 'center';
    xOverlay.style.justifyContent = 'center';
    xOverlay.style.fontSize = '32px';
    xOverlay.style.fontWeight = 'bold';
    xOverlay.style.color = '#EA4335';
    xOverlay.style.textShadow = '0 0 4px white, 0 0 8px white';
    xOverlay.style.pointerEvents = 'none';
    xOverlay.style.zIndex = '1000';
    xOverlay.style.filter = 'none'; // 游댠 Garantir que o X n칚o seja afetado pelo grayscale do pai
    xOverlay.innerHTML = '九';

    // Adicionar ao marcador
    marker.content.style.position = 'relative';
    marker.content.appendChild(xOverlay);
}

// Salvar n칚o entregue (apenas log, sem localStorage devido ao iframe)
function saveNotDeliveredToLocalStorage(client) {
    const deliveryData = {
        name: client.name,
        address: client.address,
        latitude: client.latitude,
        longitude: client.longitude,
        timestamp: Date.now(),
        date: new Date().toISOString()
    };

    console.log('游 N칚o entregue registrada:', deliveryData);
}

// Substituir bot칚o "Navegar" por "N칚o Entregue" quando chega no destino
function replaceNavigateButtonWithNotDelivered(marker, infoWindow, client) {
    if (!infoWindow || !marker) return;

    // Obter o conte칰do atual do InfoWindow
    const content = infoWindow.getContent();

    // Se o conte칰do for um elemento DOM
    if (content && content.querySelectorAll) {
        // Procurar todos os bot칫es
        const buttons = content.querySelectorAll('button');

        buttons.forEach(btn => {
            // Procurar o bot칚o que cont칠m "Navegar" no texto
            if (btn.innerHTML && (btn.innerHTML.includes('游빐 Navegar') || btn.innerHTML.includes('Navegar'))) {
                // Substituir o bot칚o Navegar por N칚o Entregue
                btn.innerHTML = '仇 N칚o Entregue';
                btn.style.background = '#EA4335';
                btn.style.color = 'white';

                // Remover eventos antigos
                const newBtn = btn.cloneNode(true);
                btn.parentNode.replaceChild(newBtn, btn);

                // Adicionar novos eventos
                newBtn.addEventListener('mouseenter', () => { newBtn.style.background = '#c5351c'; });
                newBtn.addEventListener('mouseleave', () => { newBtn.style.background = '#EA4335'; });
                newBtn.addEventListener('click', () => {
                    markAsNotDelivered(marker, client);
                    if (currentInfoWindow) {
                        currentInfoWindow.close();
                    }
                });
            }
        });
    }
}

// REC츼LCULO AUTOM츼TICO DE ROTA (quando sai do trajeto)
// 九 Fun칞칚o original (ser치 chamada com debounce)
async function checkAndRerouteIfNeededCore(currentPos) {
    // S칩 verifica se h치 uma rota ativa
    if (!window.routePolylines || window.routePolylines.length === 0) return;

    const routePath = window.routePolylines[0].getPath();
    if (!routePath || routePath.getLength() === 0) return;

    // Calcular dist칙ncia m칤nima at칠 a linha da rota
    let minDistance = Infinity;
    for (let i = 0; i < routePath.getLength(); i++) {
        const point = routePath.getAt(i);
        const distance = calculateDistanceMeters(currentPos, { lat: point.lat(), lng: point.lng() });
        if (distance < minDistance) {
            minDistance = distance;
        }
    }

    // Se est치 a mais de 50 metros da rota, recalcular
    const REROUTE_THRESHOLD = 50; // metros

    if (minDistance > REROUTE_THRESHOLD) {
        // Evitar rec치lculos muito frequentes (apenas 1 vez a cada 10 segundos)
        const now = Date.now();
        if (!navigationMode.lastRerouteTime || (now - navigationMode.lastRerouteTime) > 10000) {
            navigationMode.lastRerouteTime = now;

            console.log(`游댃 Fora da rota (${minDistance.toFixed(0)}m). Recalculando...`);

            showToast(
                '游댃 Recalculando rota...',
                'Voc칡 saiu do trajeto planejado',
                'info',
                2000
            );

            // Recalcular rota do ponto atual at칠 o destino
            await recalculateRoute(currentPos, navigationMode.destination);
        }
    }
}

// 九 Vers칚o com debounce (evita rec치lculos excessivos durante movimenta칞칚o)
const checkAndRerouteIfNeeded = debounce(checkAndRerouteIfNeededCore, 500);

// Recalcular rota com nova origem
async function recalculateRoute(origin, destination) {
    try {
        const directionsService = new google.maps.DirectionsService();

        const request = {
            origin: origin,
            destination: destination,
            travelMode: google.maps.TravelMode.DRIVING,
            optimizeWaypoints: false,
            language: 'pt-BR',
            region: 'BR'
        };

        const result = await directionsService.route(request);

        if (result.status === 'OK') {
            // Limpar rota antiga
            if (window.routePolylines && window.routePolylines.length > 0) {
                window.routePolylines.forEach(polyline => {
                    if (polyline.setMap) {
                        polyline.setMap(null);
                    }
                });
                window.routePolylines = [];
            }

            // Desenhar nova rota
            const route = result.routes[0];
            const leg = route.legs[0];

            const polyline = new google.maps.Polyline({
                path: route.overview_path,
                geodesic: true,
                strokeColor: '#4285f4',
                strokeOpacity: 0.8,
                strokeWeight: 5,
                map: map
            });

            window.routePolylines = [polyline];

            // Formatar dist칙ncia e dura칞칚o
            const distance = leg.distance.text;
            const duration = leg.duration.text;

            showToast(
                '九 Nova rota calculada',
                `游늺 ${distance}  낌勇 ${duration}`,
                'success',
                3000
            );

            console.log('九 Rota recalculada:', {
                distance: leg.distance,
                duration: leg.duration
            });

        } else {
            console.error('Erro ao recalcular rota:', result.status);
        }

    } catch (error) {
        console.error('Erro ao recalcular rota:', error);
    }
}

// Atualizar visualiza칞칚o durante navega칞칚o
function updateNavigationView() {
    if (!navigationMode.active || !navigationMode.destination) return;

    // Obter posi칞칚o atual do GPS
    let currentPos = null;
    if (gpsTracker && gpsTracker.marker) {
        const pos = gpsTracker.marker.position || (gpsTracker.marker.getPosition && gpsTracker.marker.getPosition());
        if (pos) {
            currentPos = { lat: pos.lat, lng: pos.lng };
        }
    } else if (userLocationMarker) {
        const pos = userLocationMarker.position || (userLocationMarker.getPosition && userLocationMarker.getPosition());
        if (pos) {
            currentPos = { lat: pos.lat, lng: pos.lng };
        }
    }

    if (!currentPos) return;

    // Calcular dist칙ncia at칠 o destino
    const distanceToDestination = calculateDistanceMeters(currentPos, navigationMode.destination);

    // VERIFICAR SE EST츼 FORA DA ROTA (Rec치lculo autom치tico)
    checkAndRerouteIfNeeded(currentPos);

    // Verificar se chegou ao destino (< 30 metros)
    if (distanceToDestination < 30) {
        // Salvar refer칡ncias antes de parar navega칞칚o
        const arrivedMarker = navigationMode.destinationMarker;
        const arrivedInfoWindow = navigationMode.destinationInfoWindow;
        const arrivedDestination = navigationMode.destination;
        const arrivedClient = navigationMode.clientData; // Salvar dados do cliente

        showToast(
            '游꿀 Voc칡 chegou!',
            `Destino: ${navigationMode.destinationName}`,
            'success',
            5000
        );

        // Marcar que chegou no destino
        if (arrivedMarker) {
            arrivedMarker.arrivedAtDestination = true;
        }

        stopNavigationMode();

        // Reabrir InfoWindow do destino ap칩s pequeno delay com bot칚o modificado
        setTimeout(() => {
            if (arrivedInfoWindow && arrivedMarker) {
                // Centralizar no destino
                if (arrivedDestination) {
                    map.panTo(arrivedDestination);
                    map.setZoom(18);
                }

                // 仇 REMOVIDO: N칚o precisa mais substituir o bot칚o, agora "N칚o Entregue" aparece sempre
                // replaceNavigateButtonWithNotDelivered(arrivedMarker, arrivedInfoWindow, arrivedClient);

                // Abrir InfoWindow
                arrivedInfoWindow.open(map, arrivedMarker);
                currentInfoWindow = arrivedInfoWindow;
            }
        }, 500);

        return;
    }

    // =================================================================
    // ROTA칂츾O DO MAPA - Navega칞칚o estilo Google Maps
    // O mapa gira para que a dire칞칚o do MOVIMENTO sempre aponte PARA CIMA
    // Como se estivesse usando o celular em p칠 em um suporte
    // =================================================================

    // Calcular heading baseado na dire칞칚o do MOVIMENTO (posi칞칚o anterior  atual)
    let movementHeading = navigationMode.lastHeading || 0;

    if (navigationMode.lastPosition) {
        const movementDistance = calculateDistanceMeters(navigationMode.lastPosition, currentPos);

        // Gira quando se mover mais de 3 metros
        const MIN_DISTANCE_FOR_ROTATION = 3;

        if (movementDistance > MIN_DISTANCE_FOR_ROTATION) {
            // Calcular dire칞칚o do movimento: de onde vim  para onde estou indo
            const newHeading = calculateHeading(navigationMode.lastPosition, currentPos);

            // Suavizar a transi칞칚o do heading para evitar saltos bruscos
            if (movementHeading !== 0 && navigationMode.lastHeading !== undefined) {
                let diff = newHeading - movementHeading;

                // Normalizar diferen칞a para o menor caminho (ex: de 350춿 para 10춿 칠 +20춿, n칚o -340춿)
                if (diff > 180) diff -= 360;
                if (diff < -180) diff += 360;

                // Smoothing factor 0.5 - gira r치pido mas suave
                const SMOOTHING_FACTOR = 0.5;

                movementHeading = (movementHeading + diff * SMOOTHING_FACTOR + 360) % 360;
            } else {
                // Primeira vez - usar diretamente o novo heading
                movementHeading = newHeading;
            }

            // Atualiza o 칰ltimo heading conhecido
            navigationMode.lastHeading = movementHeading;
        }
        // Se dist칙ncia < 3m, mant칠m heading anterior (n칚o gira quando parado)
    } else {
        // Primeira posi칞칚o - usar dire칞칚o para o destino como inicial
        movementHeading = calculateHeading(currentPos, navigationMode.destination);
        navigationMode.lastHeading = movementHeading;
    }

    navigationMode.lastPosition = currentPos;

    // 九 PERMITIR INTERA칂츾O DO USU츼RIO
    if (!navigationMode.userInteracting && map) {
        // Marcar que o SISTEMA est치 atualizando (n칚o o usu치rio)
        navigationMode.systemUpdating = true;

        // Acompanhamento suave do GPS (centraliza o marcador azul)
        map.panTo(currentPos);

        // Rota칞칚o para que a dire칞칚o do movimento aponte PARA CIMA (SEM invers칚o!)
        if (map.setHeading) {
            map.setHeading(movementHeading);
        }

        // Manter zoom adequado para navega칞칚o
        const currentZoom = map.getZoom();
        if (currentZoom < 17) {
            map.setZoom(17);
        } else if (currentZoom > 19) {
            map.setZoom(18);
        }

        // Manter perspectiva 3D para navega칞칚o
        if (map.setTilt && map.getTilt() !== 45) {
            map.setTilt(45);
        }

        // Resetar flag ap칩s um pequeno delay
        setTimeout(() => {
            navigationMode.systemUpdating = false;
        }, 100);
    }
    // Se usu치rio estiver interagindo, n칚o fazer nada (deixar ele controlar o mapa)
}

// Loop de anima칞칚o Tween.js (sincronizado com requestAnimationFrame)
function animateTweens(time) {
    requestAnimationFrame(animateTweens);
    TWEEN.update(time);
}
requestAnimationFrame(animateTweens);

/* ===========================
   M칍DULO: GPS TRACKER (HIGH PRECISION)
   =========================== */
class GPSTracker {
    constructor() {
        this.marker = null;
        this.watchId = null;
        this.accuracy = null;
        this.positionHistory = [];
        this.lastUpdate = 0;
        this.currentTween = null;
        this.markerCoords = { lat: 0, lng: 0 };
        this.animationFrameId = null; // Para anima칞칚o suave com requestAnimationFrame

        // Kalman Filter state
        this.kalman = {
            lat: null,
            lng: null,
            variance: null // Incerteza estimada
        };
        this.kalmanQ = 0.1; // MUITO ALTO - confiar quase totalmente nas novas leituras
        this.lastGoodPosition = null;
        this.consecutiveGoodReadings = 0;

        // Configura칞칫es ULTRA AGRESSIVAS para rastreamento instant칙neo de ve칤culo
        this.config = {
            updateThrottle: 0,          // SEM throttle - atualizar IMEDIATAMENTE
            maxAccuracyThreshold: 500,  // Aceitar qualquer leitura at칠 500m
            targetAccuracy: 50,         // Meta relaxada para ve칤culo
            historySize: 1,             // Sem hist칩rico - usar 칰ltima leitura
            highAccuracy: true,
            timeout: 30000,             // Timeout 30s para n칚o perder leituras
            maximumAge: 0,              // Sempre dados frescos
            minReadingsForStable: 1     // 1 leitura 칠 suficiente
        };
    }

    async start() {
        if (!navigator.geolocation) {
            throw new Error('Geolocaliza칞칚o n칚o suportada');
        }

        const options = {
            enableHighAccuracy: this.config.highAccuracy,
            timeout: this.config.timeout,
            maximumAge: this.config.maximumAge
        };

        return new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    this.createMarker(position);
                    this.startWatching(options);
                    resolve(position);
                },
                (error) => reject(error),
                options
            );
        });
    }

    createMarker(position) {
        const coords = {
            lat: position.coords.latitude,
            lng: position.coords.longitude
        };

        this.accuracy = position.coords.accuracy;
        this.markerCoords = coords;

        // Container principal do marcador
        const markerDiv = document.createElement('div');
        markerDiv.className = 'location-marker active';

        // Anel de precis칚o (pulso)
        const pulseDiv = document.createElement('div');
        pulseDiv.className = 'location-marker-pulse';
        markerDiv.appendChild(pulseDiv);

        // Bolinha azul central
        const dotDiv = document.createElement('div');
        dotDiv.className = 'location-marker-dot';
        markerDiv.appendChild(dotDiv);

        // Guardar refer칡ncias para contra-rota칞칚o
        this.markerElement = markerDiv;
        this.pulseElement = pulseDiv;
        this.dotElement = dotDiv;

        if (google.maps.marker && google.maps.marker.AdvancedMarkerElement) {
            this.marker = new google.maps.marker.AdvancedMarkerElement({
                map: map,
                position: coords,
                content: markerDiv,
                title: "Sua Localiza칞칚o"
            });
        } else {
            this.marker = new google.maps.Marker({
                map: map,
                position: coords,
                title: "Sua Localiza칞칚o",
                icon: {
                    path: google.maps.SymbolPath.CIRCLE,
                    scale: 8,
                    fillColor: "#4285f4",
                    fillOpacity: 1,
                    strokeColor: "white",
                    strokeWeight: 3
                }
            });
        }

        // Atualizar refer칡ncias globais (compatibilidade)
        userLocationMarker = this.marker;
        locationAccuracy = this.accuracy;
        markerCoords = this.markerCoords;

        // Listener para contra-rotacionar o marcador quando o mapa gira
        // Mant칠m o marcador sempre na posi칞칚o fixa (n칚o gira com o mapa)
        this.headingListener = map.addListener('heading_changed', () => {
            this.counterRotateMarker();
        });

        // Aplicar contra-rota칞칚o inicial
        this.counterRotateMarker();
    }

    // Contra-rotaciona o marcador para manter orienta칞칚o fixa
    counterRotateMarker() {
        if (!this.pulseElement || !this.dotElement) return;

        const heading = map.getHeading() || 0;
        // Aplicar rota칞칚o inversa aos elementos internos
        this.pulseElement.style.transform = `translate(-50%, -50%) rotate(${-heading}deg)`;
        this.dotElement.style.transform = `translate(-50%, -50%) rotate(${-heading}deg)`;
    }

    startWatching(options) {
        this.watchId = navigator.geolocation.watchPosition(
            (position) => this.updatePosition(position),
            (error) => this.handleError(error),
            options
        );
        watchId = this.watchId; // Compatibilidade global
    }

    updatePosition(position) {
        const accuracy = position.coords.accuracy;
        const lat = position.coords.latitude;
        const lng = position.coords.longitude;

        // Usar posi칞칚o direta
        const newPos = { lat, lng };

        // Atualizar marcador com anima칞칚o suave
        if (this.marker) {
            this.animateMarkerSmooth(newPos);
            this.accuracy = accuracy;
            locationAccuracy = accuracy;

            // Indicador visual de qualidade do sinal
            const qualityIcon = accuracy <= 10 ? '游꿢' : accuracy <= 30 ? '游늸' : '游니';
            updateStatus(`${qualityIcon} GPS: ${accuracy.toFixed(0)}m`, true);
        }
    }

    // Anima칞칚o suave usando requestAnimationFrame (como Google Maps)
    animateMarkerSmooth(newPosition) {
        if (!this.marker) return;

        // Cancelar anima칞칚o anterior se existir
        if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
        }

        const startPos = { ...this.markerCoords };
        const endPos = newPosition;
        const duration = 250; // 250ms - suave mas r치pido
        const startTime = performance.now();

        // Se 칠 a primeira posi칞칚o, definir diretamente
        if (startPos.lat === 0 && startPos.lng === 0) {
            this.markerCoords = endPos;
            markerCoords = endPos;
            this.setMarkerPosition(endPos);
            return;
        }

        const animate = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);

            // Easing suave (ease-out cubic)
            const easeProgress = 1 - Math.pow(1 - progress, 3);

            // Interpolar posi칞칚o
            const currentPos = {
                lat: startPos.lat + (endPos.lat - startPos.lat) * easeProgress,
                lng: startPos.lng + (endPos.lng - startPos.lng) * easeProgress
            };

            // Atualizar marcador
            this.setMarkerPosition(currentPos);
            this.markerCoords = currentPos;
            markerCoords = currentPos;

            // Continuar anima칞칚o se n칚o terminou
            if (progress < 1) {
                this.animationFrameId = requestAnimationFrame(animate);
            } else {
                // Garantir posi칞칚o final exata
                this.markerCoords = endPos;
                markerCoords = endPos;
                this.setMarkerPosition(endPos);
                this.animationFrameId = null;
            }
        };

        this.animationFrameId = requestAnimationFrame(animate);
    }

    // Fun칞칚o auxiliar para definir posi칞칚o do marcador
    setMarkerPosition(position) {
        if (!this.marker) return;

        if (this.marker.position !== undefined) {
            // AdvancedMarkerElement
            this.marker.position = position;
        } else if (this.marker.setPosition) {
            // Marker cl치ssico
            this.marker.setPosition(position);
        }
    }

    // Filtro de Kalman 1D aplicado a lat/lng
    applyKalmanFilter(lat, lng, accuracy) {
        // Vari칙ncia da medi칞칚o (baseada na precis칚o GPS)
        const measurementVariance = accuracy * accuracy;

        // Primeira medi칞칚o - inicializar
        if (this.kalman.lat === null) {
            this.kalman.lat = lat;
            this.kalman.lng = lng;
            this.kalman.variance = measurementVariance;
            return { lat, lng };
        }

        // Predi칞칚o: aumentar incerteza com o tempo
        this.kalman.variance += this.kalmanQ;

        // Ganho de Kalman: quanto confiar na nova medi칞칚o
        const kalmanGain = this.kalman.variance / (this.kalman.variance + measurementVariance);

        // Atualiza칞칚o: combinar predi칞칚o com medi칞칚o
        this.kalman.lat = this.kalman.lat + kalmanGain * (lat - this.kalman.lat);
        this.kalman.lng = this.kalman.lng + kalmanGain * (lng - this.kalman.lng);

        // Atualizar vari칙ncia
        this.kalman.variance = (1 - kalmanGain) * this.kalman.variance;

        return {
            lat: this.kalman.lat,
            lng: this.kalman.lng
        };
    }

    calculateSmoothedPosition() {
        if (this.positionHistory.length === 0) return null;

        // Se temos uma posi칞칚o est치vel recente, usar ela
        if (this.lastGoodPosition && this.consecutiveGoodReadings >= this.config.minReadingsForStable) {
            return {
                lat: this.lastGoodPosition.lat,
                lng: this.lastGoodPosition.lng
            };
        }

        if (this.positionHistory.length === 1) {
            return {
                lat: this.positionHistory[0].lat,
                lng: this.positionHistory[0].lng
            };
        }

        // M칠dia ponderada com peso exponencial (leituras recentes valem mais)
        let totalWeight = 0;
        let weightedLat = 0;
        let weightedLng = 0;

        this.positionHistory.forEach((pos, index) => {
            // Peso baseado na precis칚o E na rec칡ncia
            const recencyWeight = Math.pow(1.5, index); // Mais recente = maior peso
            const accuracyWeight = 1 / (pos.accuracy + 1);
            const weight = recencyWeight * accuracyWeight;

            weightedLat += pos.lat * weight;
            weightedLng += pos.lng * weight;
            totalWeight += weight;
        });

        return {
            lat: weightedLat / totalWeight,
            lng: weightedLng / totalWeight
        };
    }

    animateMarkerTo(newPosition, duration = 600) {
        if (!this.marker) return;

        // Primeira posi칞칚o - sem anima칞칚o
        if (this.markerCoords.lat === 0 && this.markerCoords.lng === 0) {
            this.markerCoords = newPosition;
            markerCoords = newPosition; // Atualizar global
            if (this.marker.position !== undefined) {
                this.marker.position = newPosition;
            } else if (this.marker.setPosition) {
                this.marker.setPosition(newPosition);
            }
            return;
        }

        // Parar anima칞칚o anterior
        if (this.currentTween) {
            this.currentTween.stop();
        }
        if (currentTween) {
            currentTween.stop();
        }

        // Animar com Tween.js - Linear para movimento mais direto
        this.currentTween = new TWEEN.Tween(this.markerCoords)
            .to(newPosition, duration)
            .easing(TWEEN.Easing.Linear.None) // Linear para movimento mais natural de ve칤culo
            .onUpdate(() => {
                const pos = {
                    lat: this.markerCoords.lat,
                    lng: this.markerCoords.lng
                };
                if (this.marker.position !== undefined) {
                    this.marker.position = pos;
                } else if (this.marker.setPosition) {
                    this.marker.setPosition(pos);
                }
                markerCoords = this.markerCoords; // Sync global
            })
            .start();

        currentTween = this.currentTween; // Atualizar global
    }

    centerOnUser() {
        if (this.marker) {
            const position = this.marker.position || this.marker.getPosition();
            if (position) {
                map.panTo(position);
            }
        }
    }

    handleError(error) {
        console.warn('GPS Error:', error);
    }

    stop() {
        if (this.watchId) {
            navigator.geolocation.clearWatch(this.watchId);
            this.watchId = null;
            watchId = null;
        }

        // Remover listener de heading
        if (this.headingListener) {
            google.maps.event.removeListener(this.headingListener);
            this.headingListener = null;
        }
    }

    getPosition() {
        if (!this.marker) return null;
        return this.marker.position || this.marker.getPosition();
    }

    getAccuracy() {
        return this.accuracy;
    }

    // For칞a uma atualiza칞칚o imediata do GPS (칰til quando o app volta do segundo plano)
    forceUpdate() {
        return new Promise((resolve, reject) => {
            if (!navigator.geolocation) {
                reject(new Error('Geolocaliza칞칚o n칚o suportada'));
                return;
            }

            console.log('游댃 [GPS] For칞ando atualiza칞칚o de localiza칞칚o...');

            const options = {
                enableHighAccuracy: this.config.highAccuracy,
                timeout: 10000, // Timeout mais curto para resposta r치pida
                maximumAge: 0   // Sempre dados frescos
            };

            navigator.geolocation.getCurrentPosition(
                (position) => {
                    console.log('九 [GPS] Posi칞칚o atualizada:', position.coords.latitude, position.coords.longitude);
                    this.updatePosition(position);
                    resolve(position);
                },
                (error) => {
                    console.warn('丘멆잺 [GPS] Erro ao for칞ar atualiza칞칚o:', error);
                    reject(error);
                },
                options
            );
        });
    }

    // For칞a atualiza칞칚o e centraliza o mapa na posi칞칚o do usu치rio
    async forceUpdateAndCenter() {
        try {
            const position = await this.forceUpdate();
            const coords = {
                lat: position.coords.latitude,
                lng: position.coords.longitude
            };
            map.panTo(coords);
            console.log('游늸 [GPS] Mapa centralizado na nova posi칞칚o');
            return position;
        } catch (error) {
            console.warn('丘멆잺 [GPS] N칚o foi poss칤vel atualizar e centralizar:', error);
            // Mesmo com erro, tenta centralizar na 칰ltima posi칞칚o conhecida
            if (this.markerCoords.lat !== 0 && this.markerCoords.lng !== 0) {
                map.panTo(this.markerCoords);
            }
            throw error;
        }
    }
}

// Inst칙ncia global do GPS Tracker
let gpsTracker = null;

/* ===========================
   M칍DULO: LAZY LOADER
   =========================== */
class LazyLoader {
    constructor() {
        this.loadedScripts = new Set();
        this.loadingPromises = new Map();
    }

    async loadScript(url, name) {
        // Se j치 foi carregado, retornar imediatamente
        if (this.loadedScripts.has(name)) {
            return Promise.resolve();
        }

        // Se est치 sendo carregado, retornar a promise existente
        if (this.loadingPromises.has(name)) {
            return this.loadingPromises.get(name);
        }

        // Criar nova promise de carregamento
        const loadingPromise = new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = url;
            script.async = true;

            script.onload = () => {
                this.loadedScripts.add(name);
                this.loadingPromises.delete(name);
                console.log(`九 [LAZY] ${name} carregado (economizou tempo de inicializa칞칚o)`);
                resolve();
            };

            script.onerror = () => {
                this.loadingPromises.delete(name);
                console.error(`仇 [LAZY] Erro ao carregar ${name}`);
                reject(new Error(`Failed to load ${name}`));
            };

            document.head.appendChild(script);
        });

        this.loadingPromises.set(name, loadingPromise);
        return loadingPromise;
    }

    async loadJsQR() {
        return this.loadScript(
            'https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js',
            'jsQR'
        );
    }

    isLoaded(name) {
        return this.loadedScripts.has(name);
    }
}

// Inst칙ncia global do Lazy Loader
const lazyLoader = new LazyLoader();

const MAP_ID = "ebb7ca4503045feabc75b373";

// IMPORTANTE: Substitua pelo seu Project ID do Google Cloud Platform
// Encontre em: https://console.cloud.google.com/  Configura칞칫es do projeto
const GOOGLE_CLOUD_PROJECT_ID = "mapas-clientes-479801"; // 九 Configurado!
const GOOGLE_MAPS_API_KEY = "AIzaSyApaDb9rSw2sNTaY7fjBqmrgjWYD9xwjcU"; // API Key para Fleet Routing

// ===========================
// SISTEMA DE NOTIFICA칂칏ES
// ===========================

function showToast(title, message, type = 'info', duration = 4000) {
    // Mostrar apenas toasts de erro para n칚o poluir a interface
    if (type !== 'error') {
        console.log(`[Toast ${type}] ${title}: ${message}`);
        return;
    }

    const container = document.getElementById('toast-container');
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;

    const icons = {
        success: '九',
        error: '九',
        warning: '丘',
        info: ''
    };

    toast.innerHTML = `
        <div class="toast-icon">${icons[type] || icons.info}</div>
        <div class="toast-content">
            <div class="toast-title">${title}</div>
            ${message ? `<div class="toast-message">${message}</div>` : ''}
        </div>
    `;

    container.appendChild(toast);

    setTimeout(() => {
        toast.classList.add('hiding');
        setTimeout(() => toast.remove(), 300);
    }, duration);
}

function updateLoadingScreen(text, subtext) {
    document.getElementById('loading-text').textContent = text;
    document.getElementById('loading-subtext').textContent = subtext;
}

function hideLoadingScreen() {
    const loadingScreen = document.getElementById('loading-screen');
    const mapElement = document.getElementById('map');
    const controls = document.querySelector('.map-control');

    loadingScreen.classList.add('hidden');
    mapElement.classList.add('loaded');
    controls.classList.add('visible');

    setTimeout(() => {
        document.getElementById('status-bar').classList.add('visible');
    }, 500);
}

function updateStatus(text, active = true) {
    document.getElementById('status-text').textContent = text;
    const indicator = document.getElementById('status-indicator');

    if (active) {
        indicator.classList.remove('inactive');
    } else {
        indicator.classList.add('inactive');
    }
}

// ===========================
// INICIALIZA칂츾O DO MAPA
// ===========================

// Adicionar bot칚o de GPS customizado (estilo Google Maps)
function addGPSCenterButton() {
    // Criar bot칚o
    const gpsCenterButton = document.createElement('button');
    gpsCenterButton.className = 'gps-center-button';
    gpsCenterButton.type = 'button';
    gpsCenterButton.title = 'Centralizar na minha localiza칞칚o';

    // 칈cone Material Icons
    const icon = document.createElement('i');
    icon.className = 'material-icons';
    icon.textContent = 'gps_fixed'; // 칈cone de GPS/mira
    gpsCenterButton.appendChild(icon);

    // Adicionar evento de clique
    gpsCenterButton.addEventListener('click', () => {
        // Usar GPS Tracker modular se dispon칤vel
        if (gpsTracker) {
            gpsTracker.centerOnUser();
            gpsCenterButton.classList.add('active');

            // Toast removido - a칞칚o visual j치 indica centraliza칞칚o

            // Remover classe active ap칩s 2 segundos
            setTimeout(() => {
                gpsCenterButton.classList.remove('active');
            }, 2000);
            return;
        }

        // Fallback para c칩digo legado
        if (!userLocationMarker) {
            showToast('Localiza칞칚o n칚o dispon칤vel', 'Aguarde obter sua posi칞칚o GPS', 'warning', 3000);
            return;
        }

        // Pega a posi칞칚o atual do marcador (compat칤vel com ambos os tipos)
        let currentPosition;
        if (userLocationMarker.position) {
            currentPosition = userLocationMarker.position;
        } else if (userLocationMarker.getPosition) {
            currentPosition = userLocationMarker.getPosition();
        }

        if (!currentPosition) {
            showToast('Erro ao centralizar', 'Posi칞칚o n칚o encontrada', 'error', 3000);
            return;
        }

        // Anima o zoom e centraliza
        map.panTo(currentPosition);
        map.setZoom(17);

        gpsCenterButton.classList.add('active');
        // Toast removido - a칞칚o visual j치 indica centraliza칞칚o

        // Remover classe active ap칩s 2 segundos
        setTimeout(() => {
            gpsCenterButton.classList.remove('active');
        }, 2000);
    });

    // Adicionar ao mapa usando controls API do Google Maps
    map.controls[google.maps.ControlPosition.RIGHT_BOTTOM].push(gpsCenterButton);
}

window.initMap = function () {
    console.log('Iniciando mapa...');
    updateLoadingScreen('Carregando mapa...', 'Preparando visualiza칞칚o');

    try {
        map = new google.maps.Map(document.getElementById("map"), {
            center: {lat: -23.5505, lng: -46.6333},
            zoom: 17,
            mapId: MAP_ID,
            tilt: 0,
            heading: 0,
            gestureHandling: "greedy",
            rotateControl: true,
            zoomControl: true,
            streetViewControl: false,
            fullscreenControl: true,
            // Otimiza칞칫es de performance
            disableDefaultUI: false,
            clickableIcons: false, // Desabilita cliques em POIs para melhor performance
            minZoom: 3, // Permite zoom global
            maxZoom: 22 // Zoom m치ximo detalhado
        });

        // Inicializar servi칞os de rota
        directionsService = new google.maps.DirectionsService();
        directionsRenderer = new google.maps.DirectionsRenderer({
            map: map,
            suppressMarkers: false, // N칚o suprimir marcadores (A, B, C, etc.)
            polylineOptions: {
                strokeColor: '#4285f4',
                strokeWeight: 5,
                strokeOpacity: 0.7
            }
        });

        // Adicionar bot칚o de centralizar localiza칞칚o (estilo Google Maps)
        addGPSCenterButton();

        // Configurar detec칞칚o de intera칞칚o do usu치rio durante navega칞칚o
        setupNavigationMapInteraction();

        // Fechar InfoWindow ao clicar no mapa (fora dos marcadores)
        map.addListener('click', () => {
            if (currentInfoWindow) {
                currentInfoWindow.close();
                currentInfoWindow = null;
            }
        });

        console.log('Mapa criado, aguardando tiles...');

        // Timeout de seguran칞a: se o mapa n칚o carregar em 15s, for칞a o in칤cio do tracking
        const safetyTimeout = setTimeout(() => {
            console.warn('Timeout: for칞ando in칤cio do tracking de localiza칞칚o');
            updateLoadingScreen('Obtendo sua localiza칞칚o...', 'Ative o GPS para melhor precis칚o');
            startLocationTracking();
        }, 15000);

        // Espera o mapa carregar completamente
        google.maps.event.addListenerOnce(map, 'tilesloaded', () => {
            clearTimeout(safetyTimeout);
            console.log('Tiles carregados, iniciando tracking...');
            updateLoadingScreen('Obtendo sua localiza칞칚o...', 'Ative o GPS para melhor precis칚o');
            startLocationTracking();
        });
    } catch (error) {
        console.error('Erro ao criar mapa:', error);
        hideLoadingScreen();
        showToast('Erro ao inicializar mapa', error.message, 'error', 8000);
    }
}

// ===========================
// RASTREAMENTO EM TEMPO REAL
// ===========================

async function startLocationTracking() {
    console.log('九 [MODULAR] Iniciando GPS Tracker...');

    try {
        // Criar inst칙ncia do GPS Tracker modular
        gpsTracker = new GPSTracker();

        // Iniciar rastreamento
        const position = await gpsTracker.start();

        console.log('九 Posi칞칚o obtida:', position.coords.latitude, position.coords.longitude);

        // Centralizar mapa na posi칞칚o
        map.setCenter({
            lat: position.coords.latitude,
            lng: position.coords.longitude
        });
        map.setZoom(17);

        // Esconder loading screen
        hideLoadingScreen();
        showAddClientButton();

        showToast(
            'Localiza칞칚o obtida!',
            `Precis칚o: ${Math.round(position.coords.accuracy)}m`,
            'success',
            3000
        );

        console.log('九 GPS Tracker iniciado com sucesso!');

    } catch (error) {
        console.error('仇 Erro ao iniciar GPS:', error);
        hideLoadingScreen();
        handleGeoError(error, true);
    }
}

// ===========================
// FUN칂칏ES GPS ANTIGAS REMOVIDAS
// Agora todas dentro da classe GPSTracker
// ===========================

function handleGeoError(error, isInitial = false) {
    console.warn("Erro de geolocaliza칞칚o:", error);

    let errorTitle = 'Erro de GPS';
    let errorMessage = '';

    switch(error.code) {
        case error.PERMISSION_DENIED:
            errorTitle = 'Permiss칚o negada';
            errorMessage = 'Por favor, permita o acesso  localiza칞칚o';
            break;
        case error.POSITION_UNAVAILABLE:
            errorTitle = 'Localiza칞칚o indispon칤vel';
            errorMessage = 'N칚o foi poss칤vel obter sua posi칞칚o';
            break;
        case error.TIMEOUT:
            errorTitle = 'Tempo esgotado';
            errorMessage = 'A solicita칞칚o demorou muito. Tentando novamente...';
            break;
        default:
            errorMessage = 'Erro desconhecido ao obter localiza칞칚o';
    }

    showToast(errorTitle, errorMessage, 'error', 6000);
    updateStatus('GPS com erro', false);

    if (isInitial) {
        map.setCenter({ lat: -23.5505, lng: -46.6333 });
    }
}

// ===========================
// MARCADORES DE ENTREGAS
// ===========================

// Fun칞칚o auxiliar para criar SVG de pin do Google Maps com n칰mero (suporta 1-99)
function createPinSVG(number) {
    // Ajustar tamanho da fonte baseado no n칰mero de d칤gitos
    const fontSize = number >= 10 ? '11' : '13';

    // SVG do pin do Google Maps (formato teardrop/gota invertida)
    const svg = `
        <svg width="32" height="44" viewBox="0 0 32 44" xmlns="http://www.w3.org/2000/svg">
            <!-- Sombra -->
            <ellipse cx="16" cy="42" rx="6.5" ry="2" fill="rgba(0,0,0,0.35)"/>

            <!-- Pin vermelho com gradiente sutil -->
            <defs>
                <linearGradient id="pinGradient${number}" x1="0%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" style="stop-color:#EA4335;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#C5221F;stop-opacity:1" />
                </linearGradient>
            </defs>
            <path d="M16 0 C7.164 0 0 7.164 0 16 C0 28 16 44 16 44 S32 28 32 16 C32 7.164 24.836 0 16 0 Z"
                  fill="url(#pinGradient${number})"
                  stroke="#FFFFFF"
                  stroke-width="2"/>

            <!-- C칤rculo branco interno maior -->
            <circle cx="16" cy="16" r="10" fill="#FFFFFF"/>

            <!-- Sombra interna sutil no c칤rculo -->
            <circle cx="16" cy="16" r="10" fill="none" stroke="rgba(0,0,0,0.08)" stroke-width="0.5"/>

            <!-- N칰mero com contorno para melhor legibilidade -->
            <text x="16" y="17"
                  text-anchor="middle"
                  dominant-baseline="central"
                  font-family="'Arial Black', Arial, sans-serif"
                  font-size="${fontSize}"
                  font-weight="900"
                  fill="#EA4335"
                  stroke="#FFFFFF"
                  stroke-width="0.8"
                  paint-order="stroke">${number}</text>
        </svg>
    `;

    return 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(svg);
}

// Fun칞칚o para marcar entregas como conclu칤das
async function markAsDelivered(deliveries, client, marker, coordKey, deliveredBtn) {
    try {
        console.log('游닍 Marcando entregas como conclu칤das:', deliveries);
        console.log('游댌 Client:', client);
        console.log('游댌 Marker:', marker);

        // Atualizar status no Supabase para cada entrega
        const deliveryIds = deliveries.map(d => d.id);
        console.log('游댌 IDs das entregas:', deliveryIds);

        const { data, error } = await supabase
            .from('delivery_data')
            .update({
                status: 'delivered',
                delivered_at: new Date().toISOString()
            })
            .in('id', deliveryIds)
            .select(); // Adicionar select() para retornar os dados atualizados

        if (error) {
            console.error('仇 ERRO ao atualizar Supabase:', error);
            console.error('仇 Mensagem:', error.message);
            console.error('仇 Detalhes:', error.details);
            console.error('仇 Hint:', error.hint);
            showToast(
                '仇 Erro ao salvar',
                error.message || 'N칚o foi poss칤vel salvar no banco',
                'error',
                5000
            );
            throw error;
        }

        console.log(`九 ${deliveryIds.length} entrega(s) atualizada(s) no banco de dados com sucesso!`);
        console.log('九 Dados retornados do Supabase:', data);

        // Marcar como entregue (tornar cinza e semi-transparente)
        if (marker) {
            marker.isDelivered = true; // Flag para identificar marcadores entregues

            // Salvar informa칞칫es originais para poder desfazer
            if (!marker.originalState) {
                marker.originalState = {
                    deliveries: deliveries,
                    client: client,
                    coordKey: coordKey,
                    isGreen: !!client // Se tem client, 칠 verde
                };
            }

            // Tornar o marcador cinza e semi-transparente
            if (marker.content) {
                // AdvancedMarkerElement com conte칰do personalizado
                const markerElement = marker.content;
                markerElement.style.opacity = '0.4';
                markerElement.style.filter = 'grayscale(100%)';

                // Se for marcador verde (pin customizado), mudar cor para cinza
                const pinDiv = markerElement.querySelector('div');
                if (pinDiv) {
                    pinDiv.style.background = '#9E9E9E'; // Cinza
                    const innerCircle = pinDiv.querySelector('div');
                    if (innerCircle) {
                        innerCircle.style.color = '#9E9E9E';
                    }
                }
            } else if (marker.setIcon) {
                // Marker cl치ssico - mudar para 칤cone cinza
                const currentIcon = marker.getIcon();
                if (currentIcon && currentIcon.path) {
                    marker.setIcon({
                        ...currentIcon,
                        fillColor: '#9E9E9E',
                        strokeColor: '#757575'
                    });
                } else if (currentIcon && currentIcon.url) {
                    // Marcador vermelho com SVG - recriar em cinza
                    const deliveryCount = deliveries.length;
                    marker.setIcon({
                        url: createPinSVG(deliveryCount, '#9E9E9E'),
                        scaledSize: new google.maps.Size(32, 44),
                        anchor: new google.maps.Point(16, 44)
                    });
                }
                marker.setOpacity(0.4);
            }
        }

        // Atualizar o bot칚o para "Desfazer"
        if (deliveredBtn) {
            deliveredBtn.innerHTML = ' Desfazer';
            deliveredBtn.style.background = '#FF9800'; // Laranja
            deliveredBtn.removeEventListener('mouseenter', deliveredBtn._hoverIn);
            deliveredBtn.removeEventListener('mouseleave', deliveredBtn._hoverOut);
            deliveredBtn._hoverIn = () => { deliveredBtn.style.background = '#F57C00'; };
            deliveredBtn._hoverOut = () => { deliveredBtn.style.background = '#FF9800'; };
            deliveredBtn.addEventListener('mouseenter', deliveredBtn._hoverIn);
            deliveredBtn.addEventListener('mouseleave', deliveredBtn._hoverOut);
        }

        // Obter posi칞칚o do marcador atual para encontrar o mais pr칩ximo
        let currentMarkerPosition = null;
        if (marker) {
            if (marker.position) {
                currentMarkerPosition = marker.position;
            } else if (marker.getPosition) {
                currentMarkerPosition = marker.getPosition();
            }
        }

        // Fechar InfoWindow
        if (currentInfoWindow) {
            currentInfoWindow.close();
            currentInfoWindow = null;
        }

        // Toast removido - a칞칚o visual j치 indica o status

        // Navegar para o pr칩ximo marcador mais pr칩ximo
        await navigateToNextMarker(currentMarkerPosition);

    } catch (error) {
        console.error('Erro ao marcar entregas:', error);
        showToast(
            '仇 Erro ao marcar entrega',
            error.message || 'N칚o foi poss칤vel atualizar o status',
            'error',
            4000
        );
    }
}

// Fun칞칚o para desfazer a marca칞칚o de entrega
async function undoDelivery(marker, deliveredBtn) {
    try {
        if (!marker.originalState) {
            console.error('Estado original n칚o encontrado');
            return;
        }

        const { deliveries, client, coordKey, isGreen } = marker.originalState;
        console.log(' Desfazendo marca칞칚o de entrega:', deliveries);

        // Atualizar status no Supabase de volta para pending
        const deliveryIds = deliveries.map(d => d.id);

        const { error } = await supabase
            .from('delivery_data')
            .update({
                status: 'pending',
                delivered_at: null
            })
            .in('id', deliveryIds);

        if (error) {
            console.error('Erro ao atualizar Supabase:', error);
            throw error;
        }

        console.log(`九 ${deliveryIds.length} entrega(s) revertida(s) para pendente`);

        // Restaurar apar칡ncia original do marcador
        marker.isDelivered = false;

        if (marker.content) {
            // AdvancedMarkerElement - restaurar opacidade e cor
            const markerElement = marker.content;
            markerElement.style.opacity = '1';
            markerElement.style.filter = 'none';

            // Restaurar cor original
            const pinDiv = markerElement.querySelector('div');
            if (pinDiv) {
                pinDiv.style.background = isGreen ? '#4CAF50' : '#EA4335'; // Verde ou Vermelho
                const innerCircle = pinDiv.querySelector('div');
                if (innerCircle) {
                    innerCircle.style.color = isGreen ? '#4CAF50' : '#EA4335';
                }
            }
        } else if (marker.setIcon) {
            // Marker cl치ssico - restaurar 칤cone original
            const deliveryCount = deliveries.length;
            const originalColor = isGreen ? '#4CAF50' : '#EA4335';

            const currentIcon = marker.getIcon();
            if (currentIcon && currentIcon.path) {
                marker.setIcon({
                    ...currentIcon,
                    fillColor: originalColor,
                    strokeColor: 'white'
                });
            } else {
                marker.setIcon({
                    url: createPinSVG(deliveryCount, originalColor),
                    scaledSize: new google.maps.Size(32, 44),
                    anchor: new google.maps.Point(16, 44)
                });
            }
            marker.setOpacity(1);
        }

        // Restaurar bot칚o para "Entregue"
        if (deliveredBtn) {
            deliveredBtn.innerHTML = '九 Entregue';
            deliveredBtn.style.background = '#34A853'; // Verde
            deliveredBtn.removeEventListener('mouseenter', deliveredBtn._hoverIn);
            deliveredBtn.removeEventListener('mouseleave', deliveredBtn._hoverOut);
            deliveredBtn._hoverIn = () => { deliveredBtn.style.background = '#2d8e47'; };
            deliveredBtn._hoverOut = () => { deliveredBtn.style.background = '#34A853'; };
            deliveredBtn.addEventListener('mouseenter', deliveredBtn._hoverIn);
            deliveredBtn.addEventListener('mouseleave', deliveredBtn._hoverOut);
        }

        // Toast removido - a칞칚o visual j치 indica o status

    } catch (error) {
        console.error('Erro ao desfazer entrega:', error);
    }
}

// Fun칞칚o para desfazer a marca칞칚o de "N칚o Entregue"
async function undoNotDelivered(marker, notDeliveredBtn) {
    try {
        if (!marker.originalState) {
            console.error('Estado original n칚o encontrado');
            return;
        }

        const { deliveries, client, coordKey, isGreen } = marker.originalState;
        console.log(' Desfazendo marca칞칚o de N츾O entregue:', deliveries);

        // Atualizar status no Supabase de volta para pending
        const deliveryIds = deliveries.map(d => d.id);

        const { error } = await supabase
            .from('delivery_data')
            .update({
                status: 'pending'
            })
            .in('id', deliveryIds);

        if (error) {
            console.error('Erro ao atualizar Supabase:', error);
            throw error;
        }

        console.log(`九 ${deliveryIds.length} entrega(s) revertida(s) para pendente`);

        // Restaurar apar칡ncia original do marcador
        marker.isNotDelivered = false;

        // Remover o X vermelho
        if (marker.content) {
            const xOverlay = marker.content.querySelector('.not-delivered-x');
            if (xOverlay) {
                xOverlay.remove();
            }

            // Restaurar opacidade e cor
            marker.content.style.opacity = '1';
            marker.content.style.filter = 'none';

            // Restaurar cor original
            const pinDiv = marker.content.querySelector('div');
            if (pinDiv) {
                pinDiv.style.background = isGreen ? '#4CAF50' : '#EA4335'; // Verde ou Vermelho
                const innerCircle = pinDiv.querySelector('div');
                if (innerCircle) {
                    innerCircle.style.color = isGreen ? '#4CAF50' : '#EA4335';
                }
            }
        }

        // Restaurar bot칚o para "N칚o Entregue"
        if (notDeliveredBtn) {
            notDeliveredBtn.innerHTML = '九 N칚o Entg';
            notDeliveredBtn.style.background = '#EA4335'; // Vermelho
            notDeliveredBtn.removeEventListener('mouseenter', notDeliveredBtn._hoverIn);
            notDeliveredBtn.removeEventListener('mouseleave', notDeliveredBtn._hoverOut);
            notDeliveredBtn._hoverIn = () => { notDeliveredBtn.style.background = '#c5351c'; };
            notDeliveredBtn._hoverOut = () => { notDeliveredBtn.style.background = '#EA4335'; };
            notDeliveredBtn.addEventListener('mouseenter', notDeliveredBtn._hoverIn);
            notDeliveredBtn.addEventListener('mouseleave', notDeliveredBtn._hoverOut);
        }

        // Toast removido - a칞칚o visual j치 indica o status

    } catch (error) {
        console.error('Erro ao desfazer n칚o entregue:', error);
    }
}

// Fun칞칚o para calcular dist칙ncia entre dois pontos (em metros)
function calculateDistance(lat1, lng1, lat2, lng2) {
    const R = 6371000; // Raio da Terra em metros
    const 픥1 = lat1 * Math.PI / 180;
    const 픥2 = lat2 * Math.PI / 180;
    const 풊픥 = (lat2 - lat1) * Math.PI / 180;
    const 풊풭 = (lng2 - lng1) * Math.PI / 180;

    const a = Math.sin(풊픥 / 2) * Math.sin(풊픥 / 2) +
              Math.cos(픥1) * Math.cos(픥2) *
              Math.sin(풊풭 / 2) * Math.sin(풊풭 / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

    return R * c;
}

// Fun칞칚o para navegar para o pr칩ximo marcador usando rota real de tr치fego
async function navigateToNextMarker(currentPosition = null) {
    // Filtrar apenas marcadores n칚o entregues
    const remainingMarkers = Object.values(deliveryMarkers).filter(m => m !== null && !m.isDelivered);

    if (remainingMarkers.length === 0) {
        showToast(
            '游꿀 Todas entregas conclu칤das!',
            'N칚o h치 mais entregas pendentes',
            'success',
            5000
        );
        return;
    }

    let nextMarker = null;
    let nextPosition = null;

    // Se temos posi칞칚o atual, encontrar o marcador com menor tempo de viagem REAL
    if (currentPosition) {
        console.log('游뚱 Calculando rotas reais de tr치fego para TODOS os marcadores...');

        // PASSO 1: Preparar lista de marcadores com suas posi칞칫es
        const markersList = [];

        remainingMarkers.forEach(marker => {
            let markerPosition = null;

            if (marker.position) {
                markerPosition = marker.position;
            } else if (marker.getPosition) {
                markerPosition = marker.getPosition();
            }

            if (markerPosition) {
                markersList.push({
                    marker,
                    position: markerPosition
                });
            }
        });

        if (markersList.length === 0) {
            console.warn('Nenhum marcador com posi칞칚o v치lida encontrado');
            return;
        }

        console.log(`游늵 Calculando rotas para ${markersList.length} destinos...`);

        try {
            // PASSO 2: Dividir em lotes de 25 (limite da Distance Matrix API)
            const MAX_DESTINATIONS = 25;
            const batches = [];
            for (let i = 0; i < markersList.length; i += MAX_DESTINATIONS) {
                batches.push(markersList.slice(i, i + MAX_DESTINATIONS));
            }

            console.log(`游닍 Dividido em ${batches.length} lote(s) de at칠 ${MAX_DESTINATIONS} destinos`);

            // PASSO 3: Processar todos os lotes em paralelo
            const service = new google.maps.DistanceMatrixService();
            const origin = new google.maps.LatLng(currentPosition.lat, currentPosition.lng);

            const batchPromises = batches.map((batch, batchIndex) => {
                const destinations = batch.map(item =>
                    new google.maps.LatLng(item.position.lat, item.position.lng)
                );

                const request = {
                    origins: [origin],
                    destinations: destinations,
                    travelMode: google.maps.TravelMode.DRIVING,
                    unitSystem: google.maps.UnitSystem.METRIC,
                    avoidHighways: false,
                    avoidTolls: false,
                    drivingOptions: {
                        departureTime: new Date(),
                        trafficModel: google.maps.TrafficModel.BEST_GUESS
                    }
                };

                return new Promise((resolve, reject) => {
                    // Delay entre requisi칞칫es para evitar rate limiting
                    setTimeout(() => {
                        service.getDistanceMatrix(request, (response, status) => {
                            if (status === 'OK') {
                                resolve({ response, batch, batchIndex });
                            } else {
                                reject(new Error(`Lote ${batchIndex + 1} falhou: ${status}`));
                            }
                        });
                    }, batchIndex * 200); // 200ms entre cada lote
                });
            });

            // Aguardar todos os lotes
            const batchResults = await Promise.all(batchPromises);

            // PASSO 4: Encontrar o destino com MENOR DIST츽NCIA REAL (n칚o tempo)
            let minDistance = Infinity;
            let bestMarker = null;
            let bestPosition = null;
            let bestDistanceText = null;
            let bestDurationText = null;

            batchResults.forEach(({ response, batch, batchIndex }) => {
                response.rows[0].elements.forEach((element, index) => {
                    if (element.status === 'OK') {
                        const duration = element.duration.value; // Tempo em segundos (apenas para mostrar)
                        const distance = element.distance.value; // Dist칙ncia em metros

                        console.log(`游늸 Lote ${batchIndex + 1}, Destino ${index + 1}: ${Math.round(distance)}m (${Math.round(duration / 60)} min)`);

                        // Escolher pela MENOR DIST츽NCIA, n칚o pelo menor tempo
                        if (distance < minDistance) {
                            minDistance = distance;
                            bestMarker = batch[index].marker;
                            bestPosition = batch[index].position;
                            bestDistanceText = element.distance.text;
                            bestDurationText = element.duration.text;
                        }
                    }
                });
            });

            if (bestMarker) {
                nextMarker = bestMarker;
                nextPosition = bestPosition;

                console.log(`九 Rota mais curta (de ${markersList.length} destinos): ${bestDistanceText} (tempo estimado: ${bestDurationText})`);

                showToast(
                    '游늺 Pr칩xima entrega',
                    `${bestDistanceText} de dist칙ncia`,
                    'info',
                    3000
                );
            } else {
                console.warn('Nenhuma rota v치lida encontrada');
                nextMarker = markersList[0].marker;
                nextPosition = markersList[0].position;
            }

        } catch (error) {
            console.error('Erro ao calcular rotas:', error);
            // Fallback: pegar o primeiro marcador
            nextMarker = remainingMarkers[0];

            if (nextMarker.position) {
                nextPosition = nextMarker.position;
            } else if (nextMarker.getPosition) {
                nextPosition = nextMarker.getPosition();
            }

            showToast(
                '丘멆잺 Usando pr칩ximo dispon칤vel',
                'N칚o foi poss칤vel calcular rota de tr치fego',
                'warning',
                3000
            );
        }
    } else {
        // Se n칚o temos posi칞칚o atual, pegar o primeiro marcador
        nextMarker = remainingMarkers[0];

        if (nextMarker.position) {
            nextPosition = nextMarker.position;
        } else if (nextMarker.getPosition) {
            nextPosition = nextMarker.getPosition();
        }
    }

    if (nextPosition) {
        // Centralizar no pr칩ximo marcador
        map.panTo(nextPosition);

        // Dar zoom se estiver muito longe
        const currentZoom = map.getZoom();
        if (currentZoom < 16) {
            map.setZoom(16);
        }
    }
}

async function addDeliveryMarkers() {
    console.log('游댯 Adicionando marcadores de entrega...');

    // PASSO 1: Remover TODOS os marcadores anteriores
    const markerCount = Object.keys(deliveryMarkers).length;
    if (markerCount > 0) {
        console.log(`游딈勇 Removendo ${markerCount} marcadores anteriores...`);
        Object.values(deliveryMarkers).forEach(marker => {
            try {
                if (marker.map !== undefined) {
                    marker.map = null; // AdvancedMarkerElement
                } else if (marker.setMap) {
                    marker.setMap(null); // Marker cl치ssico
                }
            } catch (e) {
                console.warn('Erro ao remover marcador:', e);
            }
        });
    }

    // PASSO 2: Resetar objeto completamente
    deliveryMarkers = {};

    // PASSO 2.5: Buscar clientes cadastrados para verificar quais endere칞os j치 existem
    let registeredClients = [];
    let registeredClientsByAddress = new Map(); // Mapa de endere칞o normalizado -> cliente
    try {
        const { data: clients, error: clientsError } = await supabase
            .from('clients')
            .select('*');

        if (clientsError) throw clientsError;
        registeredClients = clients || [];
        console.log(`游늶 ${registeredClients.length} clientes cadastrados encontrados`);

        // Criar mapa de endere칞os normalizados -> dados do cliente
        registeredClients.forEach(client => {
            const clientAddress = client.address || '';
            const clientAddressFirstLine = clientAddress.split('\n')[0];
            const normalized = normalizeAddressForComparison(clientAddressFirstLine);
            if (normalized && client.latitude && client.longitude) {
                registeredClientsByAddress.set(normalized, client);
            }
        });
        console.log(`九 ${registeredClientsByAddress.size} endere칞os 칰nicos cadastrados com coordenadas`);
    } catch (error) {
        console.warn('Aviso: N칚o foi poss칤vel buscar clientes cadastrados:', error);
        // Continuar mesmo se n칚o conseguir buscar clientes (todos ser칚o vermelhos)
    }

    // PASSO 3: Buscar dados da planilha (delivery_data) do Supabase
    // Buscar todas as entregas (pending, delivered, not_delivered)
    let deliveryData = [];
    try {
        const { data, error } = await supabase
            .from('delivery_data')
            .select('*')
            .in('status', ['pending', 'delivered', 'not_delivered']) // Todas as entregas
            .order('sequence', { ascending: true });

        if (error) throw error;
        deliveryData = data || [];

        // DEBUG: Ver os primeiros 3 registros
        console.log('游댌 DEBUG - Primeiros 3 registros do Supabase:', deliveryData.slice(0, 3));
        console.log('游댌 DEBUG - Status do primeiro registro:', deliveryData[0]?.status);
    } catch (error) {
        console.error('Erro ao buscar delivery_data:', error);
        showToast(
            'Erro ao carregar dados',
            'N칚o foi poss칤vel buscar os dados da planilha',
            'error',
            4000
        );
        return;
    }

    if (deliveryData.length === 0) {
        console.log('丘멆잺 Nenhum dado encontrado na planilha');
        showToast(
            'Nenhuma entrega encontrada',
            'Fa칞a upload de uma planilha para planejar rotas',
            'warning',
            4000
        );
        return;
    }

    // PASSO 4: Separar entregas em cadastradas vs n칚o cadastradas
    const groupedByRegistered = new Map(); // Cliente cadastrado -> entregas
    const groupedByUnregistered = {}; // Coordenada -> entregas n칚o cadastradas

    deliveryData.forEach((delivery) => {
        if (!delivery.latitude || !delivery.longitude) {
            console.warn(`Entrega ${delivery.spx_tn} n칚o tem coordenadas v치lidas`);
            return;
        }

        // Verificar se o endere칞o est치 cadastrado
        const deliveryAddress = delivery.destination_address || '';
        const normalized = normalizeAddressForComparison(deliveryAddress);
        const registeredClient = registeredClientsByAddress.get(normalized);

        if (registeredClient) {
            // Endere칞o CADASTRADO: agrupar por cliente
            if (!groupedByRegistered.has(registeredClient.id)) {
                groupedByRegistered.set(registeredClient.id, {
                    client: registeredClient,
                    deliveries: []
                });
            }
            groupedByRegistered.get(registeredClient.id).deliveries.push({
                id: delivery.id,
                spx_tn: delivery.spx_tn,
                sequence: delivery.sequence,
                destination_address: delivery.destination_address,
                status: delivery.status, // 九 ADICIONAR STATUS
                delivered_at: delivery.delivered_at
            });
        } else {
            // Endere칞o N츾O CADASTRADO: agrupar por COORDENADA + ENDERE칂O EXATO
            // Isso garante que apenas entregas com endere칞o EXATAMENTE igual sejam agrupadas
            const coordKey = `${delivery.latitude.toFixed(6)},${delivery.longitude.toFixed(6)}|${delivery.destination_address}`;
            if (!groupedByUnregistered[coordKey]) {
                groupedByUnregistered[coordKey] = {
                    position: { lat: delivery.latitude, lng: delivery.longitude },
                    address: delivery.destination_address,
                    bairro: delivery.bairro,
                    city: delivery.city,
                    zipcode: delivery.zipcode,
                    deliveries: []
                };
            }
            groupedByUnregistered[coordKey].deliveries.push({
                id: delivery.id,
                spx_tn: delivery.spx_tn,
                sequence: delivery.sequence || groupedByUnregistered[coordKey].deliveries.length + 1,
                destination_address: delivery.destination_address,
                status: delivery.status, // 九 ADICIONAR STATUS
                delivered_at: delivery.delivered_at
            });
        }
    });

    console.log(`游닍 Total de entregas: ${deliveryData.length}`);
    console.log(`九 Clientes cadastrados com entregas: ${groupedByRegistered.size}`);
    console.log(`仇 Locais n칚o cadastrados: ${Object.keys(groupedByUnregistered).length}`);

    // PASSO 4.5: Calcular offsets para marcadores sobrepostos (spiderfy)
    // Coletar todas as posi칞칫es dos marcadores
    const allMarkerPositions = [];

    // Posi칞칫es dos clientes cadastrados (verdes)
    groupedByRegistered.forEach((data, clientId) => {
        allMarkerPositions.push({
            id: `registered_${clientId}`,
            type: 'registered',
            clientId: clientId,
            lat: data.client.latitude,
            lng: data.client.longitude
        });
    });

    // Posi칞칫es dos n칚o cadastrados (vermelhos)
    Object.keys(groupedByUnregistered).forEach(coordKey => {
        const data = groupedByUnregistered[coordKey];
        allMarkerPositions.push({
            id: `unregistered_${coordKey}`,
            type: 'unregistered',
            coordKey: coordKey,
            lat: data.position.lat,
            lng: data.position.lng
        });
    });

    // Fun칞칚o para calcular offset em c칤rculo
    const calculateSpiderfyOffset = (index, total, baseOffset = 0.00015) => {
        if (total <= 1) return { latOffset: 0, lngOffset: 0 };
        const angle = (2 * Math.PI * index) / total;
        const radius = baseOffset * (1 + Math.floor(index / 8) * 0.5); // Aumenta raio para mais de 8 marcadores
        return {
            latOffset: radius * Math.cos(angle),
            lngOffset: radius * Math.sin(angle)
        };
    };

    // Agrupar marcadores por proximidade (mesmo local ou muito pr칩ximos)
    const proximityThreshold = 0.0001; // ~11 metros
    const proximityGroups = [];
    const assignedToGroup = new Set();

    allMarkerPositions.forEach((pos, i) => {
        if (assignedToGroup.has(pos.id)) return;

        const group = [pos];
        assignedToGroup.add(pos.id);

        allMarkerPositions.forEach((otherPos, j) => {
            if (i === j || assignedToGroup.has(otherPos.id)) return;

            const latDiff = Math.abs(pos.lat - otherPos.lat);
            const lngDiff = Math.abs(pos.lng - otherPos.lng);

            if (latDiff < proximityThreshold && lngDiff < proximityThreshold) {
                group.push(otherPos);
                assignedToGroup.add(otherPos.id);
            }
        });

        if (group.length > 1) {
            proximityGroups.push(group);
        }
    });

    // Criar mapa de offsets
    const markerOffsets = {};
    proximityGroups.forEach(group => {
        console.log(`游댃 Grupo de ${group.length} marcadores sobrepostos detectado`);
        group.forEach((marker, index) => {
            const offset = calculateSpiderfyOffset(index, group.length);
            markerOffsets[marker.id] = offset;
        });
    });

    const bounds = new google.maps.LatLngBounds();
    let registeredMarkersCount = 0;
    let unregisteredMarkersCount = 0;

    // PASSO 5: Criar marcadores VERDES para clientes cadastrados
    groupedByRegistered.forEach((data, clientId) => {
        const client = data.client;
        const deliveries = data.deliveries;
        const deliveryCount = deliveries.length;

        // Aplicar offset se houver marcadores sobrepostos
        const markerId = `registered_${clientId}`;
        const offset = markerOffsets[markerId] || { latOffset: 0, lngOffset: 0 };
        const position = {
            lat: client.latitude + offset.latOffset,
            lng: client.longitude + offset.lngOffset
        };

        console.log(`九 Criando marcador verde para cliente: ${client.name} (${deliveryCount} entregas)`);
        console.log(`游댌 DEBUG - Deliveries deste marcador:`, deliveries);

        // Criar marcador VERDE estilo pin do Google Maps
        const markerDiv = document.createElement('div');
        markerDiv.style.cursor = 'pointer';
        markerDiv.style.transition = 'transform 0.2s';

        // Pin verde
        const pinImg = document.createElement('div');
        pinImg.style.width = '32px';
        pinImg.style.height = '32px';
        pinImg.style.background = '#4CAF50';
        pinImg.style.border = '3px solid white';
        pinImg.style.borderRadius = '50% 50% 50% 0';
        pinImg.style.transform = 'rotate(-45deg)';
        pinImg.style.boxShadow = '0 3px 6px rgba(0,0,0,0.4)';
        pinImg.style.display = 'flex';
        pinImg.style.alignItems = 'center';
        pinImg.style.justifyContent = 'center';

        const innerCircle = document.createElement('div');
        innerCircle.style.width = '18px';
        innerCircle.style.height = '18px';
        innerCircle.style.background = 'white';
        innerCircle.style.borderRadius = '50%';
        innerCircle.style.transform = 'rotate(45deg)';
        innerCircle.style.fontSize = '11px';
        innerCircle.style.fontWeight = 'bold';
        innerCircle.style.color = '#4CAF50';
        innerCircle.style.display = 'flex';
        innerCircle.style.alignItems = 'center';
        innerCircle.style.justifyContent = 'center';
        innerCircle.textContent = deliveryCount;

        pinImg.appendChild(innerCircle);
        markerDiv.appendChild(pinImg);

        // Efeito hover
        markerDiv.addEventListener('mouseenter', () => { markerDiv.style.transform = 'scale(1.2)'; });
        markerDiv.addEventListener('mouseleave', () => { markerDiv.style.transform = 'scale(1)'; });

        // Criar InfoWindow
        const infoWindowContent = document.createElement('div');
        infoWindowContent.style.padding = '12px';
        infoWindowContent.style.maxWidth = '300px';
        infoWindowContent.style.maxHeight = '400px';
        infoWindowContent.style.overflowY = 'auto';

        // Badge
        const badgeDiv = document.createElement('div');
        badgeDiv.style.background = '#4CAF50';
        badgeDiv.style.color = 'white';
        badgeDiv.style.padding = '4px 8px';
        badgeDiv.style.borderRadius = '4px';
        badgeDiv.style.fontSize = '11px';
        badgeDiv.style.fontWeight = 'bold';
        badgeDiv.style.marginBottom = '8px';
        badgeDiv.style.display = 'inline-block';
        badgeDiv.textContent = '九 CLIENTE CADASTRADO';

        // Nome
        const nameDiv = document.createElement('div');
        nameDiv.style.fontWeight = 'bold';
        nameDiv.style.fontSize = '14px';
        nameDiv.style.color = '#4CAF50';
        nameDiv.style.marginBottom = '6px';
        nameDiv.textContent = `游녻 ${client.name}`;

        // Telefone
        const phoneDiv = document.createElement('div');
        phoneDiv.style.fontSize = '12px';
        phoneDiv.style.color = '#666';
        phoneDiv.style.marginBottom = '4px';
        phoneDiv.innerHTML = `游 ${client.phone || 'Sem telefone'}`;

        // Endere칞o
        const addressDiv = document.createElement('div');
        addressDiv.style.fontSize = '12px';
        addressDiv.style.color = '#333';
        addressDiv.style.lineHeight = '1.5';
        addressDiv.style.marginBottom = '8px';
        addressDiv.style.padding = '8px';
        addressDiv.style.background = '#f5f5f5';
        addressDiv.style.borderRadius = '4px';
        addressDiv.innerHTML = `游늸 ${client.address.replace(/\n/g, '<br>')}`;

        infoWindowContent.appendChild(badgeDiv);
        infoWindowContent.appendChild(nameDiv);
        infoWindowContent.appendChild(phoneDiv);
        infoWindowContent.appendChild(addressDiv);

        // Lista de entregas
        const packagesTitle = document.createElement('div');
        packagesTitle.style.fontWeight = 'bold';
        packagesTitle.style.fontSize = '11px';
        packagesTitle.style.color = '#666';
        packagesTitle.style.marginTop = '8px';
        packagesTitle.style.marginBottom = '6px';
        packagesTitle.style.borderTop = '1px solid #eee';
        packagesTitle.style.paddingTop = '8px';
        packagesTitle.textContent = `游닍 ${deliveryCount} pacote${deliveryCount > 1 ? 's' : ''}:`;
        infoWindowContent.appendChild(packagesTitle);

        deliveries.forEach((delivery, index) => {
            const deliveryDiv = document.createElement('div');
            deliveryDiv.style.fontSize = '11px';
            deliveryDiv.style.color = '#333';
            deliveryDiv.style.lineHeight = '1.4';
            deliveryDiv.style.marginBottom = '4px';
            deliveryDiv.style.paddingBottom = '4px';
            deliveryDiv.style.paddingLeft = '8px';
            if (index < deliveries.length - 1) deliveryDiv.style.borderBottom = '1px solid #eee';

            const qrDiv = document.createElement('div');
            qrDiv.style.display = 'flex';
            qrDiv.style.justifyContent = 'space-between';
            qrDiv.style.alignItems = 'center';
            qrDiv.style.gap = '8px';

            const sequenceSpan = document.createElement('span');
            sequenceSpan.style.color = '#4CAF50';
            sequenceSpan.style.fontWeight = 'bold';
            sequenceSpan.textContent = `Ordem: ${delivery.sequence || (index + 1)}`;

            const qrSpan = document.createElement('span');
            qrSpan.style.fontSize = '10px';
            qrSpan.style.color = '#666';
            qrSpan.style.fontFamily = 'monospace';
            qrSpan.textContent = delivery.spx_tn || 'N/A';

            qrDiv.appendChild(sequenceSpan);
            qrDiv.appendChild(qrSpan);
            deliveryDiv.appendChild(qrDiv);
            infoWindowContent.appendChild(deliveryDiv);
        });

        // Container de bot칫es (ser치 preenchido ap칩s criar o marker)
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.display = 'flex';
        buttonsContainer.style.flexWrap = 'wrap';
        buttonsContainer.style.gap = '4px';
        buttonsContainer.style.marginTop = '10px';
        buttonsContainer.style.width = '100%';
        infoWindowContent.appendChild(buttonsContainer);

        const infoWindow = new google.maps.InfoWindow({
            content: infoWindowContent,
            maxWidth: 300,
            disableAutoPan: true
        });

        // Vari치vel para armazenar o marker
        let marker;

        try {
            if (google.maps.marker && google.maps.marker.AdvancedMarkerElement) {
                marker = new google.maps.marker.AdvancedMarkerElement({
                    map,
                    position,
                    content: markerDiv,
                    title: client.name
                });

                marker.addListener('click', () => {
                    if (currentInfoWindow) currentInfoWindow.close();
                    infoWindow.open(map, marker);
                    currentInfoWindow = infoWindow;

                    // Centralizar considerando o InfoWindow
                    setTimeout(() => {
                        const mapDiv = map.getDiv();
                        const mapHeight = mapDiv.offsetHeight;
                        const scale = Math.pow(2, map.getZoom());

                        // Offset para mover o marcador mais para baixo (InfoWindow aparece acima)
                        const offsetY = 150; // pixels para deslocar para baixo
                        const latOffset = offsetY / scale * (85 / 111000); // Convers칚o aproximada

                        const newCenter = {
                            lat: position.lat - latOffset,
                            lng: position.lng
                        };

                        map.panTo(newCenter);
                    }, 100);
                });

                deliveryMarkers[`registered_${clientId}`] = marker;
                registeredMarkersCount++;
            } else {
                marker = new google.maps.Marker({
                    map,
                    position,
                    title: client.name,
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        fillColor: '#4CAF50',
                        fillOpacity: 1,
                        strokeColor: 'white',
                        strokeWeight: 2,
                        scale: 10
                    }
                });

                marker.addListener('click', () => {
                    if (currentInfoWindow) currentInfoWindow.close();
                    infoWindow.open(map, marker);
                    currentInfoWindow = infoWindow;

                    // Centralizar considerando o InfoWindow
                    setTimeout(() => {
                        const mapDiv = map.getDiv();
                        const mapHeight = mapDiv.offsetHeight;
                        const scale = Math.pow(2, map.getZoom());

                        // Offset para mover o marcador mais para baixo (InfoWindow aparece acima)
                        const offsetY = 150; // pixels para deslocar para baixo
                        const latOffset = offsetY / scale * (85 / 111000); // Convers칚o aproximada

                        const newCenter = {
                            lat: position.lat - latOffset,
                            lng: position.lng
                        };

                        map.panTo(newCenter);
                    }, 100);
                });

                deliveryMarkers[`registered_${clientId}`] = marker;
                registeredMarkersCount++;
            }

            // Armazenar deliveries no marcador para uso posterior
            marker.deliveries = deliveries;

            // Adicionar bot칫es ao container (agora que o marker foi criado)
            // Calcular dist칙ncia do usu치rio ao marcador
            let distanceToMarker = Infinity;
            if (userLocationMarker && userLocationMarker.position) {
                const userPos = userLocationMarker.position;
                distanceToMarker = google.maps.geometry.spherical.computeDistanceBetween(
                    new google.maps.LatLng(userPos.lat, userPos.lng),
                    new google.maps.LatLng(position.lat, position.lng)
                );
            }

            // Bot칚o de navega칞칚o (s칩 aparece se estiver longe - mais de 30m)
            const navigateBtn = document.createElement('button');
            navigateBtn.style.flex = '1';
            navigateBtn.style.padding = '5px 6px';
            navigateBtn.style.background = '#4285f4';
            navigateBtn.style.color = 'white';
            navigateBtn.style.border = 'none';
            navigateBtn.style.borderRadius = '4px';
            navigateBtn.style.fontSize = '11px';
            navigateBtn.style.fontWeight = '600';
            navigateBtn.style.cursor = 'pointer';
            navigateBtn.style.transition = 'background 0.2s';
            navigateBtn.style.whiteSpace = 'nowrap';
            navigateBtn.style.minWidth = '0';
            navigateBtn.innerHTML = '游빐 Navegar';
            navigateBtn.addEventListener('mouseenter', () => { navigateBtn.style.background = '#3367d6'; });
            navigateBtn.addEventListener('mouseleave', () => { navigateBtn.style.background = '#4285f4'; });
            navigateBtn.addEventListener('click', () => { navigateToClient(client, marker, infoWindow); });

            // 游댠 Esconder bot칚o Navegar se estiver pr칩ximo (< 30m)
            const isNearby = distanceToMarker < 30;
            if (isNearby) {
                navigateBtn.style.display = 'none';
            }

            // Bot칚o marcar como entregue / desfazer
            const deliveredBtn = document.createElement('button');
            deliveredBtn.style.flex = '1';
            deliveredBtn.style.padding = '5px 6px';
            deliveredBtn.style.background = '#34A853';
            deliveredBtn.style.color = 'white';
            deliveredBtn.style.border = 'none';
            deliveredBtn.style.borderRadius = '4px';
            deliveredBtn.style.fontSize = '11px';
            deliveredBtn.style.fontWeight = '600';
            deliveredBtn.style.cursor = 'pointer';
            deliveredBtn.style.transition = 'background 0.2s';
            deliveredBtn.style.whiteSpace = 'nowrap';
            deliveredBtn.style.minWidth = '0';
            deliveredBtn.innerHTML = '九 Entregue';

            // Armazenar fun칞칫es de hover para poder remov칡-las depois
            deliveredBtn._hoverIn = () => { deliveredBtn.style.background = '#2d8e47'; };
            deliveredBtn._hoverOut = () => { deliveredBtn.style.background = '#34A853'; };
            deliveredBtn.addEventListener('mouseenter', deliveredBtn._hoverIn);
            deliveredBtn.addEventListener('mouseleave', deliveredBtn._hoverOut);

            // Handler do clique - alterna entre entregar e desfazer
            deliveredBtn.addEventListener('click', async () => {
                if (marker.isDelivered) {
                    console.log(' Bot칚o Desfazer clicado (marcador verde)');
                    await undoDelivery(marker, deliveredBtn);
                } else {
                    console.log('游댖 Bot칚o Entregue clicado (marcador verde)');
                    await markAsDelivered(deliveries, client, marker, null, deliveredBtn);
                }
            });

            // 游댠 NOVO: Bot칚o "N칚o Entregue" / "Desfazer"
            const notDeliveredBtn = document.createElement('button');
            notDeliveredBtn.style.flex = '1';
            notDeliveredBtn.style.padding = '5px 6px';
            notDeliveredBtn.style.background = '#EA4335';
            notDeliveredBtn.style.color = 'white';
            notDeliveredBtn.style.border = 'none';
            notDeliveredBtn.style.borderRadius = '4px';
            notDeliveredBtn.style.fontSize = '11px';
            notDeliveredBtn.style.fontWeight = '600';
            notDeliveredBtn.style.cursor = 'pointer';
            notDeliveredBtn.style.transition = 'background 0.2s';
            notDeliveredBtn.style.whiteSpace = 'nowrap';
            notDeliveredBtn.style.minWidth = '0';
            notDeliveredBtn.innerHTML = '九 N칚o Entg';

            // Armazenar fun칞칫es de hover para poder remov칡-las depois
            notDeliveredBtn._hoverIn = () => { notDeliveredBtn.style.background = '#c5351c'; };
            notDeliveredBtn._hoverOut = () => { notDeliveredBtn.style.background = '#EA4335'; };
            notDeliveredBtn.addEventListener('mouseenter', notDeliveredBtn._hoverIn);
            notDeliveredBtn.addEventListener('mouseleave', notDeliveredBtn._hoverOut);

            // Handler do clique - alterna entre "N칚o Entregue" e "Desfazer"
            notDeliveredBtn.addEventListener('click', async () => {
                if (marker.isNotDelivered) {
                    console.log(' Bot칚o Desfazer (N칚o Entregue) clicado (marcador verde)');
                    await undoNotDelivered(marker, notDeliveredBtn);
                } else {
                    console.log('仇 Bot칚o N칚o Entregue clicado (marcador verde)');
                    await markAsNotDelivered(marker, client, notDeliveredBtn);
                }
            });

            buttonsContainer.appendChild(navigateBtn);
            buttonsContainer.appendChild(deliveredBtn);
            buttonsContainer.appendChild(notDeliveredBtn);

            // Aplicar visual baseado no status (se j치 foi entregue ou n칚o entregue)
            const firstDelivery = deliveries[0];
            console.log(`游댌 Status do marcador verde ${client.name}:`, firstDelivery.status);

            if (firstDelivery.status === 'delivered') {
                // Salvar originalState para poder desfazer
                marker.originalState = {
                    deliveries: deliveries,
                    client: client,
                    coordKey: null,
                    isGreen: true
                };

                // Aplicar visual de entregue
                marker.isDelivered = true;
                if (marker.content) {
                    marker.content.style.opacity = '0.4';
                    marker.content.style.filter = 'grayscale(100%)';
                    const pinDiv = marker.content.querySelector('div');
                    if (pinDiv) {
                        pinDiv.style.background = '#9E9E9E';
                        const innerCircle = pinDiv.querySelector('div');
                        if (innerCircle) {
                            innerCircle.style.color = '#9E9E9E';
                        }
                    }
                }
                // Atualizar bot칚o
                deliveredBtn.innerHTML = ' Desfazer';
                deliveredBtn.style.background = '#FF9800';
                deliveredBtn.removeEventListener('mouseenter', deliveredBtn._hoverIn);
                deliveredBtn.removeEventListener('mouseleave', deliveredBtn._hoverOut);
                deliveredBtn._hoverIn = () => { deliveredBtn.style.background = '#e68900'; };
                deliveredBtn._hoverOut = () => { deliveredBtn.style.background = '#FF9800'; };
                deliveredBtn.addEventListener('mouseenter', deliveredBtn._hoverIn);
                deliveredBtn.addEventListener('mouseleave', deliveredBtn._hoverOut);
                console.log(`九 Visual de ENTREGUE aplicado ao marcador verde: ${client.name}`);
            } else if (firstDelivery.status === 'not_delivered') {
                // Salvar originalState para poder desfazer
                marker.originalState = {
                    deliveries: deliveries,
                    client: client,
                    coordKey: null,
                    isGreen: true
                };

                // Aplicar visual de n칚o entregue (cinza igual ao entregue + X vermelho)
                marker.isNotDelivered = true;
                addNotDeliveredOverlay(marker);
                if (marker.content) {
                    marker.content.style.opacity = '0.4';
                    marker.content.style.filter = 'grayscale(100%)';
                }
                // 游댠 Atualizar bot칚o para "Desfazer" laranja
                notDeliveredBtn.innerHTML = ' Desfazer';
                notDeliveredBtn.style.background = '#FF9800';
                notDeliveredBtn.removeEventListener('mouseenter', notDeliveredBtn._hoverIn);
                notDeliveredBtn.removeEventListener('mouseleave', notDeliveredBtn._hoverOut);
                notDeliveredBtn._hoverIn = () => { notDeliveredBtn.style.background = '#e68900'; };
                notDeliveredBtn._hoverOut = () => { notDeliveredBtn.style.background = '#FF9800'; };
                notDeliveredBtn.addEventListener('mouseenter', notDeliveredBtn._hoverIn);
                notDeliveredBtn.addEventListener('mouseleave', notDeliveredBtn._hoverOut);
                console.log(`九 Visual de N츾O ENTREGUE aplicado ao marcador verde: ${client.name}`);
            }

            bounds.extend(position);
        } catch (error) {
            console.error('Erro ao criar marcador verde:', error);
        }
    });

    // PASSO 6: Criar marcadores VERMELHOS para endere칞os n칚o cadastrados
    Object.entries(groupedByUnregistered).forEach(([coordKey, locationData]) => {
        const deliveryCount = locationData.deliveries.length;

        // Aplicar offset se houver marcadores sobrepostos
        const markerId = `unregistered_${coordKey}`;
        const offset = markerOffsets[markerId] || { latOffset: 0, lngOffset: 0 };
        const position = {
            lat: locationData.position.lat + offset.latOffset,
            lng: locationData.position.lng + offset.lngOffset
        };

        console.log(`仇 Criando marcador vermelho para local n칚o cadastrado: ${locationData.address} (${deliveryCount} entregas)`);

        // Criar marcador vermelho (mesmo estilo do verde)
        const markerDiv = document.createElement('div');
        markerDiv.style.cursor = 'pointer';
        markerDiv.style.transition = 'transform 0.2s';

        // Pin vermelho
        const pinImg = document.createElement('div');
        pinImg.style.width = '32px';
        pinImg.style.height = '32px';
        pinImg.style.background = '#EA4335'; // Vermelho
        pinImg.style.border = '3px solid white';
        pinImg.style.borderRadius = '50% 50% 50% 0';
        pinImg.style.transform = 'rotate(-45deg)';
        pinImg.style.boxShadow = '0 3px 6px rgba(0,0,0,0.4)';
        pinImg.style.display = 'flex';
        pinImg.style.alignItems = 'center';
        pinImg.style.justifyContent = 'center';

        const innerCircle = document.createElement('div');
        innerCircle.style.width = '18px';
        innerCircle.style.height = '18px';
        innerCircle.style.background = 'white';
        innerCircle.style.borderRadius = '50%';
        innerCircle.style.transform = 'rotate(45deg)';
        innerCircle.style.fontSize = '11px';
        innerCircle.style.fontWeight = 'bold';
        innerCircle.style.color = '#EA4335'; // Vermelho
        innerCircle.style.display = 'flex';
        innerCircle.style.alignItems = 'center';
        innerCircle.style.justifyContent = 'center';
        innerCircle.textContent = deliveryCount;

        pinImg.appendChild(innerCircle);
        markerDiv.appendChild(pinImg);

        // Efeito hover (mesmo do verde)
        markerDiv.addEventListener('mouseenter', () => { markerDiv.style.transform = 'scale(1.2)'; });
        markerDiv.addEventListener('mouseleave', () => { markerDiv.style.transform = 'scale(1)'; });

        // Criar InfoWindow
        const infoWindowContent = document.createElement('div');
        infoWindowContent.style.padding = '8px';
        infoWindowContent.style.maxWidth = '250px';
        infoWindowContent.style.maxHeight = '300px';
        infoWindowContent.style.overflowY = 'auto';

        // Badge de n칚o cadastrado
        const statusBadge = document.createElement('div');
        statusBadge.style.background = '#FF9800';
        statusBadge.style.color = 'white';
        statusBadge.style.padding = '4px 8px';
        statusBadge.style.borderRadius = '4px';
        statusBadge.style.fontSize = '11px';
        statusBadge.style.fontWeight = 'bold';
        statusBadge.style.marginBottom = '8px';
        statusBadge.style.display = 'inline-block';
        statusBadge.textContent = '丘 CLIENTE N츾O CADASTRADO';
        infoWindowContent.appendChild(statusBadge);

        // Endere칞o
        const addressInfoDiv = document.createElement('div');
        addressInfoDiv.style.fontSize = '12px';
        addressInfoDiv.style.color = '#333';
        addressInfoDiv.style.lineHeight = '1.5';
        addressInfoDiv.style.marginBottom = '10px';
        addressInfoDiv.style.padding = '8px';
        addressInfoDiv.style.background = '#f5f5f5';
        addressInfoDiv.style.borderRadius = '4px';

        let fullAddress = locationData.address || '';
        if (locationData.bairro) fullAddress += `\nBairro: ${locationData.bairro}`;
        if (locationData.city && locationData.zipcode) fullAddress += `\n${locationData.city} - ${locationData.zipcode}`;
        addressInfoDiv.innerHTML = fullAddress.replace(/\n/g, '<br>');
        infoWindowContent.appendChild(addressInfoDiv);

        // Lista de pacotes
        const packagesTitle = document.createElement('div');
        packagesTitle.style.fontWeight = 'bold';
        packagesTitle.style.fontSize = '11px';
        packagesTitle.style.color = '#666';
        packagesTitle.style.marginTop = '8px';
        packagesTitle.style.marginBottom = '6px';
        packagesTitle.style.borderTop = '1px solid #eee';
        packagesTitle.style.paddingTop = '8px';
        packagesTitle.textContent = `游닍 ${deliveryCount} pacote${deliveryCount > 1 ? 's' : ''}:`;
        infoWindowContent.appendChild(packagesTitle);

        locationData.deliveries.forEach((delivery, index) => {
            const deliveryDiv = document.createElement('div');
            deliveryDiv.style.fontSize = '11px';
            deliveryDiv.style.color = '#333';
            deliveryDiv.style.lineHeight = '1.4';
            deliveryDiv.style.marginBottom = '4px';
            deliveryDiv.style.paddingBottom = '4px';
            deliveryDiv.style.paddingLeft = '8px';
            if (index < locationData.deliveries.length - 1) deliveryDiv.style.borderBottom = '1px solid #eee';

            const qrDiv = document.createElement('div');
            qrDiv.style.display = 'flex';
            qrDiv.style.justifyContent = 'space-between';
            qrDiv.style.alignItems = 'center';
            qrDiv.style.gap = '8px';

            const sequenceSpan = document.createElement('span');
            sequenceSpan.style.color = '#EA4335';
            sequenceSpan.style.fontWeight = 'bold';
            sequenceSpan.textContent = `Ordem: ${delivery.sequence}`;

            const qrSpan = document.createElement('span');
            qrSpan.style.fontSize = '10px';
            qrSpan.style.color = '#666';
            qrSpan.style.fontFamily = 'monospace';
            qrSpan.textContent = delivery.spx_tn;

            qrDiv.appendChild(sequenceSpan);
            qrDiv.appendChild(qrSpan);
            deliveryDiv.appendChild(qrDiv);
            infoWindowContent.appendChild(deliveryDiv);
        });

        // Container de bot칫es (ser치 preenchido ap칩s criar o marker)
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.display = 'flex';
        buttonsContainer.style.flexWrap = 'wrap';
        buttonsContainer.style.gap = '4px';
        buttonsContainer.style.marginTop = '10px';
        buttonsContainer.style.width = '100%';
        infoWindowContent.appendChild(buttonsContainer);

        const infoWindow = new google.maps.InfoWindow({
            content: infoWindowContent,
            maxWidth: 300,
            disableAutoPan: true
        });

        // Vari치vel para armazenar o marker
        let marker;

        try {
            if (google.maps.marker && google.maps.marker.AdvancedMarkerElement) {
                marker = new google.maps.marker.AdvancedMarkerElement({
                    map,
                    position,
                    content: markerDiv,
                    title: `${deliveryCount} entrega${deliveryCount > 1 ? 's' : ''} neste local`
                });

                marker.addListener('click', () => {
                    if (currentInfoWindow) currentInfoWindow.close();
                    const savedHeading = map.getHeading() || 0;
                    const savedTilt = map.getTilt() || 0;
                    const headingListener = map.addListener('heading_changed', () => {
                        if (map.getHeading() !== savedHeading) map.setHeading(savedHeading);
                    });
                    const tiltListener = map.addListener('tilt_changed', () => {
                        if (map.getTilt() !== savedTilt) map.setTilt(savedTilt);
                    });

                    // Centralizar considerando o InfoWindow
                    setTimeout(() => {
                        const mapDiv = map.getDiv();
                        const scale = Math.pow(2, map.getZoom());

                        // Offset para mover o marcador mais para baixo (InfoWindow aparece acima)
                        const offsetY = 150; // pixels para deslocar para baixo
                        const latOffset = offsetY / scale * (85 / 111000); // Convers칚o aproximada

                        const newCenter = {
                            lat: position.lat - latOffset,
                            lng: position.lng
                        };

                        map.panTo(newCenter);
                    }, 100);

                    infoWindow.open(map, marker);
                    currentInfoWindow = infoWindow;
                    setTimeout(() => {
                        google.maps.event.removeListener(headingListener);
                        google.maps.event.removeListener(tiltListener);
                    }, 500);
                });

                deliveryMarkers[coordKey] = marker;
                unregisteredMarkersCount++;
            } else {
                marker = new google.maps.Marker({
                    map,
                    position,
                    title: `${deliveryCount} entrega${deliveryCount > 1 ? 's' : ''} neste local`,
                    icon: {
                        url: createPinSVG(deliveryCount, '#EA4335'),
                        scaledSize: new google.maps.Size(32, 44),
                        anchor: new google.maps.Point(16, 44)
                    }
                });

                marker.addListener('click', () => {
                    if (currentInfoWindow) currentInfoWindow.close();
                    const savedHeading = map.getHeading() || 0;
                    const savedTilt = map.getTilt() || 0;
                    const headingListener = map.addListener('heading_changed', () => {
                        if (map.getHeading() !== savedHeading) map.setHeading(savedHeading);
                    });
                    const tiltListener = map.addListener('tilt_changed', () => {
                        if (map.getTilt() !== savedTilt) map.setTilt(savedTilt);
                    });

                    // Centralizar considerando o InfoWindow
                    setTimeout(() => {
                        const mapDiv = map.getDiv();
                        const scale = Math.pow(2, map.getZoom());

                        // Offset para mover o marcador mais para baixo (InfoWindow aparece acima)
                        const offsetY = 150; // pixels para deslocar para baixo
                        const latOffset = offsetY / scale * (85 / 111000); // Convers칚o aproximada

                        const newCenter = {
                            lat: position.lat - latOffset,
                            lng: position.lng
                        };

                        map.panTo(newCenter);
                    }, 100);

                    infoWindow.open(map, marker);
                    currentInfoWindow = infoWindow;
                    setTimeout(() => {
                        google.maps.event.removeListener(headingListener);
                        google.maps.event.removeListener(tiltListener);
                    }, 500);
                });

                deliveryMarkers[coordKey] = marker;
                unregisteredMarkersCount++;
            }

            // Armazenar deliveries no marcador para uso posterior
            marker.deliveries = locationData.deliveries;

            // Adicionar bot칫es ao container (agora que o marker foi criado)
            // Calcular dist칙ncia do usu치rio ao marcador
            let distanceToMarker = Infinity;
            if (userLocationMarker && userLocationMarker.position) {
                const userPos = userLocationMarker.position;
                distanceToMarker = google.maps.geometry.spherical.computeDistanceBetween(
                    new google.maps.LatLng(userPos.lat, userPos.lng),
                    new google.maps.LatLng(position.lat, position.lng)
                );
            }

            // Bot칚o de navega칞칚o (s칩 aparece se estiver longe - mais de 30m)
            const navigateBtn = document.createElement('button');
            navigateBtn.style.flex = '1';
            navigateBtn.style.padding = '5px 6px';
            navigateBtn.style.background = '#4285f4';
            navigateBtn.style.color = 'white';
            navigateBtn.style.border = 'none';
            navigateBtn.style.borderRadius = '4px';
            navigateBtn.style.fontSize = '11px';
            navigateBtn.style.fontWeight = '600';
            navigateBtn.style.cursor = 'pointer';
            navigateBtn.style.transition = 'background 0.2s';
            navigateBtn.style.whiteSpace = 'nowrap';
            navigateBtn.style.minWidth = '0';
            navigateBtn.innerHTML = '游빐 Navegar';
            navigateBtn.addEventListener('mouseenter', () => { navigateBtn.style.background = '#3367d6'; });
            navigateBtn.addEventListener('mouseleave', () => { navigateBtn.style.background = '#4285f4'; });
            navigateBtn.addEventListener('click', () => {
                const clientData = {
                    name: locationData.address || 'Cliente',
                    latitude: position.lat,
                    longitude: position.lng,
                    address: fullAddress
                };
                navigateToClient(clientData, marker, infoWindow);
            });

            // 游댠 Esconder bot칚o Navegar se estiver pr칩ximo (< 30m)
            const isNearby = distanceToMarker < 30;
            if (isNearby) {
                navigateBtn.style.display = 'none';
            }

            // Bot칚o marcar como entregue / desfazer
            const deliveredBtn = document.createElement('button');
            deliveredBtn.style.flex = '1';
            deliveredBtn.style.padding = '5px 6px';
            deliveredBtn.style.background = '#34A853';
            deliveredBtn.style.color = 'white';
            deliveredBtn.style.border = 'none';
            deliveredBtn.style.borderRadius = '4px';
            deliveredBtn.style.fontSize = '11px';
            deliveredBtn.style.fontWeight = '600';
            deliveredBtn.style.cursor = 'pointer';
            deliveredBtn.style.transition = 'background 0.2s';
            deliveredBtn.style.whiteSpace = 'nowrap';
            deliveredBtn.style.minWidth = '0';
            deliveredBtn.innerHTML = '九 Entregue';

            // Armazenar fun칞칫es de hover para poder remov칡-las depois
            deliveredBtn._hoverIn = () => { deliveredBtn.style.background = '#2d8e47'; };
            deliveredBtn._hoverOut = () => { deliveredBtn.style.background = '#34A853'; };
            deliveredBtn.addEventListener('mouseenter', deliveredBtn._hoverIn);
            deliveredBtn.addEventListener('mouseleave', deliveredBtn._hoverOut);

            // Handler do clique - alterna entre entregar e desfazer
            deliveredBtn.addEventListener('click', async () => {
                if (marker.isDelivered) {
                    console.log(' Bot칚o Desfazer clicado (marcador vermelho)');
                    await undoDelivery(marker, deliveredBtn);
                } else {
                    console.log('游댖 Bot칚o Entregue clicado (marcador vermelho)');
                    await markAsDelivered(locationData.deliveries, null, marker, coordKey, deliveredBtn);
                }
            });

            // 游댠 NOVO: Bot칚o "N칚o Entregue" / "Desfazer"
            const notDeliveredBtn = document.createElement('button');
            notDeliveredBtn.style.flex = '1';
            notDeliveredBtn.style.padding = '5px 6px';
            notDeliveredBtn.style.background = '#EA4335';
            notDeliveredBtn.style.color = 'white';
            notDeliveredBtn.style.border = 'none';
            notDeliveredBtn.style.borderRadius = '4px';
            notDeliveredBtn.style.fontSize = '11px';
            notDeliveredBtn.style.fontWeight = '600';
            notDeliveredBtn.style.cursor = 'pointer';
            notDeliveredBtn.style.transition = 'background 0.2s';
            notDeliveredBtn.style.whiteSpace = 'nowrap';
            notDeliveredBtn.style.minWidth = '0';
            notDeliveredBtn.innerHTML = '九 N칚o Entg';

            // Armazenar fun칞칫es de hover para poder remov칡-las depois
            notDeliveredBtn._hoverIn = () => { notDeliveredBtn.style.background = '#c5351c'; };
            notDeliveredBtn._hoverOut = () => { notDeliveredBtn.style.background = '#EA4335'; };
            notDeliveredBtn.addEventListener('mouseenter', notDeliveredBtn._hoverIn);
            notDeliveredBtn.addEventListener('mouseleave', notDeliveredBtn._hoverOut);

            // Handler do clique - alterna entre "N칚o Entregue" e "Desfazer"
            notDeliveredBtn.addEventListener('click', async () => {
                const clientData = {
                    name: locationData.address || 'Cliente',
                    latitude: position.lat,
                    longitude: position.lng,
                    address: fullAddress
                };

                if (marker.isNotDelivered) {
                    console.log(' Bot칚o Desfazer (N칚o Entregue) clicado (marcador vermelho)');
                    await undoNotDelivered(marker, notDeliveredBtn);
                } else {
                    console.log('仇 Bot칚o N칚o Entregue clicado (marcador vermelho)');
                    await markAsNotDelivered(marker, clientData, notDeliveredBtn);
                }
            });

            buttonsContainer.appendChild(navigateBtn);
            buttonsContainer.appendChild(deliveredBtn);
            buttonsContainer.appendChild(notDeliveredBtn);

            // Aplicar visual baseado no status (se j치 foi entregue ou n칚o entregue)
            const firstDelivery = locationData.deliveries[0];
            console.log(`游댌 Status do marcador vermelho ${locationData.address}:`, firstDelivery.status);

            if (firstDelivery.status === 'delivered') {
                // Salvar originalState para poder desfazer
                marker.originalState = {
                    deliveries: locationData.deliveries,
                    client: null,
                    coordKey: coordKey,
                    isGreen: false
                };

                // Aplicar visual de entregue
                marker.isDelivered = true;
                if (marker.content) {
                    marker.content.style.opacity = '0.4';
                    marker.content.style.filter = 'grayscale(100%)';
                    const pinDiv = marker.content.querySelector('div');
                    if (pinDiv) {
                        pinDiv.style.background = '#9E9E9E';
                        const innerCircle = pinDiv.querySelector('div');
                        if (innerCircle) {
                            innerCircle.style.color = '#9E9E9E';
                        }
                    }
                }
                // Atualizar bot칚o
                deliveredBtn.innerHTML = ' Desfazer';
                deliveredBtn.style.background = '#FF9800';
                deliveredBtn.removeEventListener('mouseenter', deliveredBtn._hoverIn);
                deliveredBtn.removeEventListener('mouseleave', deliveredBtn._hoverOut);
                deliveredBtn._hoverIn = () => { deliveredBtn.style.background = '#e68900'; };
                deliveredBtn._hoverOut = () => { deliveredBtn.style.background = '#FF9800'; };
                deliveredBtn.addEventListener('mouseenter', deliveredBtn._hoverIn);
                deliveredBtn.addEventListener('mouseleave', deliveredBtn._hoverOut);
                console.log(`九 Visual de ENTREGUE aplicado ao marcador vermelho: ${locationData.address}`);
            } else if (firstDelivery.status === 'not_delivered') {
                // Salvar originalState para poder desfazer
                marker.originalState = {
                    deliveries: locationData.deliveries,
                    client: null,
                    coordKey: coordKey,
                    isGreen: false
                };

                // Aplicar visual de n칚o entregue (cinza igual ao entregue + X vermelho)
                marker.isNotDelivered = true;
                addNotDeliveredOverlay(marker);
                if (marker.content) {
                    marker.content.style.opacity = '0.4';
                    marker.content.style.filter = 'grayscale(100%)';
                }
                // 游댠 Atualizar bot칚o para "Desfazer" laranja
                notDeliveredBtn.innerHTML = ' Desfazer';
                notDeliveredBtn.style.background = '#FF9800';
                notDeliveredBtn.removeEventListener('mouseenter', notDeliveredBtn._hoverIn);
                notDeliveredBtn.removeEventListener('mouseleave', notDeliveredBtn._hoverOut);
                notDeliveredBtn._hoverIn = () => { notDeliveredBtn.style.background = '#e68900'; };
                notDeliveredBtn._hoverOut = () => { notDeliveredBtn.style.background = '#FF9800'; };
                notDeliveredBtn.addEventListener('mouseenter', notDeliveredBtn._hoverIn);
                notDeliveredBtn.addEventListener('mouseleave', notDeliveredBtn._hoverOut);
                console.log(`九 Visual de N츾O ENTREGUE aplicado ao marcador vermelho: ${locationData.address}`);
            }

            bounds.extend(position);
        } catch (error) {
            console.error('Erro ao criar marcador vermelho:', error);
        }
    });

    console.log(`九 Total: ${registeredMarkersCount + unregisteredMarkersCount} marcadores criados`);
    console.log(`九 Cadastrados: ${registeredMarkersCount} (verde) | N칚o cadastrados: ${unregisteredMarkersCount} (vermelho)`);

    // Ajustar mapa para mostrar todos os marcadores
    if (!bounds.isEmpty()) {
        map.fitBounds(bounds, {
            padding: 80 // Adicionar margem de 80px ao redor
        });
        console.log('游딬勇 Mapa ajustado para mostrar todos os marcadores');
    }

    // Mostrar toast com estat칤sticas
    const totalLocations = registeredMarkersCount + unregisteredMarkersCount;
    showToast(
        `游늸 ${totalLocations} Locais de entrega`,
        `九 ${registeredMarkersCount} cadastrado${registeredMarkersCount !== 1 ? 's' : ''} 仇 ${unregisteredMarkersCount} n칚o cadastrado${unregisteredMarkersCount !== 1 ? 's' : ''}`,
        'info',
        6000
    );
}

// ===========================
// ANIMA칂츾O 2D  3D
// ===========================

function animateValue(start, end, duration, onUpdate, onFinish) {
    const startTime = performance.now();
    let frameCount = 0;

    function frame(time) {
        const progress = Math.min((time - startTime) / duration, 1);

        // Easing function para anima칞칚o mais suave (easeInOutCubic)
        const eased = progress < 0.5
            ? 4 * progress * progress * progress
            : 1 - Math.pow(-2 * progress + 2, 3) / 2;

        const value = start + (end - start) * eased;

        // Limitar updates para 60fps m치ximo
        frameCount++;
        if (frameCount % 1 === 0) { // Atualiza a cada frame
            onUpdate(value);
        }

        if (progress < 1) {
            requestAnimationFrame(frame);
        } else {
            onUpdate(end); // Garantir valor final exato
            if (onFinish) onFinish();
        }
    }

    requestAnimationFrame(frame);
}

document.getElementById("btnToggle3D").onclick = () => {
    const btn = document.getElementById("btnToggle3D");

    if (_animating3D) return;
    _animating3D = true;

    btn.classList.add('loading');
    btn.disabled = true;

    if (!is3D) {
        is3D = true;

        animateValue(map.getTilt(), 67, 600, val => map.setTilt(val));
        animateValue(map.getHeading(), 45, 600, val => map.setHeading(val), () => {
            _animating3D = false;
            btn.classList.remove('loading');
            btn.classList.add('active');
            btn.textContent = "2D";
            btn.disabled = false;
            // Toast removido - bot칚o j치 indica o modo
        });

    } else {
        is3D = false;

        animateValue(map.getTilt(), 0, 600, val => map.setTilt(val));
        animateValue(map.getHeading(), 0, 600, val => map.setHeading(val), () => {
            _animating3D = false;
            btn.classList.remove('loading', 'active');
            btn.textContent = "3D";
            btn.disabled = false;
            // Toast removido - bot칚o j치 indica o modo
        });
    }
};

// ===========================
// BOT츾O PARAR NAVEGA칂츾O
// ===========================

document.getElementById("btnStopNavigation").onclick = () => {
    stopNavigationMode();
};

// ===========================
// CENTRALIZAR LOCALIZA칂츾O (BOT츾O ANTIGO - REMOVIDO)
// ===========================
// Agora usa o bot칚o GPS customizado adicionado via addGPSCenterButton()

/* C칍DIGO ANTIGO COMENTADO - Bot칚o removido do HTML
document.getElementById("btnCenterLocation").onclick = () => {
    const btn = document.getElementById("btnCenterLocation");

    // Usar GPS Tracker modular se dispon칤vel
    if (gpsTracker) {
        gpsTracker.centerOnUser();
        // Toast removido - a칞칚o visual j치 indica centraliza칞칚o
        return;
    }

    // Fallback para c칩digo legado
    if (!userLocationMarker) {
        showToast('Localiza칞칚o n칚o dispon칤vel', 'Aguarde obter sua posi칞칚o GPS', 'warning', 3000);
        return;
    }

    // Pega a posi칞칚o atual do marcador (compat칤vel com ambos os tipos)
    let currentPosition;
    if (userLocationMarker.position) {
        currentPosition = userLocationMarker.position;
    } else if (userLocationMarker.getPosition) {
        currentPosition = userLocationMarker.getPosition();
    }

    if (!currentPosition) {
        showToast('Erro ao centralizar', 'Posi칞칚o n칚o encontrada', 'error', 3000);
        return;
    }

    // Feedback visual no bot칚o
    btn.classList.add('loading');
    btn.disabled = true;

    // Anima o zoom e centraliza
    map.panTo(currentPosition);

    // Se estiver muito distante, ajusta o zoom
    const currentZoom = map.getZoom();
    if (currentZoom < 16) {
        map.setZoom(17);
    }

    // Remove o loading ap칩s a anima칞칚o
    setTimeout(() => {
        btn.classList.remove('loading');
        btn.disabled = false;
        showToast(
            'Centralizado!',
            `Precis칚o: ${Math.round(locationAccuracy)}m`,
            'success',
            2000
        );
    }, 400);
};
*/

// ===========================
// MODAL E QR CODE SCANNER
// ===========================

const modal = document.getElementById('modal-add-client');
const btnAddClient = document.getElementById('btn-add-client');
const btnModalClose = document.getElementById('modal-close');
const btnCancel = document.getElementById('btn-cancel');
const btnSave = document.getElementById('btn-save');
const form = document.getElementById('form-add-client');

const addressDisplay = document.getElementById('address-display');
const addressText = document.getElementById('address-text');

const inputName = document.getElementById('input-name');
const inputPhone = document.getElementById('input-phone');

// Elementos do dropdown customizado
const addressDropdown = document.getElementById('address-dropdown');
const dropdownHeader = document.getElementById('dropdown-header');
const dropdownList = document.getElementById('dropdown-list');

let scannedAddress = '';
let scannedQRCode = ''; // Armazena o c칩digo QR escaneado
let scannedLatLng = null; // Armazena coordenadas do endere칞o escaneado

// ===========================
// LOCATION PICKER (Marcador Arrast치vel no Mapa Principal)
// ===========================
const locationPickerBar = document.getElementById('location-picker-bar');
const locationPickerOverlay = document.getElementById('location-picker-overlay');
const btnConfirmLocation = document.getElementById('btn-confirm-location');
const btnCancelLocation = document.getElementById('btn-cancel-location');
const pickerCoordsDisplay = document.getElementById('picker-coords-display');

let selectedLocation = null; // Coordenadas selecionadas pelo usu치rio
let isLocationPickerActive = false; // Se o modo de sele칞칚o est치 ativo
let locationPickerCallback = null; // Callback quando confirmar localiza칞칚o
let mapDragListener = null; // Listener de arrasto do mapa
let mapDragEndListener = null; // Listener de fim de arrasto
let locationPickerFromModal = false; // Se o picker foi ativado a partir do modal

// Vari치veis do Cadastro R치pido (declaradas aqui para estar dispon칤vel no resetForm)
let isQuickRegisterMode = false; // Flag para indicar modo de cadastro r치pido
let quickRegisterAddressData = null; // Dados do endere칞o para salvar no modo r치pido

// Elementos da mira fixa
const locationPickerCrosshair = document.getElementById('location-picker-crosshair');
const locationPickerDot = document.getElementById('location-picker-dot');

// Ativar modo de sele칞칚o de localiza칞칚o (estilo Uber/99 - mira fixa, arrasta o mapa)
function activateLocationPicker(callback) {
    if (isLocationPickerActive) return;

    isLocationPickerActive = true;
    locationPickerCallback = callback;

    // Fechar sidebar se estiver aberto (garantir que n칚o sobreponha o picker)
    const sidebarEl = document.getElementById('sidebar');
    const sidebarOverlayEl = document.getElementById('sidebar-overlay');
    if (sidebarEl) sidebarEl.classList.remove('open');
    if (sidebarOverlayEl) sidebarOverlayEl.classList.remove('active');

    // Obter posi칞칚o inicial (GPS atual)
    let initialPosition = { lat: -1.4558, lng: -48.4902 }; // Fallback

    if (gpsTracker && gpsTracker.markerCoords.lat !== 0) {
        initialPosition = {
            lat: gpsTracker.markerCoords.lat,
            lng: gpsTracker.markerCoords.lng
        };
    } else if (userLocationMarker) {
        const pos = userLocationMarker.position || userLocationMarker.getPosition();
        if (pos) {
            initialPosition = { lat: pos.lat, lng: pos.lng };
        }
    }

    selectedLocation = initialPosition;

    // Centralizar mapa na posi칞칚o inicial com zoom bem pr칩ximo
    map.setCenter(initialPosition);
    map.setZoom(20); // Zoom m치ximo para ajuste preciso

    // Mostrar mira fixa e UI
    if (locationPickerCrosshair) locationPickerCrosshair.classList.add('active');
    if (locationPickerDot) locationPickerDot.classList.add('active');
    locationPickerBar.classList.add('active');
    locationPickerOverlay.classList.add('active');
    btnConfirmLocation.classList.add('active');
    btnCancelLocation.classList.add('active');

    // Esconder outros controles
    const mapControl = document.querySelector('.map-control');
    const statusBar = document.getElementById('status-bar');
    const btnAddClientEl = document.getElementById('btn-add-client');
    const btnQuickRegisterEl = document.getElementById('btn-quick-register');

    if (mapControl) mapControl.style.opacity = '0';
    if (statusBar) statusBar.style.opacity = '0';
    if (btnAddClientEl) btnAddClientEl.style.opacity = '0';
    if (btnQuickRegisterEl) btnQuickRegisterEl.style.opacity = '0';

    // Listener: quando o mapa 칠 arrastado, a mira "sobe"
    mapDragListener = map.addListener('drag', () => {
        if (locationPickerCrosshair) locationPickerCrosshair.classList.add('dragging');
        // Atualizar coordenadas em tempo real baseado no centro do mapa
        const center = map.getCenter();
        selectedLocation = { lat: center.lat(), lng: center.lng() };
        updatePickerCoordsDisplay();
    });

    // Listener: quando termina o arrasto, a mira "desce"
    mapDragEndListener = map.addListener('dragend', () => {
        if (locationPickerCrosshair) locationPickerCrosshair.classList.remove('dragging');
        // Pegar posi칞칚o final do centro do mapa
        const center = map.getCenter();
        selectedLocation = { lat: center.lat(), lng: center.lng() };
        updatePickerCoordsDisplay();
    });

    // Atualizar coordenadas iniciais
    updatePickerCoordsDisplay();

    console.log('游늸 [PICKER] Modo de sele칞칚o de localiza칞칚o ativado (mira fixa)');

    showToast(
        'Ajuste a posi칞칚o',
        'Arraste o mapa para posicionar a mira no local exato',
        'info',
        3000
    );
}

// Desativar modo de sele칞칚o
function deactivateLocationPicker(confirmed = false) {
    if (!isLocationPickerActive) return;

    isLocationPickerActive = false;

    // Remover listeners do mapa
    if (mapDragListener) {
        google.maps.event.removeListener(mapDragListener);
        mapDragListener = null;
    }
    if (mapDragEndListener) {
        google.maps.event.removeListener(mapDragEndListener);
        mapDragEndListener = null;
    }

    // Esconder mira fixa e UI
    if (locationPickerCrosshair) {
        locationPickerCrosshair.classList.remove('active');
        locationPickerCrosshair.classList.remove('dragging');
    }
    if (locationPickerDot) locationPickerDot.classList.remove('active');
    locationPickerBar.classList.remove('active');
    locationPickerOverlay.classList.remove('active');
    btnConfirmLocation.classList.remove('active');
    btnCancelLocation.classList.remove('active');

    // Mostrar controles novamente
    const mapControl = document.querySelector('.map-control');
    const statusBar = document.getElementById('status-bar');
    const btnAddClientEl = document.getElementById('btn-add-client');
    const btnQuickRegisterEl = document.getElementById('btn-quick-register');

    if (mapControl) mapControl.style.opacity = '1';
    if (statusBar) statusBar.style.opacity = '1';
    if (btnAddClientEl) btnAddClientEl.style.opacity = '1';
    if (btnQuickRegisterEl) btnQuickRegisterEl.style.opacity = '1';

    // Executar callback se confirmou
    if (confirmed && locationPickerCallback && selectedLocation) {
        locationPickerCallback(selectedLocation);
    }

    locationPickerCallback = null;

    console.log('游늸 [PICKER] Modo de sele칞칚o de localiza칞칚o desativado', confirmed ? '(confirmado)' : '(cancelado)');
}

// Atualizar coordenadas na barra
function updatePickerCoordsDisplay() {
    if (pickerCoordsDisplay && selectedLocation) {
        pickerCoordsDisplay.textContent = `${selectedLocation.lat.toFixed(5)}, ${selectedLocation.lng.toFixed(5)}`;
    }
}

// Resetar o picker (compatibilidade)
function resetLocationPicker() {
    deactivateLocationPicker(false);
    selectedLocation = null;
}

// Event listeners dos bot칫es
if (btnConfirmLocation) {
    btnConfirmLocation.addEventListener('click', () => {
        deactivateLocationPicker(true);
    });
}

if (btnCancelLocation) {
    btnCancelLocation.addEventListener('click', () => {
        deactivateLocationPicker(false);

        // Reabrir modal APENAS se o picker veio do modal
        if (locationPickerFromModal) {
            const modalEl = document.getElementById('modal-add-client');
            if (modalEl) {
                modalEl.style.display = ''; // Restaurar display
                modalEl.classList.add('active');
                document.body.style.overflow = 'hidden';
            }
            locationPickerFromModal = false; // Resetar flag
        }

        showToast(
            'Sele칞칚o cancelada',
            'A posi칞칚o ser치 definida pelo GPS atual',
            'info',
            2000
        );
    });
}

// Popular lista de endere칞os da planilha do dia (Supabase) no dropdown customizado
// Exibe apenas endere칞os N츾O cadastrados
async function populateAddressSelect() {
    if (!dropdownList) return;

    // Limpar itens anteriores
    dropdownList.innerHTML = '';

    try {
        // Buscar dados da planilha do dia no Supabase
        const { data: deliveryData, error } = await supabase
            .from('delivery_data')
            .select('*')
            .order('sequence', { ascending: true });

        if (error) {
            console.error('Erro ao buscar endere칞os da planilha:', error);
            return;
        }

        if (!deliveryData || deliveryData.length === 0) {
            const emptyItem = document.createElement('div');
            emptyItem.className = 'dropdown-item-empty';
            emptyItem.textContent = '丘멆잺 Nenhuma planilha carregada';
            dropdownList.appendChild(emptyItem);
            return;
        }

        // Buscar clientes j치 cadastrados
        const { data: clients, error: clientsError } = await supabase
            .from('clients')
            .select('address');

        if (clientsError) {
            console.warn('Erro ao buscar clientes:', clientsError);
        }

        // Criar Set de endere칞os j치 cadastrados (normalizados)
        const registeredAddresses = new Set();
        if (clients && clients.length > 0) {
            clients.forEach(client => {
                if (client.address) {
                    // Normalizar: primeira linha, lowercase, sem espa칞os extras
                    const firstLine = client.address.split('\n')[0].toLowerCase().trim();
                    registeredAddresses.add(firstLine);
                }
            });
        }

        // Filtrar apenas endere칞os N츾O cadastrados
        let addedCount = 0;
        deliveryData.forEach((item, index) => {
            // Verificar se j치 est치 cadastrado
            const addressFirstLine = (item.destination_address || '').split('\n')[0].toLowerCase().trim();

            if (registeredAddresses.has(addressFirstLine)) {
                // Endere칞o j치 cadastrado - pular
                return;
            }

            // Montar endere칞o completo
            const fullAddress = [
                item.destination_address,
                item.bairro ? `Bairro: ${item.bairro}` : '',
                item.city,
                item.zipcode
            ].filter(Boolean).join('\n');

            // Pegar primeira linha do endere칞o para exibi칞칚o
            const displayAddress = (item.destination_address || '').split('\n')[0].trim();

            // Usar sequence da planilha ou 칤ndice + 1
            const seq = item.sequence || (index + 1);

            // Criar item do dropdown
            const dropdownItem = document.createElement('div');
            dropdownItem.className = 'dropdown-item';
            dropdownItem.dataset.value = item.spx_tn || item.id;
            dropdownItem.dataset.address = fullAddress;
            dropdownItem.dataset.lat = item.latitude || 0;
            dropdownItem.dataset.lng = item.longitude || 0;
            dropdownItem.dataset.spxTn = item.spx_tn || '';

            dropdownItem.innerHTML = `
                <span class="dropdown-item-number">${seq}.</span>
                <span class="dropdown-item-address">${escapeHtml(displayAddress)}</span>
            `;

            // Evento de clique no item
            dropdownItem.addEventListener('click', () => selectDropdownItem(dropdownItem));

            dropdownList.appendChild(dropdownItem);
            addedCount++;
        });

        // Se todos j치 est칚o cadastrados
        if (addedCount === 0) {
            const successItem = document.createElement('div');
            successItem.className = 'dropdown-item-empty dropdown-item-success';
            successItem.textContent = '九 Todos os endere칞os j치 cadastrados';
            dropdownList.appendChild(successItem);
        }

        console.log(`游늶 ${addedCount} endere칞os n칚o cadastrados dispon칤veis (${deliveryData.length - addedCount} j치 cadastrados)`);

    } catch (err) {
        console.error('Erro ao popular dropdown de endere칞os:', err);
    }
}

// Fun칞칚o para selecionar item do dropdown
function selectDropdownItem(item) {
    const qrCode = item.dataset.spxTn || item.dataset.value;
    const address = item.dataset.address;
    const lat = parseFloat(item.dataset.lat) || 0;
    const lng = parseFloat(item.dataset.lng) || 0;

    // ===== MODO CADASTRO R츼PIDO =====
    if (isQuickRegisterMode) {
        // Salvar dados do endere칞o em vari치vel local (antes do closeModal resetar)
        const addressDataToSave = {
            address: address,
            latitude: lat,
            longitude: lng,
            spx_tn: qrCode
        };

        // Fechar dropdown e modal
        addressDropdown.classList.remove('open');
        stopCamera();

        // Fechar modal manualmente SEM resetar as vari치veis do cadastro r치pido
        modal.classList.remove('active');
        modal.classList.remove('quick-mode');
        document.body.style.overflow = '';

        // Verificar se j치 tem localiza칞칚o ajustada previamente
        if (selectedLocation) {
            // Usar a localiza칞칚o j치 ajustada e salvar diretamente
            console.log(`丘 Cadastro r치pido com localiza칞칚o pr칠-ajustada: ${address}`);
            saveQuickClient(addressDataToSave, selectedLocation).then(() => {
                closeQuickRegisterMode();
                selectedLocation = null; // Limpar ap칩s usar
            });
        } else {
            // Iniciar picker de localiza칞칚o com callback para salvar
            setTimeout(() => {
                activateLocationPicker(async (confirmedLocation) => {
                    await saveQuickClient(addressDataToSave, confirmedLocation);
                    closeQuickRegisterMode();
                });
            }, 300);
        }

        console.log(`丘 Cadastro r치pido: ${address}`);
        return;
    }

    // ===== MODO NORMAL =====
    // Atualizar vari치veis como se tivesse escaneado o QR Code
    scannedQRCode = qrCode;
    scannedAddress = address;
    if (lat && lng) {
        scannedLatLng = { lat, lng };
    }

    // Atualizar header do dropdown com o item selecionado
    const numberSpan = item.querySelector('.dropdown-item-number');
    const addressSpan = item.querySelector('.dropdown-item-address');
    dropdownHeader.innerHTML = `
        <span><span style="color: #EA4335; font-weight: 700;">${numberSpan.textContent}</span> ${addressSpan.textContent}</span>
        <span class="dropdown-arrow">郊</span>
    `;

    // Fechar dropdown
    addressDropdown.classList.remove('open');

    // Mostrar endere칞o selecionado
    addressDisplay.classList.add('active');
    addressText.textContent = address;

    // Parar c칙mera (n칚o precisa mais escanear)
    stopCamera();

    // Focar no campo nome para preenchimento
    setTimeout(() => {
        inputName.focus();
    }, 100);

    showToast(
        '游늸 Endere칞o selecionado',
        'Preencha os dados do cliente',
        'info',
        3000
    );

    console.log(`九 Endere칞o selecionado manualmente: ${qrCode}`);
}

// Evento de toggle do dropdown customizado
if (dropdownHeader) {
    dropdownHeader.addEventListener('click', function() {
        const isOpen = addressDropdown.classList.toggle('open');

        if (isOpen) {
            // Parar c칙mera ao abrir dropdown
            stopCamera();
            const qrStatus = document.getElementById('qr-status');
            if (qrStatus) {
                qrStatus.textContent = '낒勇 Aguardando sele칞칚o manual...';
            }
            console.log('游늶 Modo sele칞칚o manual ativado - c칙mera pausada');
        }
    });
}

// Fechar dropdown ao clicar fora
document.addEventListener('click', function(e) {
    if (addressDropdown && !addressDropdown.contains(e.target)) {
        addressDropdown.classList.remove('open');
    }
});

// Mostrar bot칫es ap칩s carregar o mapa
function showAddClientButton() {
    setTimeout(() => {
        btnAddClient.classList.add('visible');
        // Mostrar tamb칠m o bot칚o de cadastro r치pido
        if (btnQuickRegister) {
            btnQuickRegister.classList.add('visible');
        }
    }, 800);
}

// Abrir modal
async function openModal() {
    modal.classList.add('active');
    document.body.style.overflow = 'hidden';

    // Popular lista de endere칞os da planilha
    populateAddressSelect();

    // Verificar se c칙mera est치 dispon칤vel
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        showToast(
            'C칙mera n칚o dispon칤vel',
            'Seu navegador n칚o suporta acesso  c칙mera',
            'error',
            5000
        );
        return;
    }

    // Abrir c칙mera automaticamente
    try {
        await startCamera();
    } catch (error) {
        console.error('Erro ao abrir c칙mera:', error);

        let errorMessage = 'Verifique as permiss칫es do navegador';

        // Mensagens de erro mais espec칤ficas
        if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
            errorMessage = 'Permiss칚o negada. Permita o acesso  c칙mera nas configura칞칫es do navegador.';
        } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
            errorMessage = 'Nenhuma c칙mera encontrada no dispositivo.';
        } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
            errorMessage = 'C칙mera j치 est치 em uso por outro aplicativo.';
        } else if (error.name === 'OverconstrainedError') {
            errorMessage = 'C칙mera n칚o atende aos requisitos necess치rios.';
        } else if (error.name === 'SecurityError') {
            errorMessage = 'Acesso  c칙mera bloqueado por pol칤tica de seguran칞a.';
        }

        showToast(
            'Erro ao abrir c칙mera',
            errorMessage,
            'error',
            7000
        );
    }
}

// Fechar modal
function closeModal() {
    modal.classList.remove('active');
    modal.classList.remove('quick-mode'); // Remover modo r치pido
    document.body.style.overflow = '';
    resetForm();
    // Restaurar formul치rio normal (caso esteja mostrando painel de atualiza칞칚o)
    showNormalRegistrationForm();

    // Restaurar visibilidade dos campos escondidos pelo modo r치pido
    const formGroups = modal.querySelectorAll('.form-group');
    formGroups.forEach(group => {
        group.style.display = '';
    });
    const btnSaveEl = modal.querySelector('#btn-save');
    if (btnSaveEl) btnSaveEl.style.display = '';

    // Restaurar t칤tulo do modal se estava no modo r치pido
    const modalTitle = modal.querySelector('.modal-header h3');
    if (modalTitle) {
        modalTitle.innerHTML = '游늸 Adicionar Cliente';
    }
}

// Resetar formul치rio
function resetForm() {
    form.reset();
    addressDisplay.classList.remove('active');
    addressText.textContent = '';
    scannedAddress = '';
    scannedQRCode = '';
    scannedLatLng = null;
    stopCamera(); // Parar c칙mera ao fechar modal

    // Resetar seletor de localiza칞칚o
    resetLocationPicker();

    // Resetar bot칚o de ajuste de localiza칞칚o
    const locStatusEl = document.getElementById('location-status');
    if (locStatusEl) {
        locStatusEl.textContent = 'GPS atual';
        locStatusEl.classList.remove('adjusted');
    }

    // Resetar dropdown customizado de endere칞o manual
    if (addressDropdown) {
        addressDropdown.classList.remove('open');
        if (dropdownHeader) {
            dropdownHeader.innerHTML = `
                <span class="dropdown-placeholder">-- Escolha um endere칞o da planilha --</span>
                <span class="dropdown-arrow">郊</span>
            `;
        }
    }

    // Resetar modo de edi칞칚o
    isEditMode = false;
    editingClientId = null;
    btnSave.textContent = 'Salvar Cliente';

    // Resetar modo cadastro r치pido
    isQuickRegisterMode = false;
    quickRegisterAddressData = null;

    // Restaurar t칤tulo do scanner
    const scannerTitle = document.querySelector('.scanner-title span');
    if (scannerTitle) {
        scannerTitle.textContent = '游닞 Aponte a c칙mera para o QR Code';
    }
}

// Event listeners do modal
btnAddClient.addEventListener('click', async () => {
    // Verificar se est치 em modo de atualiza칞칚o de localiza칞칚o
    if (btnAddClient.dataset.updateMode === 'true' && pendingLocationUpdate) {
        // Ativar modo de sele칞칚o de localiza칞칚o com mira (igual ao cadastro)
        activateLocationPicker(async (confirmedLocation) => {
            // Callback quando usu치rio confirmar a localiza칞칚o
            await updateClientLocationWithCoords(
                pendingLocationUpdate.clientId,
                pendingLocationUpdate.clientName,
                confirmedLocation
            );
        });
    } else {
        openModal();
    }
});
btnModalClose.addEventListener('click', closeModal);
btnCancel.addEventListener('click', closeModal);

// Fechar modal ao clicar fora
modal.addEventListener('click', (e) => {
    if (e.target === modal) {
        closeModal();
    }
});

// ===========================
// BOT츾O AJUSTAR LOCALIZA칂츾O NO MAPA
// ===========================
const btnAdjustLocation = document.getElementById('btn-adjust-location');
const locationStatusEl = document.getElementById('location-status');

if (btnAdjustLocation) {
    btnAdjustLocation.addEventListener('click', () => {
        // Marcar que o picker veio do modal
        locationPickerFromModal = true;

        // Salvar se estava no modo r치pido para restaurar depois
        const wasQuickMode = isQuickRegisterMode;

        // Fechar modal completamente (esconder de verdade) mas N츾O remove quick-mode class
        modal.classList.remove('active');
        modal.style.display = 'none'; // For칞ar esconder imediatamente
        document.body.style.overflow = '';

        // Fechar sidebar se estiver aberto
        const sidebarEl = document.getElementById('sidebar');
        const sidebarOverlayEl = document.getElementById('sidebar-overlay');
        if (sidebarEl) sidebarEl.classList.remove('open');
        if (sidebarOverlayEl) sidebarOverlayEl.classList.remove('active');

        // Parar c칙mera
        stopCamera();

        // Ativar modo de sele칞칚o de localiza칞칚o
        activateLocationPicker((confirmedLocation) => {
            // Callback quando usu치rio confirmar a localiza칞칚o
            selectedLocation = confirmedLocation;

            // Atualizar status visual no bot칚o
            if (locationStatusEl) {
                locationStatusEl.textContent = '九 Ajustado';
                locationStatusEl.classList.add('adjusted');
            }

            // Reabrir modal mantendo quick-mode se estava ativo
            modal.style.display = ''; // Restaurar display
            modal.classList.add('active');
            if (wasQuickMode) {
                modal.classList.add('quick-mode');
            }
            document.body.style.overflow = 'hidden';

            // Resetar flag
            locationPickerFromModal = false;

            // Reiniciar c칙mera para continuar lendo QR code
            setTimeout(() => {
                startCamera();
            }, 300);

            console.log('游늸 Localiza칞칚o ajustada manualmente:', confirmedLocation);
        });
    });
}

// ===========================
// M츼SCARA DE TELEFONE
// ===========================

inputPhone.addEventListener('input', (e) => {
    let value = e.target.value.replace(/\D/g, ''); // Remove tudo que n칚o 칠 n칰mero

    // Limita a 11 d칤gitos
    if (value.length > 11) {
        value = value.slice(0, 11);
    }

    // Aplica a m치scara conforme o usu치rio digita
    let formatted = '';

    if (value.length > 0) {
        formatted = '(' + value.substring(0, 2); // (DD
    }
    if (value.length >= 3) {
        formatted += ')' + value.substring(2, 3); // (DD)D
    }
    if (value.length >= 4) {
        formatted += ' ' + value.substring(3, 7); // (DD)D DDDD
    }
    if (value.length >= 8) {
        formatted += '-' + value.substring(7, 11); // (DD)D DDDD-DDDD
    }

    e.target.value = formatted;
});

// Permitir apenas n칰meros e teclas de controle
inputPhone.addEventListener('keydown', (e) => {
    const allowedKeys = ['Backspace', 'Delete', 'Tab', 'ArrowLeft', 'ArrowRight', 'Home', 'End'];
    const isNumber = /^[0-9]$/.test(e.key);

    if (!isNumber && !allowedKeys.includes(e.key) && !e.ctrlKey && !e.metaKey) {
        e.preventDefault();
    }
});

// ===========================
// QR CODE SCANNER COM C츽MERA
// ===========================

const btnStopCamera = document.getElementById('btn-stop-camera');
const btnSwitchCamera = document.getElementById('btn-switch-camera');
const qrCameraContainer = document.getElementById('qr-camera-container');
const qrVideo = document.getElementById('qr-video');
const qrCanvas = document.getElementById('qr-canvas');
const qrStatus = document.getElementById('qr-status');

let videoStream = null;
let scanningInterval = null;
let currentFacingMode = 'environment'; // Come칞a com c칙mera traseira
let lastScannedCode = null;

// Fechar c칙mera
btnStopCamera.addEventListener('click', () => {
    stopCamera();
});

// Trocar c칙mera (frontal/traseira)
btnSwitchCamera.addEventListener('click', async () => {
    currentFacingMode = currentFacingMode === 'environment' ? 'user' : 'environment';
    stopCamera();
    await startCamera();
});

// Iniciar c칙mera
async function startCamera() {
    // Parar c칙mera existente antes de iniciar nova
    stopCamera();

    // 游 LAZY LOADING: Carregar jsQR apenas quando necess치rio
    if (!lazyLoader.isLoaded('jsQR')) {
        console.log('游닍 [LAZY] Carregando jsQR pela primeira vez...');
        try {
            await lazyLoader.loadJsQR();
        } catch (error) {
            showToast('Erro ao carregar scanner', 'N칚o foi poss칤vel carregar a biblioteca QR', 'error', 4000);
            return;
        }
    }

    // 游꿢 CONSTRAINTS EXATAMENTE COMO O GEMINI ESPECIFICA
    const constraints = {
        video: {
            facingMode: "environment", // Prioriza a c칙mera traseira (como Gemini especificou)
            // Resolu칞칚o otimizada para QR Code
            width: { ideal: 640 },  // Gemini: usar 640x480 para melhor performance
            height: { ideal: 480 },
            // 九 Configura칞칫es DIRETAS (sem { ideal: ... }) como Gemini especificou
            focusMode: "continuous",      // Mant칠m foco no objeto
            exposureMode: "continuous",   // Ajusta exposi칞칚o automaticamente
            whiteBalanceMode: "continuous"
        }
    };

    try {
        videoStream = await navigator.mediaDevices.getUserMedia(constraints);

        // Garantir que o v칤deo recebe o stream
        qrVideo.srcObject = videoStream;

        // 九 Deixar o sistema operacional gerenciar exposi칞칚o automaticamente
        // (removido c칩digo que for칞ava brilho alto e causava superexposi칞칚o)

        // Mostrar container da c칙mera
        qrCameraContainer.classList.add('active');

        // Aguardar v칤deo carregar e iniciar reprodu칞칚o
        return new Promise((resolve, reject) => {
            qrVideo.onloadedmetadata = async () => {
                try {
                    // For칞ar play do v칤deo
                    await qrVideo.play();

                    // Iniciar scanning ap칩s v칤deo come칞ar
                    startScanning();

                    resolve();
                } catch (playError) {
                    console.error('Erro ao iniciar reprodu칞칚o do v칤deo:', playError);
                    reject(playError);
                }
            };

            qrVideo.onerror = (error) => {
                console.error('Erro no elemento de v칤deo:', error);
                reject(error);
            };

            // Timeout de seguran칞a
            setTimeout(() => {
                if (qrVideo.readyState < 2) {
                    reject(new Error('Timeout ao carregar v칤deo'));
                }
            }, 10000);
        });

    } catch (error) {
        // Limpar em caso de erro
        stopCamera();
        qrCameraContainer.classList.remove('active');
        throw error;
    }
}

// Parar c칙mera
function stopCamera() {
    // Parar todas as tracks do stream
    if (videoStream) {
        videoStream.getTracks().forEach(track => {
            track.stop();
            track.enabled = false;
        });
        videoStream = null;
    }

    // Parar intervalo de scanning
    if (scanningInterval) {
        clearInterval(scanningInterval);
        scanningInterval = null;
    }

    // Limpar v칤deo completamente
    qrVideo.pause();
    qrVideo.srcObject = null;
    qrVideo.load(); // For칞a reload do elemento de v칤deo

    // Remover event listeners antigos
    qrVideo.onloadedmetadata = null;
    qrVideo.onerror = null;

    // Esconder container
    qrCameraContainer.classList.remove('active');

    // Resetar status
    qrStatus.textContent = 'Procurando QR Code...';
    qrStatus.classList.remove('success');
    lastScannedCode = null;
}

// Vari치veis para valida칞칚o de leitura
let consecutiveReads = 0;
let lastReadData = null;
const REQUIRED_CONSECUTIVE_READS = 2; // Precisa ler 2x consecutivo para confirmar

// Validar se o c칩digo lido parece ser um c칩digo de pacote v치lido
function isValidPackageCode(code) {
    if (!code || typeof code !== 'string') return false;

    // Remover espa칞os
    const trimmed = code.trim();

    // Verificar comprimento m칤nimo (c칩digos podem ter a partir de 4 caracteres)
    if (trimmed.length < 4) return false;

    // Rejeitar strings vazias ou apenas espa칞os
    if (trimmed.length === 0) return false;

    // Rejeitar URLs completas (falsos positivos de propagandas)
    if (trimmed.startsWith('http://') || trimmed.startsWith('https://')) return false;

    // Rejeitar c칩digos extremamente longos (> 100 caracteres - provavelmente erro)
    if (trimmed.length > 100) return false;

    // Aceitar qualquer c칩digo alfanum칠rico com s칤mbolos comuns de pacotes
    // Inclui: letras, n칰meros, h칤fen, underscore, ponto, barra, dois pontos, espa칞os
    const validPattern = /^[A-Za-z0-9\-_\.\/\:\s\#\@\+\=]+$/;
    if (!validPattern.test(trimmed)) {
        // Se falhar, ainda aceitar se tiver pelo menos 50% alfanum칠rico
        const alphanumCount = (trimmed.match(/[A-Za-z0-9]/g) || []).length;
        if (alphanumCount / trimmed.length < 0.5) return false;
    }

    return true;
}

// Iniciar loop de scanning otimizado
function startScanning() {
    const canvasContext = qrCanvas.getContext('2d', { willReadFrequently: true });

    // Resetar contadores
    consecutiveReads = 0;
    lastReadData = null;

    scanningInterval = setInterval(() => {
        if (qrVideo.readyState === qrVideo.HAVE_ENOUGH_DATA) {
            // 九 OTIMIZA칂츾O GEMINI 1: Reduzir resolu칞칚o de processamento
            // Em vez de processar a resolu칞칚o nativa (ex: 1920x1080 = 2M pixels),
            // processar apenas 640x480 (300k pixels) - 85% mais r치pido!
            const processWidth = 640;
            const processHeight = (qrVideo.videoHeight / qrVideo.videoWidth) * processWidth;

            qrCanvas.width = processWidth;
            qrCanvas.height = processHeight;

            // Desenhar v칤deo redimensionado no canvas
            canvasContext.drawImage(qrVideo, 0, 0, processWidth, processHeight);

            // 九 OTIMIZA칂츾O GEMINI 2: ROI (Region of Interest)
            // Processar apenas o centro da imagem (quadrado de 400x400px)
            // Isso reduz ainda mais o processamento em ~70%
            const scanSize = Math.min(400, processWidth, processHeight);
            const centerX = processWidth / 2;
            const centerY = processHeight / 2;

            // Capturar apenas a regi칚o central
            const imageData = canvasContext.getImageData(
                centerX - scanSize / 2,
                centerY - scanSize / 2,
                scanSize,
                scanSize
            );

            // 九 OTIMIZA칂츾O GEMINI 3: attemptBoth (j치 implementado)
            // Tenta ler QR codes normais E invertidos
            const code = jsQR(imageData.data, scanSize, scanSize, {
                inversionAttempts: "attemptBoth",
            });

            if (code && code.data) {
                const qrData = code.data.trim();

                // Validar se parece um c칩digo de pacote v치lido
                if (!isValidPackageCode(qrData)) {
                    // C칩digo inv치lido - ignorar silenciosamente
                    consecutiveReads = 0;
                    lastReadData = null;
                    return;
                }

                // Verificar tamanho m칤nimo do QR code detectado (evitar falsos positivos)
                const qrSize = Math.abs(code.location.bottomRightCorner.x - code.location.topLeftCorner.x);
                if (qrSize < 20) {
                    // QR code muito pequeno - pode ser ru칤do
                    return;
                }

                // Sistema de confirma칞칚o: precisa ler o mesmo c칩digo 2x consecutivo
                if (qrData === lastReadData) {
                    consecutiveReads++;
                } else {
                    consecutiveReads = 1;
                    lastReadData = qrData;
                }

                // Atualizar status visual
                qrStatus.textContent = `游댌 Lendo... (${consecutiveReads}/${REQUIRED_CONSECUTIVE_READS})`;

                // S칩 processar ap칩s leituras consecutivas confirmadas
                if (consecutiveReads >= REQUIRED_CONSECUTIVE_READS && qrData !== lastScannedCode) {
                    lastScannedCode = qrData;
                    consecutiveReads = 0;
                    lastReadData = null;

                    console.log('九 QR Code confirmado:', qrData);

                    // Feedback visual
                    qrStatus.textContent = '九 QR Code detectado!';
                    qrStatus.classList.add('success');

                    // Som de beep
                    playBeep();

                    // Processar resultado
                    handleQRCodeResult(qrData);

                    // Parar scanning ap칩s detectar
                    setTimeout(() => {
                        stopCamera();
                    }, 800);
                }
            } else {
                // Nenhum c칩digo detectado - resetar contador
                if (consecutiveReads > 0) {
                    consecutiveReads = 0;
                    lastReadData = null;
                }
            }
        }
    }, 50); // Scan a cada 50ms (20 fps) - mais r치pido para detectar
}

// Som de beep ao detectar QR code
function playBeep() {
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();

    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);

    oscillator.frequency.value = 800;
    oscillator.type = 'sine';

    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);

    oscillator.start(audioContext.currentTime);
    oscillator.stop(audioContext.currentTime + 0.2);
}

// Processar resultado do QR Code
async function handleQRCodeResult(qrData) {
    console.log('Processando QR Code:', qrData);

    // Buscar endere칞o no banco de dados (delivery_data)
    const addressData = await lookupAddressData(qrData);

    if (addressData) {
        // Verificar se o endere칞o J츼 EST츼 CADASTRADO na tabela clients
        const existingClient = await checkClientByAddress(addressData.address);

        if (existingClient) {
            // Cliente j치 cadastrado - mostrar op칞칚o de atualizar localiza칞칚o
            showUpdateLocationPanel(existingClient, addressData);
            return;
        }

        // ===== MODO CADASTRO R츼PIDO =====
        if (isQuickRegisterMode) {
            // Salvar dados do endere칞o em vari치vel local (antes de fechar o modal)
            const addressDataToSave = addressData;

            // Parar c칙mera
            stopCamera();

            // Fechar modal manualmente SEM resetar as vari치veis
            modal.classList.remove('active');
            modal.classList.remove('quick-mode');
            document.body.style.overflow = '';

            // Verificar se j치 tem localiza칞칚o ajustada previamente
            if (selectedLocation) {
                // Usar a localiza칞칚o j치 ajustada e salvar diretamente
                console.log(`丘 Cadastro r치pido via QR com localiza칞칚o pr칠-ajustada`);
                saveQuickClient(addressDataToSave, selectedLocation).then(() => {
                    closeQuickRegisterMode();
                    selectedLocation = null; // Limpar ap칩s usar
                });
            } else {
                // Iniciar picker de localiza칞칚o com callback para salvar
                setTimeout(() => {
                    activateLocationPicker(async (confirmedLocation) => {
                        await saveQuickClient(addressDataToSave, confirmedLocation);
                        closeQuickRegisterMode();
                    });
                }, 300);
            }
            return;
        }

        // ===== MODO NORMAL =====
        // Cliente N츾O cadastrado - fluxo normal de cadastro
        scannedAddress = addressData.address;
        scannedQRCode = qrData;
        scannedLatLng = {
            latitude: addressData.latitude,
            longitude: addressData.longitude
        };

        // Mostrar formul치rio normal
        showNormalRegistrationForm();

        addressText.textContent = addressData.address;
        addressDisplay.classList.add('active');

        showToast(
            '九 Endere칞o encontrado!',
            'Preencha o nome do cliente',
            'success',
            3000
        );

        // Focar automaticamente no campo de nome
        setTimeout(() => {
            inputName.focus();
        }, 500);
    } else {
        // Endere칞o n칚o encontrado
        if (isQuickRegisterMode) {
            showToast(
                '丘멆잺 Endere칞o n칚o encontrado',
                'Este QR code n칚o est치 na planilha',
                'warning',
                4000
            );
            return;
        }

        // Modo normal - mostrar c칩digo
        scannedAddress = `C칩digo QR: ${qrData} (Endere칞o n칚o cadastrado)`;
        scannedQRCode = qrData;
        scannedLatLng = null; // Sem coordenadas

        // Mostrar formul치rio normal
        showNormalRegistrationForm();

        addressText.textContent = scannedAddress;
        addressDisplay.classList.add('active');

        showToast(
            '丘멆잺 Endere칞o n칚o cadastrado',
            'Este QR code n칚o est치 no banco de dados',
            'warning',
            4000
        );

        // Focar automaticamente no campo de nome
        setTimeout(() => {
            inputName.focus();
        }, 500);
    }
}

// Verificar se j치 existe cliente cadastrado com o endere칞o
async function checkClientByAddress(address) {
    try {
        // Extrair a primeira linha do endere칞o (rua e n칰mero) para busca
        const addressFirstLine = address.split('\n')[0].trim();

        const { data, error } = await supabase
            .from('clients')
            .select('*')
            .ilike('address', `%${addressFirstLine}%`)
            .limit(1);

        if (error) {
            console.error('Erro ao verificar cliente:', error);
            return null;
        }

        return data && data.length > 0 ? data[0] : null;
    } catch (error) {
        console.error('Erro ao verificar cliente:', error);
        return null;
    }
}

// Vari치vel global para armazenar dados do cliente a ser atualizado
let pendingLocationUpdate = null;

// Mostrar modo de atualiza칞칚o de localiza칞칚o (cliente j치 cadastrado)
function showUpdateLocationPanel(client, addressData) {
    // Fechar o modal do QR code
    closeModal();

    // Armazenar dados do cliente para atualiza칞칚o
    pendingLocationUpdate = {
        clientId: client.id,
        clientName: client.name,
        clientAddress: client.address
    };

    // Criar banner no topo da tela com info do cliente
    createClientInfoBanner(client);

    // Transformar bot칚o "Adicionar Cliente" em "Atualizar Localiza칞칚o"
    transformAddButtonToUpdate();

    // Centralizar no marcador do cliente se existir com zoom 80%
    if (client.latitude && client.longitude) {
        const clientPos = { lat: client.latitude, lng: client.longitude };
        map.panTo(clientPos);
        map.setZoom(20); // Zoom 80%
    }

    showToast(
        '九 Cliente j치 cadastrado!',
        'Aproxime o mapa e clique no bot칚o para atualizar',
        'info',
        4000
    );
}

// Criar banner no topo da tela com informa칞칫es do cliente
function createClientInfoBanner(client) {
    // Remover banner anterior se existir
    const existingBanner = document.getElementById('client-info-banner');
    if (existingBanner) existingBanner.remove();

    const banner = document.createElement('div');
    banner.id = 'client-info-banner';
    banner.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        background: linear-gradient(135deg, #1976D2 0%, #1565C0 100%);
        color: white;
        padding: 12px 16px;
        z-index: 9999;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
    `;

    // Formatar endere칞o completo
    const fullAddress = client.address.replace(/\n/g, '  ');

    banner.innerHTML = `
        <div style="flex: 1; min-width: 0;">
            <div style="font-size: 14px; font-weight: 700; margin-bottom: 4px;">
                ${client.name}
            </div>
            <div style="font-size: 12px; opacity: 0.9; line-height: 1.3;">
                ${fullAddress}
            </div>
        </div>
        <button id="btn-cancel-location-update" style="
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            white-space: nowrap;
            flex-shrink: 0;
        ">
            九 Cancelar
        </button>
    `;

    document.body.appendChild(banner);

    // Event listener para cancelar
    document.getElementById('btn-cancel-location-update').addEventListener('click', () => {
        cancelLocationUpdate();
    });
}

// Transformar bot칚o "Adicionar Cliente" em "Atualizar Localiza칞칚o"
function transformAddButtonToUpdate() {
    const btnAddClient = document.getElementById('btn-add-client');
    if (!btnAddClient) return;

    // Salvar estado original
    btnAddClient.dataset.originalHtml = btnAddClient.innerHTML;
    btnAddClient.dataset.originalBackground = btnAddClient.style.background || '';

    // Transformar em bot칚o de atualiza칞칚o
    btnAddClient.innerHTML = '游댃 Atualizar Localiza칞칚o';
    btnAddClient.style.background = 'linear-gradient(135deg, #ff9800 0%, #f57c00 100%)';
    btnAddClient.style.animation = 'pulse-update 1.5s infinite';

    // Adicionar anima칞칚o CSS se n칚o existir
    if (!document.getElementById('update-button-animation')) {
        const style = document.createElement('style');
        style.id = 'update-button-animation';
        style.textContent = `
            @keyframes pulse-update {
                0%, 100% { transform: translateX(-50%) scale(1); box-shadow: 0 4px 15px rgba(255, 152, 0, 0.4); }
                50% { transform: translateX(-50%) scale(1.05); box-shadow: 0 6px 20px rgba(255, 152, 0, 0.6); }
            }
        `;
        document.head.appendChild(style);
    }

    // Marcar como modo de atualiza칞칚o
    btnAddClient.dataset.updateMode = 'true';
}

// Restaurar bot칚o "Adicionar Cliente" ao estado original
function restoreAddButton() {
    const btnAddClient = document.getElementById('btn-add-client');
    if (!btnAddClient) return;

    // Restaurar estado original
    if (btnAddClient.dataset.originalHtml) {
        btnAddClient.innerHTML = btnAddClient.dataset.originalHtml;
    } else {
        btnAddClient.innerHTML = '+ Adicionar Cliente';
    }

    btnAddClient.style.background = btnAddClient.dataset.originalBackground || '';
    btnAddClient.style.animation = '';

    // Remover marca칞칚o de modo de atualiza칞칚o
    delete btnAddClient.dataset.updateMode;
    delete btnAddClient.dataset.originalHtml;
    delete btnAddClient.dataset.originalBackground;
}

// Cancelar modo de atualiza칞칚o de localiza칞칚o
function cancelLocationUpdate() {
    pendingLocationUpdate = null;

    // Remover banner
    const banner = document.getElementById('client-info-banner');
    if (banner) banner.remove();

    // Restaurar bot칚o
    restoreAddButton();

    showToast(
        'Atualiza칞칚o cancelada',
        'O bot칚o voltou ao estado original',
        'info',
        2000
    );
}

// Atualizar localiza칞칚o do cliente no banco de dados (com coordenadas manuais)
async function updateClientLocationWithCoords(clientId, clientName, coords) {
    if (!coords || !coords.lat || !coords.lng) {
        showToast(
            '仇 Erro',
            'Coordenadas inv치lidas',
            'error',
            4000
        );
        return;
    }

    try {
        // Atualizar no banco de dados
        const { error } = await supabase
            .from('clients')
            .update({
                latitude: coords.lat,
                longitude: coords.lng
            })
            .eq('id', clientId);

        if (error) {
            throw error;
        }

        showToast(
            '九 Localiza칞칚o Atualizada!',
            `${clientName} - Nova posi칞칚o salva no mapa`,
            'success',
            5000
        );

        // Limpar modo de atualiza칞칚o
        pendingLocationUpdate = null;

        // Remover banner do topo
        const banner = document.getElementById('client-info-banner');
        if (banner) banner.remove();

        // Restaurar bot칚o ao estado original
        restoreAddButton();

        // Recarregar marcadores para refletir a mudan칞a
        if (typeof toggleClientsOnMap === 'function') {
            // Desligar e ligar novamente para atualizar
            if (clientsVisible) {
                await toggleClientsOnMap();
                await toggleClientsOnMap();
            }
        }

        console.log('游늸 Localiza칞칚o atualizada com sucesso:', coords);

    } catch (error) {
        console.error('Erro ao atualizar localiza칞칚o:', error);
        showToast(
            '仇 Erro ao atualizar',
            'N칚o foi poss칤vel salvar a nova localiza칞칚o',
            'error',
            4000
        );
    }
}

// Atualizar localiza칞칚o do cliente no banco de dados (GPS autom치tico - legado)
async function updateClientLocation(clientId, clientName) {
    // Obter posi칞칚o GPS atual
    let currentPosition = null;

    if (gpsTracker && gpsTracker.markerCoords) {
        currentPosition = gpsTracker.markerCoords;
    } else if (userLocationMarker) {
        if (userLocationMarker.position) {
            currentPosition = userLocationMarker.position;
        } else if (userLocationMarker.getPosition) {
            const pos = userLocationMarker.getPosition();
            currentPosition = { lat: pos.lat(), lng: pos.lng() };
        }
    }

    if (!currentPosition || !currentPosition.lat || !currentPosition.lng) {
        showToast(
            '仇 Erro de GPS',
            'N칚o foi poss칤vel obter sua localiza칞칚o atual',
            'error',
            4000
        );
        return;
    }

    // Usar a nova fun칞칚o com coordenadas
    await updateClientLocationWithCoords(clientId, clientName, currentPosition);
}

// Mostrar formul치rio normal de cadastro
function showNormalRegistrationForm() {
    const form = document.getElementById('form-add-client');
    const formFooter = document.querySelector('#modal-add-client .form-footer');

    if (form) form.style.display = 'block';
    if (formFooter) formFooter.style.display = 'flex';

    // Remover painel de atualiza칞칚o se existir
    const updatePanel = document.getElementById('update-location-panel');
    if (updatePanel) updatePanel.remove();
}


// Buscar dados completos do endere칞o no banco de dados (delivery_data)
async function lookupAddressData(qrCode) {
    try {
        // Buscar na tabela delivery_data pelo SPX TN (c칩digo QR)
        const { data, error } = await supabase
            .from('delivery_data')
            .select('*')
            .eq('spx_tn', qrCode)
            .single();

        if (error) {
            console.warn('Erro ao buscar QR code:', error);
            // Fallback: buscar no addressDatabase hardcoded (compatibilidade)
            if (addressDatabase[qrCode]) {
                return addressDatabase[qrCode];
            }
            return null;
        }

        if (data) {
            // Formatar endere칞o no mesmo padr칚o
            let formattedAddress = data.destination_address || '';
            if (data.bairro) {
                formattedAddress += `\nBairro: ${data.bairro}`;
            }
            if (data.city && data.zipcode) {
                formattedAddress += `\n${data.city} - ${data.zipcode}`;
            }

            return {
                address: formattedAddress,
                latitude: data.latitude,
                longitude: data.longitude
            };
        }

        // Se n칚o encontrou no Supabase, tentar no addressDatabase
        if (addressDatabase[qrCode]) {
            return addressDatabase[qrCode];
        }

        return null;

    } catch (error) {
        console.error('Erro ao buscar endere칞o:', error);
        // Fallback: buscar no addressDatabase
        if (addressDatabase[qrCode]) {
            return addressDatabase[qrCode];
        }
        return null;
    }
}

// Buscar endere칞o no banco de dados (fun칞칚o legada - mantida para compatibilidade)
async function lookupAddress(qrCode) {
    const data = await lookupAddressData(qrCode);
    return data ? data.address : null;
}

// ===========================
// CADASTRO R츼PIDO
// ===========================

const btnQuickRegister = document.getElementById('btn-quick-register');

// Abrir modal no modo cadastro r치pido (usa o mesmo modal, mas esconde formul치rio)
function openQuickRegisterModal() {
    isQuickRegisterMode = true;
    quickRegisterAddressData = null;

    // Adicionar classe para estiliza칞칚o diferenciada
    modal.classList.add('quick-mode');

    // Esconder campos de nome e telefone via JavaScript (fallback para navegadores sem :has())
    const formGroups = modal.querySelectorAll('.form-group');
    formGroups.forEach(group => {
        // Esconder apenas nome e telefone, N츾O o bot칚o de ajustar localiza칞칚o
        if (group.querySelector('#input-name') || group.querySelector('#input-phone')) {
            group.style.display = 'none';
        }
    });

    // Esconder bot칚o Salvar
    const btnSaveEl = modal.querySelector('#btn-save');
    if (btnSaveEl) btnSaveEl.style.display = 'none';

    // Alterar t칤tulo do modal
    const modalTitle = modal.querySelector('.modal-header h3');
    if (modalTitle) {
        modalTitle.innerHTML = '丘 Cadastro R치pido';
    }

    // Abrir modal normalmente
    openModal();

    showToast(
        '丘 Modo R치pido',
        'Escaneie o QR ou escolha da lista',
        'info',
        2000
    );
}

// Fechar modo cadastro r치pido e restaurar modal normal
function closeQuickRegisterMode() {
    isQuickRegisterMode = false;
    quickRegisterAddressData = null;

    // Remover classe de estiliza칞칚o
    modal.classList.remove('quick-mode');

    // Restaurar visibilidade dos campos escondidos via JavaScript
    const formGroups = modal.querySelectorAll('.form-group');
    formGroups.forEach(group => {
        group.style.display = '';
    });

    // Restaurar bot칚o Salvar
    const btnSaveEl = modal.querySelector('#btn-save');
    if (btnSaveEl) btnSaveEl.style.display = '';

    // Restaurar t칤tulo do modal
    const modalTitle = modal.querySelector('.modal-header h3');
    if (modalTitle) {
        modalTitle.innerHTML = '游늸 Adicionar Cliente';
    }
}

// Salvar cliente no modo r치pido (apenas endere칞o e localiza칞칚o)
async function saveQuickClient(addressData, location) {
    try {
        const clientData = {
            name: '', // Sem nome - pode ser preenchido depois
            phone: '', // Sem telefone - pode ser preenchido depois
            address: addressData.address,
            latitude: location.lat,
            longitude: location.lng,
            created_at: new Date().toISOString()
        };

        const { data, error } = await supabase
            .from('clients')
            .insert([clientData])
            .select();

        if (error) throw error;

        console.log('九 Cliente r치pido salvo:', data);

        showToast(
            '九 Cliente cadastrado!',
            'Edite no menu lateral para adicionar nome/telefone',
            'success',
            4000
        );

        // Atualizar lista de clientes e marcadores
        await loadClients();

        // Atualizar lista de endere칞os no modal
        await populateAddressSelect();

    } catch (error) {
        console.error('Erro ao salvar cliente r치pido:', error);
        showToast(
            '仇 Erro ao salvar',
            error.message || 'Tente novamente',
            'error',
            4000
        );
    }
}

// Event Listener do Bot칚o Cadastro R치pido
if (btnQuickRegister) {
    btnQuickRegister.addEventListener('click', openQuickRegisterModal);
}

// ===========================
// SALVAR CLIENTE
// ===========================

form.addEventListener('submit', async (e) => {
    e.preventDefault();

    // Preparar dados do cliente
    const clientData = {
        name: inputName.value.trim(),
        phone: inputPhone.value.trim(),
        address: scannedAddress,
        created_at: new Date().toISOString()
    };

    // PRIORIDADE: Usar coordenadas selecionadas no picker do mapa
    // Se o usu치rio ajustou manualmente a posi칞칚o, usar essa localiza칞칚o
    if (selectedLocation && selectedLocation.lat && selectedLocation.lng) {
        clientData.latitude = selectedLocation.lat;
        clientData.longitude = selectedLocation.lng;
        console.log('游늸 Salvando localiza칞칚o selecionada no mapa:', selectedLocation);
    } else {
        // Fallback 1: usar posi칞칚o GPS atual
        let currentPosition = null;
        if (userLocationMarker) {
            if (userLocationMarker.position) {
                currentPosition = userLocationMarker.position;
            } else if (userLocationMarker.getPosition) {
                currentPosition = userLocationMarker.getPosition();
            }
        }

        if (currentPosition) {
            clientData.latitude = currentPosition.lat;
            clientData.longitude = currentPosition.lng;
            console.log('游늸 Salvando localiza칞칚o GPS atual:', currentPosition);
        } else {
            // Fallback 2: usar coordenadas do QR code se dispon칤veis
            if (scannedLatLng) {
                clientData.latitude = scannedLatLng.latitude;
                clientData.longitude = scannedLatLng.longitude;
                console.log('游늸 Usando coordenadas do QR code:', scannedLatLng);
            } else {
                console.warn('丘멆잺 Nenhuma coordenada dispon칤vel para salvar');
            }
        }
    }

    // Valida칞칚o
    if (!clientData.name) {
        showToast(
            'Campo obrigat칩rio',
            'Preencha o nome do cliente',
            'error',
            4000
        );
        return;
    }

    if (!clientData.address) {
        showToast(
            'Escaneie o QR Code',
            '칄 necess치rio escanear o QR Code do pacote primeiro',
            'error',
            4000
        );
        return;
    }

    // Loading
    btnSave.classList.add('loading');
    btnSave.disabled = true;

    try {
        if (isEditMode && editingClientId) {
            // MODO EDI칂츾O - Atualizar cliente existente
            const { data, error } = await supabase
                .from('clients')
                .update(clientData)
                .eq('id', editingClientId)
                .select();

            if (error) throw error;

            console.log('Cliente atualizado:', data);

            showToast(
                'Cliente atualizado!',
                `${clientData.name} foi atualizado com sucesso`,
                'success',
                4000
            );
        } else {
            // MODO CRIA칂츾O - Inserir novo cliente
            const { data, error } = await supabase
                .from('clients')
                .insert([clientData])
                .select();

            if (error) throw error;

            console.log('Cliente salvo:', data);

            showToast(
                'Cliente adicionado!',
                `${clientData.name} foi cadastrado com sucesso`,
                'success',
                4000
            );
        }

        // Atualizar lista de clientes no sidebar
        await loadClients();

        closeModal();

    } catch (error) {
        console.error('Erro ao salvar cliente:', error);
        showToast(
            'Erro ao salvar',
            error.message || 'N칚o foi poss칤vel salvar o cliente',
            'error',
            5000
        );
    } finally {
        btnSave.classList.remove('loading');
        btnSave.disabled = false;
    }
});

// ===========================
// SIDEBAR - MENU LATERAL
// ===========================

const sidebar = document.getElementById('sidebar');
const sidebarOverlay = document.getElementById('sidebar-overlay');
const btnOpenSidebar = document.getElementById('btnOpenSidebar');
const btnCloseSidebar = document.getElementById('sidebar-close');
const clientsList = document.getElementById('clients-list');
const searchInput = document.getElementById('search-input');
const clientCount = document.getElementById('client-count');

let allClients = [];
let filteredClients = [];

// Abrir sidebar
btnOpenSidebar.addEventListener('click', () => {
    openSidebar();
    loadClients();
});

// Fechar sidebar
btnCloseSidebar.addEventListener('click', closeSidebar);
sidebarOverlay.addEventListener('click', closeSidebar);

function openSidebar() {
    sidebar.classList.add('open');
    sidebarOverlay.classList.add('active');
}

function closeSidebar() {
    sidebar.classList.remove('open');
    sidebarOverlay.classList.remove('active');
}

// Busca em tempo real
searchInput.addEventListener('input', (e) => {
    const searchTerm = e.target.value.toLowerCase().trim();

    if (searchTerm === '') {
        filteredClients = allClients;
    } else {
        filteredClients = allClients.filter(client => {
            const name = (client.name || '').toLowerCase();
            const address = (client.address || '').toLowerCase();
            const phone = (client.phone || '').toLowerCase();

            return name.includes(searchTerm) ||
                   address.includes(searchTerm) ||
                   phone.includes(searchTerm);
        });
    }

    renderClients(filteredClients);
});

// Carregar clientes do Supabase
async function loadClients() {
    try {
        const { data, error } = await supabase
            .from('clients')
            .select('*')
            .order('created_at', { ascending: false });

        if (error) {
            console.error('Erro do Supabase:', error);
            throw error;
        }

        allClients = data || [];
        filteredClients = allClients;

        renderClients(filteredClients);
        updateClientCount(allClients.length);

        console.log(`${allClients.length} cliente(s) carregado(s)`);

    } catch (error) {
        console.error('Erro ao carregar clientes:', error);

        // Mostrar mensagem mais espec칤fica
        let errorMsg = 'N칚o foi poss칤vel carregar a lista de clientes';

        if (error.message && error.message.includes('Failed to fetch')) {
            errorMsg = 'Verifique se a tabela "clients" existe no Supabase';
        } else if (error.code) {
            errorMsg = `Erro Supabase: ${error.message}`;
        }

        showToast(
            'Erro ao carregar',
            errorMsg,
            'error',
            6000
        );

        // Mostrar empty state mesmo com erro
        renderClients([]);
    }
}

// ===========================
// SUPABASE REALTIME - Sincroniza칞칚o entre navegadores
// ===========================

let clientsChannel = null;
let deliveryDataChannel = null;

// Inicializar Realtime para sincroniza칞칚o autom치tica
function initRealtimeSync() {
    console.log('游니 [REALTIME] Iniciando configura칞칚o...');

    // Remover canais anteriores se existirem
    if (clientsChannel) {
        console.log('游니 [REALTIME] Removendo canal clients anterior...');
        supabase.removeChannel(clientsChannel);
    }
    if (deliveryDataChannel) {
        console.log('游니 [REALTIME] Removendo canal delivery_data anterior...');
        supabase.removeChannel(deliveryDataChannel);
    }

    try {
        // Criar canal para escutar mudan칞as na tabela clients
        clientsChannel = supabase
            .channel('clients-realtime-channel')
            .on(
                'postgres_changes',
                {
                    event: '*', // Escutar INSERT, UPDATE, DELETE
                    schema: 'public',
                    table: 'clients'
                },
                (payload) => {
                    console.log('游니 [REALTIME] ========================================');
                    console.log('游니 [REALTIME] MUDAN칂A DETECTADA!');
                    console.log('游니 [REALTIME] Tipo:', payload.eventType);
                    console.log('游니 [REALTIME] Dados novos:', JSON.stringify(payload.new));
                    console.log('游니 [REALTIME] Dados antigos:', JSON.stringify(payload.old));
                    console.log('游니 [REALTIME] ========================================');
                    handleRealtimeChange(payload);
                }
            )
            .subscribe((status, err) => {
                console.log('游니 [REALTIME] Status da conex칚o:', status);
                if (err) {
                    console.error('仇 [REALTIME] Erro na subscri칞칚o:', err);
                }
                if (status === 'SUBSCRIBED') {
                    console.log('九 [REALTIME] Conectado com sucesso - sincroniza칞칚o ativa!');
                    // Toast removido para evitar polui칞칚o visual
                } else if (status === 'CHANNEL_ERROR') {
                    console.error('仇 [REALTIME] Erro no canal - verifique Realtime no Supabase');
                } else if (status === 'TIMED_OUT') {
                    console.error('仇 [REALTIME] Timeout na conex칚o');
                } else if (status === 'CLOSED') {
                    console.warn('丘멆잺 [REALTIME] Canal clients fechado');
                }
            });

        // Criar canal para escutar mudan칞as na tabela delivery_data (status de entrega)
        deliveryDataChannel = supabase
            .channel('delivery-data-realtime-channel')
            .on(
                'postgres_changes',
                {
                    event: 'UPDATE', // S칩 precisamos escutar UPDATE para status
                    schema: 'public',
                    table: 'delivery_data'
                },
                (payload) => {
                    console.log('游닍 [REALTIME-DELIVERY] ========================================');
                    console.log('游닍 [REALTIME-DELIVERY] STATUS DE ENTREGA ALTERADO!');
                    console.log('游닍 [REALTIME-DELIVERY] SPX TN:', payload.new?.spx_tn);
                    console.log('游닍 [REALTIME-DELIVERY] Dados novos:', JSON.stringify(payload.new));
                    console.log('游닍 [REALTIME-DELIVERY] Dados antigos:', JSON.stringify(payload.old));
                    console.log('游닍 [REALTIME-DELIVERY] ========================================');
                    handleDeliveryStatusChange(payload);
                }
            )
            .subscribe((status, err) => {
                console.log('游닍 [REALTIME-DELIVERY] Status da conex칚o:', status);
                if (err) {
                    console.error('仇 [REALTIME-DELIVERY] Erro na subscri칞칚o:', err);
                }
                if (status === 'SUBSCRIBED') {
                    console.log('九 [REALTIME-DELIVERY] Conectado - sincroniza칞칚o de status ativa!');
                } else if (status === 'CHANNEL_ERROR') {
                    console.error('仇 [REALTIME-DELIVERY] Erro no canal - verifique Realtime para delivery_data');
                }
            });

        console.log('游니 [REALTIME] Canais criados, aguardando conex칚o...');

    } catch (error) {
        console.error('仇 [REALTIME] Erro ao inicializar:', error);
    }
}

// Processar mudan칞as recebidas via Realtime
async function handleRealtimeChange(payload) {
    const { eventType, new: newRecord, old: oldRecord } = payload;

    switch (eventType) {
        case 'INSERT':
            console.log('游니 [REALTIME] Novo cliente adicionado:', newRecord);
            // Recarregar lista de clientes
            await loadClients();
            // Toast removido para evitar polui칞칚o visual
            break;

        case 'UPDATE':
            console.log('游니 [REALTIME] Cliente atualizado:', newRecord);
            // Atualizar marcador no mapa
            updateClientMarkerOnMap(newRecord);
            // Recarregar lista
            await loadClients();
            break;

        case 'DELETE':
            console.log('游니 [REALTIME] Cliente removido:', oldRecord);
            // Remover marcador do mapa
            removeClientMarkerFromMap(oldRecord.id);
            // Recarregar lista
            await loadClients();
            // Toast removido para evitar polui칞칚o visual
            break;
    }
}

// Processar mudan칞as de status de entrega (delivery_data)
async function handleDeliveryStatusChange(payload) {
    const { new: newRecord } = payload;

    // Verificar se temos dados novos
    if (!newRecord) return;

    const spxTn = newRecord.spx_tn;
    const newStatus = newRecord.status;

    console.log(`游닍 [REALTIME-DELIVERY] SPX TN: ${spxTn}`);
    console.log(`游닍 [REALTIME-DELIVERY] Novo status: ${newStatus}`);

    // Encontrar o cliente associado a este SPX TN
    const clientToUpdate = allClients.find(c => c.spx_tn === spxTn);

    // Recarregar marcadores de entrega (verdes/vermelhos) para refletir novo status
    if (typeof addDeliveryMarkers === 'function') {
        console.log('游닍 [REALTIME-DELIVERY] Recarregando marcadores de entrega...');
        await addDeliveryMarkers();
    }

    // Mostrar notifica칞칚o
    const statusText = newStatus === 'delivered' ? '九 Entregue' :
                      newStatus === 'not_delivered' ? '仇 N칚o Entregue' :
                      '游닍 Pendente';

    const clientName = clientToUpdate ?
        (clientToUpdate.name || clientToUpdate.address?.substring(0, 30) || spxTn) :
        spxTn;

    // Toast removido para evitar polui칞칚o visual - status 칠 atualizado silenciosamente
    console.log(`游닍 [REALTIME-DELIVERY] ${clientName}  ${statusText}`);
}

// Atualizar marcador espec칤fico no mapa
function updateClientMarkerOnMap(client) {
    if (!client || !clientMarkers) return;

    // Remover marcador antigo se existir
    if (clientMarkers[client.id]) {
        clientMarkers[client.id].map = null;
        delete clientMarkers[client.id];
    }

    // Recarregar todos os marcadores para atualizar o status
    // (mais simples e garante consist칡ncia)
    if (typeof showClientMarkers === 'function') {
        showClientMarkers();
    }
}

// Remover marcador do mapa por ID do cliente
function removeClientMarkerFromMap(clientId) {
    if (!clientMarkers) return;

    if (clientMarkers[clientId]) {
        clientMarkers[clientId].map = null;
        delete clientMarkers[clientId];
        console.log('游늸 Marcador removido do mapa:', clientId);
    }
}

// Renderizar lista de clientes
function renderClients(clients) {
    if (!clients || clients.length === 0) {
        clientsList.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon">游늶</div>
                <div class="empty-state-text">Nenhum cliente encontrado</div>
                <div class="empty-state-subtext">${searchInput.value ? 'Tente outra busca' : 'Adicione clientes para v칡-los aqui'}</div>
            </div>
        `;
        return;
    }

    const clientsHTML = clients.map(client => `
        <div class="client-card" data-client-id="${client.id}">
            <div class="client-card-header">
                <div class="client-name">
                    <span>游녻</span>
                    <span>${escapeHtml(client.name)}</span>
                </div>
                <div class="client-actions">
                    <button class="client-action-btn navigate-btn" data-client-id="${client.id}" title="Navegar at칠 o cliente">
                        游빐
                    </button>
                    <button class="client-action-btn edit-btn" data-client-id="${client.id}" title="Editar">
                        九勇
                    </button>
                    <button class="client-action-btn delete-btn" data-client-id="${client.id}" title="Excluir">
                        游딈勇
                    </button>
                </div>
            </div>
            ${client.phone ? `
                <div class="client-info phone-info">
                    <span class="client-info-icon">游</span>
                    <span>${escapeHtml(client.phone)}</span>
                    <div class="phone-actions">
                        <a href="tel:${client.phone.replace(/\D/g, '')}" class="phone-action-btn call-btn" title="Ligar" onclick="event.stopPropagation()">
                            <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M6.62 10.79c1.44 2.83 3.76 5.14 6.59 6.59l2.2-2.2c.27-.27.67-.36 1.02-.24 1.12.37 2.33.57 3.57.57.55 0 1 .45 1 1V20c0 .55-.45 1-1 1-9.39 0-17-7.61-17-17 0-.55.45-1 1-1h3.5c.55 0 1 .45 1 1 0 1.25.2 2.45.57 3.57.11.35.03.74-.25 1.02l-2.2 2.2z" fill="white"/>
                            </svg>
                        </a>
                        <a href="https://wa.me/55${client.phone.replace(/\D/g, '')}" target="_blank" class="phone-action-btn whatsapp-btn" title="WhatsApp" onclick="event.stopPropagation()">
                            <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M12.04 2c-5.46 0-9.91 4.45-9.91 9.91 0 1.75.46 3.45 1.32 4.95L2.05 22l5.25-1.38c1.45.79 3.08 1.21 4.74 1.21 5.46 0 9.91-4.45 9.91-9.91 0-2.65-1.03-5.14-2.9-7.01A9.816 9.816 0 0012.04 2m.01 1.67c2.2 0 4.26.86 5.82 2.42a8.225 8.225 0 012.41 5.83c0 4.54-3.7 8.23-8.24 8.23-1.48 0-2.93-.39-4.19-1.15l-.3-.17-3.12.82.83-3.04-.2-.32a8.188 8.188 0 01-1.26-4.38c.01-4.54 3.7-8.24 8.25-8.24M8.53 7.33c-.16 0-.43.06-.66.31-.22.25-.87.85-.87 2.07 0 1.22.89 2.39 1 2.56.14.17 1.76 2.67 4.25 3.73.59.27 1.05.42 1.41.53.59.19 1.13.16 1.56.1.48-.07 1.46-.6 1.67-1.18.21-.58.21-1.07.15-1.18-.07-.1-.23-.16-.48-.27-.25-.14-1.47-.74-1.69-.82-.23-.08-.37-.12-.56.12-.16.25-.64.81-.78.97-.15.17-.29.19-.53.07-.26-.13-1.06-.39-2-1.23-.74-.66-1.23-1.47-1.38-1.72-.14-.25-.02-.39.11-.5.11-.11.25-.29.37-.44.13-.14.17-.25.25-.41.08-.17.04-.31-.02-.43-.06-.11-.56-1.35-.76-1.84-.2-.48-.4-.42-.56-.43-.14 0-.3-.01-.47-.01z" fill="white"/>
                            </svg>
                        </a>
                    </div>
                </div>
            ` : ''}
            ${client.address ? `
                <div class="client-info">
                    <span class="client-info-icon">游늸</span>
                    <span>${escapeHtml(client.address.replace(/C칩digo QR:.*?\(/g, '(').replace(/BR\d+/g, '').trim())}</span>
                </div>
            ` : ''}
        </div>
    `).join('');

    clientsList.innerHTML = clientsHTML;

    // Adicionar event listeners aos cards
    document.querySelectorAll('.client-card').forEach(card => {
        card.addEventListener('click', (e) => {
            // N칚o abrir detalhes se clicou em um bot칚o de a칞칚o
            if (e.target.closest('.client-action-btn')) {
                return;
            }

            const clientId = card.getAttribute('data-client-id');
            const client = clients.find(c => c.id === clientId);
            if (client) {
                showClientDetails(client);
            }
        });
    });

    // Event listeners para bot칫es de navegar
    document.querySelectorAll('.navigate-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const clientId = btn.getAttribute('data-client-id');
            const client = clients.find(c => c.id === clientId);
            if (client) {
                // Buscar marker do cliente se existir
                const marker = clientMarkers[clientId] || null;
                navigateToClient(client, marker, null);
            }
        });
    });

    // Event listeners para bot칫es de editar
    document.querySelectorAll('.edit-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const clientId = btn.getAttribute('data-client-id');
            const client = clients.find(c => c.id === clientId);
            if (client) {
                editClient(client);
            }
        });
    });

    // Event listeners para bot칫es de excluir
    document.querySelectorAll('.delete-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const clientId = btn.getAttribute('data-client-id');
            const client = clients.find(c => c.id === clientId);
            if (client) {
                deleteClient(client);
            }
        });
    });

    // Event listeners para bot칫es de telefone - reset agressivo com class toggle
    document.querySelectorAll('.phone-action-btn').forEach(btn => {
        // Touchstart - preparar para reset
        btn.addEventListener('touchstart', function(e) {
            e.stopPropagation();
            this.setAttribute('data-touched', 'true');
        }, { passive: true });

        // Touch end - resetar com class toggle para for칞ar re-render
        btn.addEventListener('touchend', function(e) {
            e.stopPropagation();
            const element = this;

            // Reset imediato com requestAnimationFrame para for칞ar reflow
            requestAnimationFrame(() => {
                element.blur();

                // Remove e readiciona classe para for칞ar re-render
                element.classList.remove('btn-reset');
                void element.offsetWidth; // For칞a reflow
                element.classList.add('btn-reset');

                // Remove todos os estilos inline
                element.removeAttribute('style');

                // Remove atributo de touch
                element.removeAttribute('data-touched');
            });

            // Segundo reset ap칩s um delay
            setTimeout(() => {
                element.blur();
                element.removeAttribute('style');
                element.classList.remove('btn-reset');
                void element.offsetWidth;
                element.classList.add('btn-reset');
            }, 100);
        });

        // Click - reset similar
        btn.addEventListener('click', function(e) {
            const element = this;

            requestAnimationFrame(() => {
                element.blur();
                element.classList.remove('btn-reset');
                void element.offsetWidth;
                element.classList.add('btn-reset');
                element.removeAttribute('style');
            });

            setTimeout(() => {
                element.blur();
                element.removeAttribute('style');
            }, 150);
        });

        // Mouseout - limpar estados residuais
        btn.addEventListener('mouseout', function() {
            this.blur();
            this.removeAttribute('style');
        });
    });

    // Listener global para resetar quando volta do app externo
    window.removeEventListener('focus', resetPhoneButtonsFocus);
    window.addEventListener('focus', resetPhoneButtonsFocus);

    // Listener para quando a p치gina fica vis칤vel novamente
    document.removeEventListener('visibilitychange', resetPhoneButtonsFocus);
    document.addEventListener('visibilitychange', function() {
        if (!document.hidden) {
            resetPhoneButtonsFocus();
        }
    });
}

// Fun칞칚o para resetar foco dos bot칫es de telefone - vers칚o agressiva
function resetPhoneButtonsFocus() {
    requestAnimationFrame(() => {
        // Resetar TODOS os bot칫es de telefone
        document.querySelectorAll('.phone-action-btn').forEach(btn => {
            // Remove foco
            btn.blur();

            // Remove todos os estilos inline
            btn.removeAttribute('style');

            // Remove e readiciona classe para for칞ar re-render
            btn.classList.remove('btn-reset');
            void btn.offsetWidth; // For칞a reflow
            btn.classList.add('btn-reset');

            // Remove atributos residuais
            btn.removeAttribute('data-touched');
        });

        // Remover foco dos cards
        document.querySelectorAll('.client-card').forEach(card => {
            card.blur();
            card.style.outline = 'none';
        });

        // Criar input tempor치rio para roubar foco completamente
        const tempInput = document.createElement('input');
        tempInput.style.cssText = 'position:absolute;opacity:0;height:0;width:0;left:-9999px;pointer-events:none;';
        tempInput.setAttribute('tabindex', '-1');
        tempInput.setAttribute('aria-hidden', 'true');
        document.body.appendChild(tempInput);

        tempInput.focus();

        setTimeout(() => {
            tempInput.blur();
            if (document.body.contains(tempInput)) {
                document.body.removeChild(tempInput);
            }

            // Reset final dos bot칫es
            document.querySelectorAll('.phone-action-btn').forEach(btn => {
                btn.removeAttribute('style');
                btn.blur();
            });
        }, 50);
    });
}

// Atualizar contador de clientes
function updateClientCount(count) {
    clientCount.textContent = count;
}

// Mostrar detalhes do cliente e centralizar no mapa
function showClientDetails(client) {
    // Fechar sidebar
    closeSidebar();

    let targetPosition = null;
    let qrCodeMatch = null;

    // Prioridade 1: Usar coordenadas salvas no cliente (se dispon칤veis)
    if (client.latitude && client.longitude) {
        targetPosition = {
            lat: client.latitude,
            lng: client.longitude
        };
        console.log('Usando coordenadas do cliente:', targetPosition);
    } else {
        // Prioridade 2: Procurar nos dados da planilha pelo endere칞o do cliente
        for (const [qrCode, data] of Object.entries(addressDatabase)) {
            if (client.address && client.address.includes(data.address.split('\n')[0])) {
                targetPosition = {
                    lat: data.latitude,
                    lng: data.longitude
                };
                qrCodeMatch = qrCode;
                console.log('Coordenadas encontradas na planilha:', targetPosition);
                break;
            }
        }
    }

    if (targetPosition) {
        // Centralizar no endere칞o encontrado
        map.setCenter(targetPosition);
        map.setZoom(18);

        // Criar marcador tempor치rio para mostrar a localiza칞칚o do cliente
        const clientMarkerDiv = document.createElement('div');
        clientMarkerDiv.style.width = '40px';
        clientMarkerDiv.style.height = '40px';
        clientMarkerDiv.style.background = '#4285f4';
        clientMarkerDiv.style.border = '3px solid white';
        clientMarkerDiv.style.borderRadius = '50%';
        clientMarkerDiv.style.boxShadow = '0 2px 10px rgba(0,0,0,0.4)';
        clientMarkerDiv.style.display = 'flex';
        clientMarkerDiv.style.alignItems = 'center';
        clientMarkerDiv.style.justifyContent = 'center';
        clientMarkerDiv.style.fontSize = '20px';
        clientMarkerDiv.innerHTML = '游녻';

        let tempMarker;
        try {
            if (google.maps.marker && google.maps.marker.AdvancedMarkerElement) {
                tempMarker = new google.maps.marker.AdvancedMarkerElement({
                    map,
                    position: targetPosition,
                    content: clientMarkerDiv,
                    title: client.name
                });
            } else {
                tempMarker = new google.maps.Marker({
                    map,
                    position: targetPosition,
                    title: client.name,
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 12,
                        fillColor: '#4285f4',
                        fillOpacity: 1,
                        strokeColor: 'white',
                        strokeWeight: 3
                    },
                    label: {
                        text: '游녻',
                        color: 'white',
                        fontSize: '16px'
                    }
                });
            }

            // Remover marcador tempor치rio ap칩s 5 segundos
            setTimeout(() => {
                if (tempMarker.map !== undefined) {
                    tempMarker.map = null;
                } else if (tempMarker.setMap) {
                    tempMarker.setMap(null);
                }
            }, 5000);
        } catch (error) {
            console.warn('Erro ao criar marcador tempor치rio:', error);
        }

        // Destacar o marcador correspondente (apenas se estiver no modo de rota)
        if (qrCodeMatch && deliveryMarkers[qrCodeMatch]) {
            try {
                // Verificar se 칠 AdvancedMarkerElement ou Marker cl치ssico
                const marker = deliveryMarkers[qrCodeMatch];

                if (marker.content && marker.content.style) {
                    // AdvancedMarkerElement
                    const markerElement = marker.content;
                    markerElement.style.transform = 'scale(1.5)';
                    markerElement.style.background = '#fbbc04'; // Amarelo para destaque

                    setTimeout(() => {
                        markerElement.style.transform = 'scale(1)';
                        markerElement.style.background = '#ea4335'; // Voltar ao vermelho
                    }, 2000);
                } else if (marker.setIcon) {
                    // Marker cl치ssico - trocar cor temporariamente
                    const originalIcon = marker.getIcon();
                    marker.setIcon({
                        ...originalIcon,
                        fillColor: '#fbbc04',
                        scale: 12
                    });

                    setTimeout(() => {
                        marker.setIcon(originalIcon);
                    }, 2000);
                }
            } catch (error) {
                console.warn('Erro ao destacar marcador:', error);
            }
        }

        showToast(
            `游늸 ${client.name}`,
            client.address,
            'success',
            4000
        );
    } else {
        // Se n칚o encontrar coordenadas, apenas mostrar informa칞칫es
        showToast(
            client.name,
            `游 ${client.phone || 'Sem telefone'}\n游늸 ${client.address}`,
            'info',
            5000
        );
    }
}

// ===========================
// EDITAR CLIENTE
// ===========================

let isEditMode = false;
let editingClientId = null;

async function editClient(client) {
    isEditMode = true;
    editingClientId = client.id;

    // Abrir modal (sem fechar sidebar)
    modal.classList.add('active');
    document.body.style.overflow = 'hidden';

    // Preencher campos com dados atuais
    inputName.value = client.name || '';
    inputPhone.value = client.phone || '';

    // Mostrar endere칞o
    scannedAddress = client.address || '';
    addressText.textContent = scannedAddress;
    if (scannedAddress) {
        addressDisplay.classList.add('active');
    }

    // Salvar coordenadas existentes
    if (client.latitude && client.longitude) {
        scannedLatLng = {
            latitude: client.latitude,
            longitude: client.longitude
        };
    }

    // Trocar texto do bot칚o
    btnSave.textContent = 'Atualizar Cliente';

    // Modificar o t칤tulo do scanner
    const scannerTitle = document.querySelector('.scanner-title span');
    if (scannerTitle) {
        scannerTitle.textContent = '九勇 Editando Cliente';
    }

    // Iniciar c칙mera para o scanner QR Code
    try {
        await startCamera();
    } catch (error) {
        console.error('Erro ao abrir c칙mera no modo de edi칞칚o:', error);

        // Mensagem de erro para o usu치rio
        let errorMessage = 'Verifique as permiss칫es do navegador';

        if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
            errorMessage = 'Permiss칚o negada. Permita o acesso  c칙mera nas configura칞칫es do navegador.';
        } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
            errorMessage = 'Nenhuma c칙mera encontrada no dispositivo.';
        } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
            errorMessage = 'C칙mera j치 est치 em uso por outro aplicativo.';
        }

        showToast(
            'Erro ao abrir c칙mera',
            errorMessage,
            'error',
            5000
        );
    }

    // Focar no nome
    setTimeout(() => {
        inputName.focus();
        inputName.select();
    }, 300);
}

// ===========================
// EXCLUIR CLIENTE
// ===========================

function deleteClient(client) {
    // Criar modal de confirma칞칚o customizado
    const confirmModal = document.createElement('div');
    confirmModal.className = 'modal-overlay';
    confirmModal.style.zIndex = '10004';
    confirmModal.innerHTML = `
        <div class="modal-container" style="max-width: 400px;">
            <div class="modal-body" style="padding: 24px;">
                <h3 style="margin: 0 0 16px 0; color: #ea4335; font-size: 20px;">
                    游딈勇 Confirmar Exclus칚o
                </h3>
                <p style="margin: 0 0 8px 0; color: #333; font-size: 16px;">
                    Deseja realmente excluir este cliente?
                </p>
                <div style="background: #f5f5f5; padding: 12px; border-radius: 8px; margin-top: 12px;">
                    <p style="margin: 0 0 4px 0; font-weight: 600; color: #333;">
                        ${escapeHtml(client.name)}
                    </p>
                    <p style="margin: 0; font-size: 14px; color: #666;">
                        ${client.phone ? '游 ' + escapeHtml(client.phone) : ''}
                    </p>
                </div>
                <p style="margin: 16px 0 0 0; font-size: 13px; color: #999;">
                    Esta a칞칚o n칚o pode ser desfeita.
                </p>
            </div>
            <div class="form-footer">
                <button type="button" class="btn btn-secondary" id="btn-confirm-cancel">
                    Cancelar
                </button>
                <button type="button" class="btn btn-primary" id="btn-confirm-delete" style="background: #ea4335;">
                    Excluir
                </button>
            </div>
        </div>
    `;

    document.body.appendChild(confirmModal);

    // Animar entrada
    setTimeout(() => {
        confirmModal.classList.add('active');
    }, 10);

    // Bot칚o Cancelar
    const btnCancel = confirmModal.querySelector('#btn-confirm-cancel');
    btnCancel.addEventListener('click', () => {
        confirmModal.classList.remove('active');
        setTimeout(() => {
            confirmModal.remove();
        }, 300);
    });

    // Bot칚o Excluir
    const btnDelete = confirmModal.querySelector('#btn-confirm-delete');
    btnDelete.addEventListener('click', async () => {
        btnDelete.classList.add('loading');
        btnDelete.disabled = true;
        btnDelete.textContent = 'Excluindo...';

        try {
            // Excluir do Supabase
            const { error } = await supabase
                .from('clients')
                .delete()
                .eq('id', client.id);

            if (error) throw error;

            console.log('Cliente exclu칤do:', client.id);

            showToast(
                'Cliente exclu칤do!',
                `${client.name} foi removido com sucesso`,
                'success',
                3000
            );

            // Fechar modal de confirma칞칚o
            confirmModal.classList.remove('active');
            setTimeout(() => {
                confirmModal.remove();
            }, 300);

            // Atualizar lista de clientes
            await loadClients();

        } catch (error) {
            console.error('Erro ao excluir cliente:', error);
            showToast(
                'Erro ao excluir',
                error.message || 'N칚o foi poss칤vel excluir o cliente',
                'error',
                5000
            );
            btnDelete.classList.remove('loading');
            btnDelete.disabled = false;
            btnDelete.textContent = 'Excluir';
        }
    });

    // Fechar ao clicar fora
    confirmModal.addEventListener('click', (e) => {
        if (e.target === confirmModal) {
            confirmModal.classList.remove('active');
            setTimeout(() => {
                confirmModal.remove();
            }, 300);
        }
    });
}

// ===========================
// NAVEGAR AT칄 O CLIENTE
// ===========================

async function navigateToClient(client, marker = null, infoWindow = null) {
    // Fechar sidebar
    closeSidebar();

    // Verificar se temos coordenadas do destino
    let destination = null;

    if (client.latitude && client.longitude) {
        destination = { lat: client.latitude, lng: client.longitude };
    } else {
        // Tentar encontrar no addressDatabase pelo endere칞o
        const qrCodeMatch = Object.keys(addressDatabase).find(qr =>
            client.address && client.address.includes(qr)
        );

        if (qrCodeMatch && addressDatabase[qrCodeMatch]) {
            destination = {
                lat: addressDatabase[qrCodeMatch].latitude,
                lng: addressDatabase[qrCodeMatch].longitude
            };
        }
    }

    if (!destination) {
        showToast(
            '丘멆잺 Coordenadas n칚o encontradas',
            'Este cliente n칚o possui coordenadas GPS salvas',
            'error',
            4000
        );
        return;
    }

    // Obter localiza칞칚o atual do usu치rio
    let userPosition = null;
    if (userLocationMarker) {
        if (userLocationMarker.position) {
            userPosition = userLocationMarker.position;
        } else if (userLocationMarker.getPosition) {
            userPosition = userLocationMarker.getPosition();
        }
    }

    if (!userPosition) {
        showToast(
            '丘멆잺 Localiza칞칚o n칚o dispon칤vel',
            'Ative a localiza칞칚o GPS para navegar',
            'error',
            4000
        );
        return;
    }

    showToast(
        '游빐 Calculando rota...',
        `Tra칞ando caminho at칠 ${client.name}`,
        'info',
        3000
    );

    try {
        // Usar Directions API para rota ponto-a-ponto
        const directionsService = new google.maps.DirectionsService();

        const request = {
            origin: userPosition,
            destination: destination,
            travelMode: google.maps.TravelMode.DRIVING,
            optimizeWaypoints: false,
            language: 'pt-BR',
            region: 'BR'
        };

        const result = await directionsService.route(request);

        if (result.status === 'OK') {
            // Limpar rotas antigas
            if (window.routePolylines && window.routePolylines.length > 0) {
                window.routePolylines.forEach(polyline => {
                    if (polyline.setMap) {
                        polyline.setMap(null);
                    }
                });
                window.routePolylines = [];
            }

            // Desenhar nova rota
            const route = result.routes[0];
            const leg = route.legs[0];

            // Criar polyline para a rota
            const polyline = new google.maps.Polyline({
                path: route.overview_path,
                geodesic: true,
                strokeColor: '#4285f4',
                strokeOpacity: 0.8,
                strokeWeight: 5,
                map: map
            });

            window.routePolylines = [polyline];

            // Ajustar mapa para mostrar toda a rota
            const bounds = new google.maps.LatLngBounds();
            bounds.extend(userPosition);
            bounds.extend(destination);
            map.fitBounds(bounds);

            // Formatar dist칙ncia e dura칞칚o
            const distance = leg.distance.text;
            const duration = leg.duration.text;

            showToast(
                `游꿢 Rota para ${client.name}`,
                `游늺 Dist칙ncia: ${distance}\n낌勇 Tempo estimado: ${duration}`,
                'success',
                5000
            );

            console.log('九 Rota calculada:', {
                distance: leg.distance,
                duration: leg.duration,
                steps: leg.steps.length
            });

            // Iniciar modo de navega칞칚o em tempo real
            startNavigationMode(destination, client.name, marker, infoWindow, client);

        } else {
            throw new Error(`Directions API retornou status: ${result.status}`);
        }

    } catch (error) {
        console.error('Erro ao calcular rota:', error);
        showToast(
            '仇 Erro ao calcular rota',
            error.message || 'N칚o foi poss칤vel tra칞ar o caminho',
            'error',
            5000
        );
    }
}

// Fun칞칚o helper para escape HTML
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Carregar clientes ao inicializar e verificar se h치 dados da planilha
setTimeout(async () => {
    loadClients();

    // Inicializar sincroniza칞칚o em tempo real entre navegadores
    initRealtimeSync();

    // Verificar se h치 dados da planilha salvos no Supabase
    try {
        const { data, error } = await supabase
            .from('delivery_data')
            .select('id')
            .limit(1);

        if (!error && data && data.length > 0) {
            // Se h치 dados da planilha, mudar bot칚o para modo "Limpar"
            setButtonToClearMode();
            console.log('游늵 Planilha detectada no banco de dados');
        } else {
            // Sem dados, manter bot칚o em modo "Upload"
            setButtonToUploadMode();
            console.log('游늶 Nenhuma planilha no banco de dados');
        }
    } catch (error) {
        console.error('Erro ao verificar dados da planilha:', error);
    }
}, 2000);

// ===========================
// SISTEMA DE ROTAS DE ENTREGA
// ===========================

const btnToggleRoute = document.getElementById('btnToggleRoute');

btnToggleRoute.addEventListener('click', () => {
    if (!routeMode) {
        // Ativar modo de rota
        activateRouteMode();
    } else {
        // Desativar modo de rota
        deactivateRouteMode();
    }
});

// Bot칚o de limpar rotas e marcadores
const btnClearRoute = document.getElementById('btnClearRoute');
btnClearRoute.addEventListener('click', () => {
    clearAllRoutesAndMarkers();
});

async function activateRouteMode() {
    routeMode = true;
    btnToggleRoute.classList.add('active');

    // Esconder bot칚o de planejar rota e mostrar bot칚o de limpar
    btnToggleRoute.style.display = 'none';
    document.getElementById('btnClearRoute').style.display = 'flex';

    // Reativar DirectionsRenderer se necess치rio
    if (directionsRenderer && !directionsRenderer.getMap()) {
        console.log('游댯 Reativando DirectionsRenderer...');
        directionsRenderer.setMap(map);
    }

    // Obter posi칞칚o atual do usu치rio
    let currentPosition;
    if (userLocationMarker) {
        if (userLocationMarker.position) {
            currentPosition = userLocationMarker.position;
        } else if (userLocationMarker.getPosition) {
            currentPosition = userLocationMarker.getPosition();
        }
    }

    if (!currentPosition) {
        showToast(
            'Localiza칞칚o n칚o dispon칤vel',
            'Aguarde obter sua posi칞칚o GPS para calcular rotas',
            'warning',
            4000
        );
        deactivateRouteMode();
        return;
    }

    // NOVO: Adicionar marcadores do Supabase SOMENTE quando clicar
    await addDeliveryMarkers();

    // Rota otimizada desabilitada (Fleet Routing API quota esgotada)
    // await calculateOptimizedRouteFromDB(currentPosition);
}

function deactivateRouteMode() {
    routeMode = false;
    btnToggleRoute.classList.remove('active');

    // Mostrar bot칚o de planejar rota e esconder bot칚o de limpar
    btnToggleRoute.style.display = 'flex';
    document.getElementById('btnClearRoute').style.display = 'none';

    // Limpar rota do mapa COMPLETAMENTE
    if (directionsRenderer) {
        directionsRenderer.setDirections({routes: []});
        directionsRenderer.setMap(null);
    }

    // Limpar polylines (rotas em segmentos)
    if (window.routePolylines) {
        window.routePolylines.forEach(polyline => {
            polyline.setMap(null);
        });
        window.routePolylines = [];
    }

    // Remover marcadores de entrega
    Object.values(deliveryMarkers).forEach(marker => {
        if (marker.map) {
            marker.map = null; // Remove do mapa
        } else if (marker.setMap) {
            marker.setMap(null);
        }
    });

    showToast(
        'Modo de rota desativado',
        'Marcadores de entrega ocultados',
        'info',
        2000
    );
}

// Nova fun칞칚o: Limpar TUDO (marcadores + rotas + cluster)
async function clearAllRoutesAndMarkers() {
    console.log('游딈勇 ========================================');
    console.log('游딈勇 LIMPANDO ROTAS E MARCADORES DO MAPA...');
    console.log('游딈勇 (Dados da planilha ser칚o mantidos no Supabase)');
    console.log('游딈勇 ========================================');

    // Desativar modo de rota se estiver ativo
    if (routeMode) {
        console.log('游댮 Desativando modo de rota...');
        routeMode = false;
        btnToggleRoute.classList.remove('active');
    }

    // Esconder bot칚o de limpar e mostrar bot칚o de planejar rota novamente
    document.getElementById('btnClearRoute').style.display = 'none';
    btnToggleRoute.style.display = 'flex';

    // 1. Limpar DirectionsRenderer COMPLETAMENTE
    if (directionsRenderer) {
        console.log('游딈勇 Limpando DirectionsRenderer...');
        try {
            directionsRenderer.setDirections({routes: []});
            directionsRenderer.setMap(null);
            directionsRenderer.setPanel(null);
            // Recriar DirectionsRenderer limpo
            directionsRenderer = new google.maps.DirectionsRenderer({
                map: null, // Inicialmente sem mapa
                suppressMarkers: false,
                polylineOptions: {
                    strokeColor: '#4285f4',
                    strokeWeight: 5,
                    strokeOpacity: 0.7
                }
            });
        } catch (e) {
            console.warn('Erro ao limpar DirectionsRenderer:', e);
        }
    }

    // 2. Limpar TODAS as polylines (array + verifica칞칚o extra)
    let polylinesRemoved = 0;

    if (window.routePolylines && window.routePolylines.length > 0) {
        console.log(`游딈勇 Removendo ${window.routePolylines.length} polylines do array...`);
        window.routePolylines.forEach(polyline => {
            try {
                if (polyline && polyline.setMap) {
                    polyline.setMap(null);
                    polylinesRemoved++;
                }
            } catch (e) {
                console.warn('Erro ao remover polyline:', e);
            }
        });
        window.routePolylines = [];
    } else {
        console.log('游딈勇 Nenhuma polyline encontrada no array');
    }

    console.log(`九 ${polylinesRemoved} polylines removidas`);

    // 3. Remover TODOS os marcadores de entrega
    const markerCount = Object.keys(deliveryMarkers).length;
    if (markerCount > 0) {
        console.log(`游딈勇 Removendo ${markerCount} marcadores de entrega...`);
        Object.values(deliveryMarkers).forEach(marker => {
            try {
                if (marker.map !== undefined) {
                    marker.map = null; // AdvancedMarkerElement
                } else if (marker.setMap) {
                    marker.setMap(null); // Marker cl치ssico
                }
            } catch (e) {
                console.warn('Erro ao remover marcador:', e);
            }
        });
    }

    // 4. RESETAR completamente o objeto de marcadores
    deliveryMarkers = {};

    // 丘멆잺 N츾O voltar bot칚o de upload para modo padr칚o
    // Os dados da planilha continuam no Supabase, apenas limpamos os marcadores visuais

    console.log('九 ========================================');
    console.log('九 MARCADORES E ROTAS REMOVIDOS DO MAPA!');
    console.log('九 Dados da planilha mantidos no Supabase');
    console.log('九 ========================================');

    showToast(
        '游딈勇 Marcadores limpos!',
        'Clique em "Planejar rota" para ver novamente',
        'success',
        3000
    );
}

async function calculateOptimizedRoute(origin) {
    // Marcadores j치 foram adicionados em activateRouteMode()
    // Removido: addDeliveryMarkers();

    showToast(
        'Calculando rota otimizada...',
        'Usando Fleet Routing API para todos os 73 endere칞os',
        'info',
        4000
    );

    // Verificar se Project ID foi configurado
    if (GOOGLE_CLOUD_PROJECT_ID === "SEU_PROJECT_ID_AQUI") {
        showToast(
            '丘멆잺 Configura칞칚o necess치ria',
            'Configure o GOOGLE_CLOUD_PROJECT_ID no c칩digo (linha 1799)',
            'error',
            8000
        );
        deactivateRouteMode();
        return;
    }

    // Obter todos os pontos de entrega
    let deliveryPoints = Object.values(addressDatabase).map(data => ({
        location: {lat: data.latitude, lng: data.longitude},
        address: data.address
    }));

    console.log(`Total de endere칞os na planilha: ${deliveryPoints.length}`);

    // Remover pontos duplicados (mesmas coordenadas)
    const uniquePoints = [];
    const seenCoords = new Set();

    deliveryPoints.forEach(point => {
        const coordKey = `${point.location.lat.toFixed(6)},${point.location.lng.toFixed(6)}`;
        if (!seenCoords.has(coordKey)) {
            seenCoords.add(coordKey);
            uniquePoints.push(point);
        }
    });

    console.log(`Endere칞os 칰nicos (sem duplicatas): ${uniquePoints.length}`);

    if (uniquePoints.length === 0) {
        showToast(
            'Nenhuma entrega encontrada',
            'N칚o h치 endere칞os cadastrados para criar uma rota',
            'warning',
            4000
        );
        deactivateRouteMode();
        return;
    }

    // Usar Fleet Routing API para TODOS os pontos
    try {
        await calculateFleetRoute(origin, uniquePoints);
    } catch (error) {
        console.error('仇 ERRO ao calcular rota com Fleet API:', error);
        console.error('Mensagem do erro:', error.message);

        // Fallback para Directions API com limite de 23 pontos
        console.log('丘멆잺 USANDO FALLBACK: Directions API (limite de 23 pontos)...');

        showToast(
            '丘멆잺 Usando modo fallback',
            'Fleet API falhou. Calculando com 23 pontos mais pr칩ximos.',
            'warning',
            6000
        );

        await calculateDirectionsRoute(origin, uniquePoints);
    }
}

// Nova fun칞칚o: Calcular rota usando dados do Supabase
async function calculateOptimizedRouteFromDB(origin) {
    showToast(
        'Calculando rota otimizada...',
        'Buscando dados da planilha de entregas',
        'info',
        4000
    );

    try {
        // Buscar todos os dados da planilha do Supabase
        const { data: deliveryData, error } = await supabase
            .from('delivery_data')
            .select('*')
            .order('sequence', { ascending: true });

        if (error) throw error;

        if (!deliveryData || deliveryData.length === 0) {
            showToast(
                'Nenhuma entrega encontrada',
                'Fa칞a upload de uma planilha para planejar rotas',
                'warning',
                4000
            );
            deactivateRouteMode();
            return;
        }

        // Criar array de pontos de entrega com endere칞os formatados
        let deliveryPoints = deliveryData
            .filter(delivery => delivery.latitude && delivery.longitude)
            .map(delivery => {
                let address = delivery.destination_address || '';
                if (delivery.bairro) address += `, ${delivery.bairro}`;
                if (delivery.city) address += `, ${delivery.city}`;

                return {
                    location: { lat: delivery.latitude, lng: delivery.longitude },
                    address: address,
                    spx_tn: delivery.spx_tn,
                    sequence: delivery.sequence
                };
            });

        console.log(`Total de entregas na planilha: ${deliveryPoints.length}`);

        // Remover pontos duplicados (mesmas coordenadas)
        const uniquePoints = [];
        const seenCoords = new Set();

        deliveryPoints.forEach(point => {
            const coordKey = `${point.location.lat.toFixed(6)},${point.location.lng.toFixed(6)}`;
            if (!seenCoords.has(coordKey)) {
                seenCoords.add(coordKey);
                uniquePoints.push(point);
            }
        });

        console.log(`Endere칞os 칰nicos (sem duplicatas): ${uniquePoints.length}`);

        if (uniquePoints.length === 0) {
            showToast(
                'Nenhuma entrega encontrada',
                'N칚o h치 clientes com coordenadas v치lidas',
                'warning',
                4000
            );
            deactivateRouteMode();
            return;
        }

        // Verificar configura칞칚o do Project ID
        if (typeof GOOGLE_CLOUD_PROJECT_ID !== 'undefined' && GOOGLE_CLOUD_PROJECT_ID !== "SEU_PROJECT_ID_AQUI") {
            // Usar Fleet Routing API se configurado
            await calculateFleetRoute(origin, uniquePoints);
        } else {
            // Fallback: usar Directions API (limitado a 23 pontos)
            if (uniquePoints.length > 23) {
                showToast(
                    '丘멆잺 Limite de endere칞os',
                    `Voc칡 tem ${uniquePoints.length} entregas. Configure o Fleet Routing API para otimizar todas.`,
                    'warning',
                    6000
                );
                // Usar apenas os 23 primeiros
                const limitedPoints = uniquePoints.slice(0, 23);
                await calculateDirectionsRoute(origin, limitedPoints);
            } else {
                await calculateDirectionsRoute(origin, uniquePoints);
            }
        }

    } catch (error) {
        console.error('Erro ao calcular rota:', error);
        showToast(
            'Erro ao calcular rota',
            error.message || 'N칚o foi poss칤vel processar os dados',
            'error',
            5000
        );
        deactivateRouteMode();
    }
}

// Nova fun칞칚o: Fleet Routing API via Backend (suporta todos os pontos)
async function calculateFleetRoute(origin, deliveryPoints) {
    console.log(`游 Chamando backend para otimizar ${deliveryPoints.length} pontos`);
    console.log(`Project ID: ${GOOGLE_CLOUD_PROJECT_ID}`);

    // Chamar API serverless do backend (Cloudflare Pages Function)
    const backendUrl = '/api/optimize-route';

    // Transformar deliveryPoints para o formato esperado pelo backend
    const formattedPoints = deliveryPoints.map(point => ({
        lat: point.location.lat,
        lng: point.location.lng,
        address: point.address || ''
    }));

    const payload = {
        origin: origin,
        deliveryPoints: formattedPoints,
        projectId: GOOGLE_CLOUD_PROJECT_ID
    };

    console.log('游닋 Enviando requisi칞칚o para backend...');
    console.log('URL:', backendUrl);
    console.log(`Pontos: ${deliveryPoints.length}`);

    const response = await fetch(backendUrl, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
    });

    console.log(`游닌 Resposta backend: Status ${response.status}`);

    if (!response.ok) {
        const errorData = await response.json();
        console.error('仇 ERRO do Backend:');
        console.error('Status:', response.status);
        console.error('Erro completo:', JSON.stringify(errorData, null, 2));

        // Logar detalhes espec칤ficos se existirem
        if (errorData.details) {
            console.error('Detalhes do Google:', errorData.details);
        }
        if (errorData.requestModel) {
            console.error('Modelo enviado:', JSON.stringify(errorData.requestModel, null, 2));
        }

        showToast(
            '仇 Erro no Backend',
            errorData.message || 'N칚o foi poss칤vel calcular a rota',
            'error',
            10000
        );

        throw new Error(`Backend falhou: ${response.status} - ${errorData.message}`);
    }

    const data = await response.json();

    if (!data.success || !data.result) {
        console.error('仇 Resposta inv치lida do backend:', data);
        throw new Error('Resposta inv치lida do backend');
    }

    console.log('九 Fleet Routing result:', data.result);
    console.log(`Rotas retornadas: ${data.result.routes?.length || 0}`);

    // Renderizar rota otimizada no mapa (passar deliveryPoints originais para mapear shipmentIndex)
    renderFleetRoute(data.result, origin, deliveryPoints);
}

// Renderizar resultado da Fleet Routing API
async function renderFleetRoute(fleetResult, origin, deliveryPoints) {
    const route = fleetResult.routes[0];

    if (!route || !route.visits) {
        showToast(
            'Erro ao processar rota',
            'N칚o foi poss칤vel obter rota otimizada',
            'error',
            5000
        );
        deactivateRouteMode();
        return;
    }

    // Criar lista de pontos otimizados (origem + visitas + volta  origem)
    const allPoints = [origin];

    console.log(`游늸 Processando ${route.visits.length} visitas na ordem otimizada...`);

    route.visits.forEach((visit, index) => {
        // A Fleet API retorna apenas o shipmentIndex, n칚o as coordenadas
        // Precisamos buscar as coordenadas nos deliveryPoints originais
        let shipmentIndex = visit.shipmentIndex;

        // Fallback: se shipmentIndex n칚o existe, extrair do shipmentLabel
        if (shipmentIndex === undefined && visit.shipmentLabel) {
            // shipmentLabel 칠 "Entrega N" -> extrair N e converter para 칤ndice (N-1)
            const match = visit.shipmentLabel.match(/Entrega (\d+)/);
            if (match) {
                shipmentIndex = parseInt(match[1]) - 1; // Label come칞a em 1, 칤ndice em 0
                console.log(`游댃 Usando label para obter 칤ndice: ${visit.shipmentLabel} -> 칤ndice ${shipmentIndex}`);
            }
        }

        if (shipmentIndex !== undefined && deliveryPoints[shipmentIndex]) {
            const point = deliveryPoints[shipmentIndex].location;
            allPoints.push({
                lat: point.lat,
                lng: point.lng
            });
            console.log(`九 Visita ${index + 1}: Entrega #${shipmentIndex + 1} - ${visit.shipmentLabel}`);
        } else {
            console.warn(`丘멆잺 Visita ${index} sem shipmentIndex v치lido:`, visit);
        }
    });

    // Adicionar retorno  origem
    allPoints.push(origin);

    console.log(`Rota otimizada com ${route.visits.length} pontos de entrega`);
    console.log(`Total de pontos na rota: ${allPoints.length} (incluindo origem e retorno)`);

    // Desenhar a rota DIRETAMENTE usando m칰ltiplas requisi칞칫es  Directions API
    // Dividir em segmentos de at칠 25 pontos cada
    await drawRouteInSegments(allPoints, route.visits.length);
}

// Desenhar rota em m칰ltiplos segmentos (para mais de 25 pontos)
async function drawRouteInSegments(allPoints, totalDeliveries) {
    console.log(`游댯 Desenhando rota com ${allPoints.length} pontos totais`);

    // PASSO 1: Limpar TODAS as rotas anteriores COMPLETAMENTE
    if (directionsRenderer) {
        directionsRenderer.setMap(null);
    }

    // PASSO 2: Limpar polylines antigas se existirem
    if (window.routePolylines && window.routePolylines.length > 0) {
        console.log(`游딈勇 Removendo ${window.routePolylines.length} polylines antigas antes de desenhar...`);
        window.routePolylines.forEach(polyline => {
            try {
                polyline.setMap(null);
            } catch (e) {
                console.warn('Erro ao remover polyline antiga:', e);
            }
        });
    }

    // PASSO 3: Resetar array de polylines
    window.routePolylines = [];

    // Dividir pontos em segmentos de at칠 25 (origem + 23 waypoints + destino)
    const segments = [];
    const maxWaypoints = 23;

    for (let i = 0; i < allPoints.length - 1; i += maxWaypoints + 1) {
        const segmentStart = i;
        const segmentEnd = Math.min(i + maxWaypoints + 1, allPoints.length - 1);

        const origin = allPoints[segmentStart];
        const destination = allPoints[segmentEnd];
        const waypoints = [];

        for (let j = segmentStart + 1; j < segmentEnd; j++) {
            waypoints.push({
                location: allPoints[j],
                stopover: true
            });
        }

        segments.push({ origin, destination, waypoints });
    }

    console.log(`Rota dividida em ${segments.length} segmento(s)`);

    // Desenhar todos os segmentos
    const polylines = [];
    const bounds = new google.maps.LatLngBounds();
    let totalDistance = 0;
    let totalDuration = 0;

    for (let i = 0; i < segments.length; i++) {
        const segment = segments[i];

        try {
            const result = await new Promise((resolve, reject) => {
                directionsService.route({
                    origin: segment.origin,
                    destination: segment.destination,
                    waypoints: segment.waypoints,
                    optimizeWaypoints: false, // J츼 otimizado pela Fleet API
                    travelMode: google.maps.TravelMode.DRIVING
                }, (result, status) => {
                    if (status === 'OK') {
                        resolve(result);
                    } else {
                        reject(new Error(`Segment ${i + 1} failed: ${status}`));
                    }
                });
            });

            // Calcular dist칙ncia e tempo
            result.routes[0].legs.forEach(leg => {
                totalDistance += leg.distance.value;
                totalDuration += leg.duration.value;
            });

            // Criar polyline para este segmento
            const path = result.routes[0].overview_path;
            const polyline = new google.maps.Polyline({
                path: path,
                strokeColor: '#4285f4',
                strokeWeight: 5,
                strokeOpacity: 0.7,
                map: map
            });

            polylines.push(polyline);

            // Expandir bounds
            path.forEach(point => bounds.extend(point));

            console.log(`Segmento ${i + 1}/${segments.length} desenhado: ${segment.waypoints.length + 2} pontos`);

        } catch (error) {
            console.error(`Erro no segmento ${i + 1}:`, error);
        }

        // Pequeno delay entre requisi칞칫es para evitar rate limit
        if (i < segments.length - 1) {
            await new Promise(resolve => setTimeout(resolve, 300));
        }
    }

    // Armazenar polylines para limpeza posterior
    window.routePolylines = polylines;
    console.log(`九 ${polylines.length} polylines armazenadas para limpeza futura`);

    // Ajustar zoom para mostrar toda a rota com padding
    if (!bounds.isEmpty()) {
        map.fitBounds(bounds, {
            padding: 100 // Margem de 100px ao redor da rota
        });
        console.log('游딬勇 Mapa ajustado para mostrar toda a rota otimizada');
    }

    // Mostrar estat칤sticas
    const distanceKm = (totalDistance / 1000).toFixed(1);
    const durationMin = Math.round(totalDuration / 60);

    showToast(
        '九 Rota otimizada completa!',
        `${totalDeliveries} entregas  ${distanceKm} km  ${durationMin} min`,
        'success',
        10000
    );

    console.log(`九 Rota completa: ${totalDeliveries} entregas, ${distanceKm}km, ${durationMin}min`);
}

// Fallback: Directions API (at칠 23 pontos)
async function calculateDirectionsRoute(origin, deliveryPoints) {
    console.log(`Usando Directions API (fallback) com limite de 23 pontos`);

    const nearestPoints = deliveryPoints
        .map(point => ({
            ...point,
            distance: google.maps.geometry.spherical.computeDistanceBetween(
                new google.maps.LatLng(origin.lat, origin.lng),
                new google.maps.LatLng(point.location.lat, point.location.lng)
            )
        }))
        .sort((a, b) => a.distance - b.distance)
        .slice(0, 23);

    const waypoints = nearestPoints.slice(0, -1).map(point => ({
        location: point.location,
        stopover: true
    }));

    const destination = nearestPoints[nearestPoints.length - 1].location;

    const request = {
        origin: origin,
        destination: destination,
        waypoints: waypoints,
        optimizeWaypoints: true,
        travelMode: google.maps.TravelMode.DRIVING
    };

    directionsService.route(request, (result, status) => {
        if (status === 'OK') {
            directionsRenderer.setDirections(result);

            let totalDistance = 0;
            let totalDuration = 0;

            result.routes[0].legs.forEach(leg => {
                totalDistance += leg.distance.value;
                totalDuration += leg.duration.value;
            });

            const distanceKm = (totalDistance / 1000).toFixed(1);
            const durationMin = Math.round(totalDuration / 60);
            const totalPoints = waypoints.length + 2;

            showToast(
                '九 Rota calculada (Directions API)!',
                `${totalPoints} pontos de entrega  ${distanceKm} km  ${durationMin} min`,
                'success',
                8000
            );

            const bounds = new google.maps.LatLngBounds();
            result.routes[0].overview_path.forEach(point => bounds.extend(point));
            map.fitBounds(bounds);
        } else {
            console.error('Erro ao calcular rota:', status);
            showToast('Erro ao calcular rota', 'Tente novamente', 'error', 5000);
            deactivateRouteMode();
        }
    });
}

// ===========================
// SCANNER DE PACOTES
// ===========================

const modalScanPackage = document.getElementById('modal-scan-package');
const btnScanPackage = document.getElementById('btn-scan-package');
const btnModalScanClose = document.getElementById('modal-scan-close');
const btnPackageClose = document.getElementById('btn-package-close');
const btnPackageStopCamera = document.getElementById('btn-package-stop-camera');
const btnPackageSwitchCamera = document.getElementById('btn-package-switch-camera');
const qrPackageCameraContainer = document.getElementById('qr-package-camera-container');
const qrPackageVideo = document.getElementById('qr-package-video');
const qrPackageCanvas = document.getElementById('qr-package-canvas');
const qrPackageStatus = document.getElementById('qr-package-status');
const scanResult = document.getElementById('scan-result');
const scanResultText = document.getElementById('scan-result-text');

let packageVideoStream = null;
let packageScanningInterval = null;
let packageCurrentFacingMode = 'environment';
let packageLastScannedCode = null;

// Abrir modal de scanner de pacotes
async function openPackageScanner() {
    modalScanPackage.classList.add('active');
    document.body.style.overflow = 'hidden';

    // Resetar resultado anterior
    scanResult.classList.remove('active');
    scanResultText.textContent = '';

    // Verificar se c칙mera est치 dispon칤vel
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        showToast(
            'C칙mera n칚o dispon칤vel',
            'Seu navegador n칚o suporta acesso  c칙mera',
            'error',
            5000
        );
        return;
    }

    // Abrir c칙mera automaticamente
    try {
        await startPackageCamera();
    } catch (error) {
        console.error('Erro ao abrir c칙mera:', error);

        let errorMessage = 'Verifique as permiss칫es do navegador';

        if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
            errorMessage = 'Permiss칚o negada. Permita o acesso  c칙mera nas configura칞칫es do navegador.';
        } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
            errorMessage = 'Nenhuma c칙mera encontrada no dispositivo.';
        } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
            errorMessage = 'C칙mera j치 est치 em uso por outro aplicativo.';
        }

        showToast(
            'Erro ao abrir c칙mera',
            errorMessage,
            'error',
            7000
        );
    }
}

// Fechar modal de scanner de pacotes
function closePackageScanner() {
    modalScanPackage.classList.remove('active');
    document.body.style.overflow = '';
    stopPackageCamera();
}

// Iniciar c칙mera do scanner de pacotes
async function startPackageCamera() {
    stopPackageCamera();

    // 游 LAZY LOADING: Carregar jsQR apenas quando necess치rio
    if (!lazyLoader.isLoaded('jsQR')) {
        console.log('游닍 [LAZY] Carregando jsQR pela primeira vez...');
        try {
            await lazyLoader.loadJsQR();
        } catch (error) {
            showToast('Erro ao carregar scanner', 'N칚o foi poss칤vel carregar a biblioteca QR', 'error', 4000);
            return;
        }
    }

    // 游꿢 CONSTRAINTS EXATAMENTE COMO O GEMINI ESPECIFICA
    const constraints = {
        video: {
            facingMode: "environment", // Prioriza a c칙mera traseira (como Gemini especificou)
            // Resolu칞칚o otimizada para QR Code
            width: { ideal: 640 },  // Gemini: usar 640x480 para melhor performance
            height: { ideal: 480 },
            // 九 Configura칞칫es DIRETAS (sem { ideal: ... }) como Gemini especificou
            focusMode: "continuous",      // Mant칠m foco no objeto
            exposureMode: "continuous",   // Ajusta exposi칞칚o automaticamente
            whiteBalanceMode: "continuous"
        }
    };

    try {
        packageVideoStream = await navigator.mediaDevices.getUserMedia(constraints);
        qrPackageVideo.srcObject = packageVideoStream;

        // 九 Deixar o sistema operacional gerenciar exposi칞칚o automaticamente
        // (removido c칩digo que for칞ava brilho alto e causava superexposi칞칚o)

        qrPackageCameraContainer.classList.add('active');

        return new Promise((resolve, reject) => {
            qrPackageVideo.onloadedmetadata = async () => {
                try {
                    await qrPackageVideo.play();
                    startPackageScanning();
                    resolve();
                } catch (playError) {
                    console.error('Erro ao iniciar reprodu칞칚o do v칤deo:', playError);
                    reject(playError);
                }
            };

            qrPackageVideo.onerror = (error) => {
                console.error('Erro no elemento de v칤deo:', error);
                reject(error);
            };

            setTimeout(() => {
                if (qrPackageVideo.readyState < 2) {
                    reject(new Error('Timeout ao carregar v칤deo'));
                }
            }, 10000);
        });

    } catch (error) {
        stopPackageCamera();
        qrPackageCameraContainer.classList.remove('active');
        throw error;
    }
}

// Parar c칙mera do scanner de pacotes
function stopPackageCamera() {
    if (packageVideoStream) {
        packageVideoStream.getTracks().forEach(track => {
            track.stop();
            track.enabled = false;
        });
        packageVideoStream = null;
    }

    if (packageScanningInterval) {
        clearInterval(packageScanningInterval);
        packageScanningInterval = null;
    }

    qrPackageVideo.pause();
    qrPackageVideo.srcObject = null;
    qrPackageVideo.load();

    qrPackageVideo.onloadedmetadata = null;
    qrPackageVideo.onerror = null;

    qrPackageCameraContainer.classList.remove('active');
    qrPackageStatus.textContent = 'Procurando c칩digo QR...';
    qrPackageStatus.classList.remove('success');
    packageLastScannedCode = null;
}

// Vari치veis para valida칞칚o de leitura do scanner de pacotes
let packageConsecutiveReads = 0;
let packageLastReadData = null;
const PACKAGE_REQUIRED_READS = 2;

// Iniciar loop de scanning do pacote (otimizado)
function startPackageScanning() {
    const canvasContext = qrPackageCanvas.getContext('2d', { willReadFrequently: true });

    // Resetar contadores
    packageConsecutiveReads = 0;
    packageLastReadData = null;

    packageScanningInterval = setInterval(() => {
        if (qrPackageVideo.readyState === qrPackageVideo.HAVE_ENOUGH_DATA) {
            // 九 OTIMIZA칂츾O GEMINI 1: Reduzir resolu칞칚o de processamento
            // Processar apenas 640x480 em vez da resolu칞칚o nativa
            const processWidth = 640;
            const processHeight = (qrPackageVideo.videoHeight / qrPackageVideo.videoWidth) * processWidth;

            qrPackageCanvas.width = processWidth;
            qrPackageCanvas.height = processHeight;

            // Desenhar v칤deo redimensionado
            canvasContext.drawImage(qrPackageVideo, 0, 0, processWidth, processHeight);

            // 九 OTIMIZA칂츾O GEMINI 2: ROI (Region of Interest)
            // Processar apenas o centro da imagem (quadrado de 400x400px)
            const scanSize = Math.min(400, processWidth, processHeight);
            const centerX = processWidth / 2;
            const centerY = processHeight / 2;

            // Capturar apenas a regi칚o central
            const imageData = canvasContext.getImageData(
                centerX - scanSize / 2,
                centerY - scanSize / 2,
                scanSize,
                scanSize
            );

            // 九 OTIMIZA칂츾O GEMINI 3: attemptBoth para suportar QR Model 1 e 2
            const code = jsQR(imageData.data, scanSize, scanSize, {
                inversionAttempts: "attemptBoth",
            });

            if (code && code.data) {
                const qrData = code.data.trim();

                // Validar c칩digo
                if (!isValidPackageCode(qrData)) {
                    packageConsecutiveReads = 0;
                    packageLastReadData = null;
                    return;
                }

                // Verificar tamanho m칤nimo do QR
                const qrSize = Math.abs(code.location.bottomRightCorner.x - code.location.topLeftCorner.x);
                if (qrSize < 20) return;

                // Sistema de confirma칞칚o
                if (qrData === packageLastReadData) {
                    packageConsecutiveReads++;
                } else {
                    packageConsecutiveReads = 1;
                    packageLastReadData = qrData;
                }

                qrPackageStatus.textContent = `游댌 Lendo... (${packageConsecutiveReads}/${PACKAGE_REQUIRED_READS})`;

                if (packageConsecutiveReads >= PACKAGE_REQUIRED_READS && qrData !== packageLastScannedCode) {
                    packageLastScannedCode = qrData;
                    packageConsecutiveReads = 0;
                    packageLastReadData = null;

                    console.log('九 QR Code do pacote confirmado:', qrData);

                    qrPackageStatus.textContent = '九 C칩digo detectado!';
                    qrPackageStatus.classList.add('success');

                    // Buscar cliente pelo c칩digo QR
                    findClientByQRCode(qrData);
                }
            } else {
                if (packageConsecutiveReads > 0) {
                    packageConsecutiveReads = 0;
                    packageLastReadData = null;
                }
            }
        }
    }, 50); // 20 fps para leitura mais r치pida
}

// Buscar cliente pelo c칩digo QR do pacote
async function findClientByQRCode(qrCode) {
    try {
        // PASSO 1: Buscar o pacote na planilha do dia (delivery_data)
        const { data: deliveryData, error: deliveryError } = await supabase
            .from('delivery_data')
            .select('*')
            .eq('spx_tn', qrCode)
            .single();

        if (deliveryError && deliveryError.code !== 'PGRST116') {
            console.error('Erro ao buscar na planilha:', deliveryError);
        }

        if (!deliveryData) {
            // Pacote n칚o encontrado na planilha do dia
            scanResult.classList.add('active');
            scanResultText.innerHTML = `
                <strong style="color: #ea4335;">仇 Pacote n칚o encontrado</strong><br>
                O c칩digo <code>${escapeHtml(qrCode)}</code> n칚o est치 na planilha do dia.
            `;

            showToast(
                'Pacote n칚o encontrado',
                'Este c칩digo QR n칚o est치 na planilha de entregas do dia',
                'error',
                4000
            );

            // Resetar scanner
            setTimeout(() => {
                packageLastScannedCode = null;
                qrPackageStatus.textContent = 'Procurando c칩digo QR...';
                qrPackageStatus.classList.remove('success');
            }, 3000);
            return;
        }

        // PASSO 2: Buscar clientes cadastrados
        const { data: clients, error: clientsError } = await supabase
            .from('clients')
            .select('*');

        if (clientsError) throw clientsError;

        if (!clients || clients.length === 0) {
            // Nenhum cliente cadastrado
            scanResult.classList.add('active');
            scanResultText.innerHTML = `
                <strong style="color: #ff9800;">丘멆잺 Nenhum cliente cadastrado</strong><br>
                Pacote encontrado na planilha, mas n칚o h치 clientes cadastrados para verificar.
            `;

            showToast(
                'Nenhum cliente cadastrado',
                'Adicione clientes para verificar correspond칡ncia',
                'warning',
                4000
            );

            setTimeout(() => {
                packageLastScannedCode = null;
                qrPackageStatus.textContent = 'Procurando c칩digo QR...';
                qrPackageStatus.classList.remove('success');
            }, 3000);
            return;
        }

        // PASSO 3: Verificar se algum cliente tem endere칞o que bate com o da planilha
        const deliveryAddress = (deliveryData.destination_address || '').toLowerCase().trim();

        let matchedClient = null;

        for (const client of clients) {
            const clientAddress = (client.address || '').toLowerCase().trim();

            // Verificar se os endere칞os batem (compara칞칚o flex칤vel)
            if (clientAddress.includes(deliveryAddress) || deliveryAddress.includes(clientAddress)) {
                matchedClient = client;
                break;
            }

            // Verificar tamb칠m por coordenadas pr칩ximas (mesma latitude/longitude)
            if (client.latitude && client.longitude && deliveryData.latitude && deliveryData.longitude) {
                const latDiff = Math.abs(client.latitude - deliveryData.latitude);
                const lngDiff = Math.abs(client.longitude - deliveryData.longitude);

                // Se diferen칞a menor que 0.0001 graus (~11 metros), considera mesmo endere칞o
                if (latDiff < 0.0001 && lngDiff < 0.0001) {
                    matchedClient = client;
                    break;
                }
            }
        }

        if (matchedClient) {
            // 九 CLIENTE ENCONTRADO - Endere칞o bate!
            scanResult.classList.add('active');
            scanResultText.innerHTML = `
                <strong style="color: #4caf50;">九 Cliente encontrado!</strong><br>
                <strong>${escapeHtml(matchedClient.name)}</strong><br>
                游 ${escapeHtml(matchedClient.phone || 'Sem telefone')}<br>
                游닍 SPX TN: ${escapeHtml(qrCode)}<br>
                游늸 ${escapeHtml(deliveryData.destination_address || 'Sem endere칞o')}
            `;

            // Filtrar lista para mostrar apenas este cliente
            highlightClientInList(matchedClient);

            // Parar c칙mera
            stopPackageCamera();

            // Toast de sucesso
            showToast(
                '九 Endere칞o confirmado!',
                `Cliente: ${matchedClient.name}`,
                'success',
                3000
            );

            // Fechar modal ap칩s 2 segundos
            setTimeout(() => {
                closePackageScanner();
            }, 2000);

        } else {
            // 仇 PACOTE NA PLANILHA MAS CLIENTE N츾O CADASTRADO
            scanResult.classList.add('active');
            scanResultText.innerHTML = `
                <strong style="color: #ff9800;">丘멆잺 Cliente n칚o cadastrado</strong><br>
                游닍 SPX TN: ${escapeHtml(qrCode)}<br>
                游늸 Endere칞o da planilha:<br>
                ${escapeHtml(deliveryData.destination_address || 'Sem endere칞o')}<br>
                <small style="color: #666;">Nenhum cliente cadastrado corresponde a este endere칞o.</small>
            `;

            showToast(
                'Cliente n칚o cadastrado',
                'O pacote existe na planilha mas o cliente n칚o foi cadastrado ainda',
                'warning',
                4000
            );

            // Resetar scanner
            setTimeout(() => {
                packageLastScannedCode = null;
                qrPackageStatus.textContent = 'Procurando c칩digo QR...';
                qrPackageStatus.classList.remove('success');
            }, 3000);
        }

    } catch (error) {
        console.error('Erro ao buscar cliente:', error);
        showToast(
            'Erro na busca',
            'N칚o foi poss칤vel buscar o cliente',
            'error',
            4000
        );
    }
}

// Destacar cliente na lista
function highlightClientInList(client) {
    // Filtrar lista para mostrar apenas este cliente
    searchInput.value = client.name;

    // Disparar evento de busca
    const event = new Event('input', { bubbles: true });
    searchInput.dispatchEvent(event);

    // Scroll at칠 o cliente na lista
    setTimeout(() => {
        const clientCard = document.querySelector(`[data-client-id="${client.id}"]`);
        if (clientCard) {
            clientCard.scrollIntoView({ behavior: 'smooth', block: 'center' });

            // Adicionar destaque visual tempor치rio
            clientCard.style.animation = 'highlight-pulse 1.5s ease-in-out';

            setTimeout(() => {
                clientCard.style.animation = '';
            }, 1500);
        }
    }, 100);
}

// Event listeners do scanner de pacotes
btnScanPackage.addEventListener('click', openPackageScanner);
btnModalScanClose.addEventListener('click', closePackageScanner);
btnPackageClose.addEventListener('click', closePackageScanner);

btnPackageStopCamera.addEventListener('click', () => {
    stopPackageCamera();
});

btnPackageSwitchCamera.addEventListener('click', async () => {
    packageCurrentFacingMode = packageCurrentFacingMode === 'environment' ? 'user' : 'environment';
    stopPackageCamera();
    await startPackageCamera();
});

// Fechar modal ao clicar fora
modalScanPackage.addEventListener('click', (e) => {
    if (e.target === modalScanPackage) {
        closePackageScanner();
    }
});

// ===========================
// MOSTRAR/OCULTAR CLIENTES NO MAPA
// ===========================

const btnToggleClients = document.getElementById('btnToggleClients');
let clientMarkers = {};
let clientsVisible = false;

// Toggle clientes no mapa
btnToggleClients.addEventListener('click', async () => {
    if (clientsVisible) {
        // Ocultar clientes
        hideClientMarkers();
    } else {
        // Mostrar clientes
        await showClientMarkers();
    }
});

// Mostrar marcadores dos clientes cadastrados
async function showClientMarkers() {
    try {
        // Buscar todos os clientes do banco
        const { data: clients, error } = await supabase
            .from('clients')
            .select('*')
            .order('created_at', { ascending: true });

        if (error) throw error;

        if (!clients || clients.length === 0) {
            showToast(
                'Nenhum cliente cadastrado',
                'Adicione clientes para visualiz치-los no mapa',
                'warning',
                3000
            );
            return;
        }

        // Criar marcador para cada cliente
        clients.forEach((client, index) => {
            if (!client.latitude || !client.longitude) {
                console.warn(`Cliente ${client.name} n칚o tem coordenadas v치lidas`);
                return;
            }

            const position = { lat: client.latitude, lng: client.longitude };

            // Criar elemento do marcador com pin azul (diferente dos vermelhos de entrega)
            const markerDiv = document.createElement('div');
            markerDiv.style.cursor = 'pointer';
            markerDiv.style.transition = 'transform 0.2s';

            // Criar pin azul para clientes
            const pinImg = document.createElement('div');
            pinImg.style.width = '28px';
            pinImg.style.height = '28px';
            pinImg.style.background = '#2196F3';
            pinImg.style.border = '3px solid white';
            pinImg.style.borderRadius = '50% 50% 50% 0';
            pinImg.style.transform = 'rotate(-45deg)';
            pinImg.style.boxShadow = '0 2px 5px rgba(0,0,0,0.3)';
            pinImg.style.display = 'flex';
            pinImg.style.alignItems = 'center';
            pinImg.style.justifyContent = 'center';

            const innerCircle = document.createElement('div');
            innerCircle.style.width = '16px';
            innerCircle.style.height = '16px';
            innerCircle.style.background = 'white';
            innerCircle.style.borderRadius = '50%';
            innerCircle.style.transform = 'rotate(45deg)';
            innerCircle.style.fontSize = '10px';
            innerCircle.style.display = 'flex';
            innerCircle.style.alignItems = 'center';
            innerCircle.style.justifyContent = 'center';
            innerCircle.textContent = '游녻';

            pinImg.appendChild(innerCircle);
            markerDiv.appendChild(pinImg);

            // Efeito hover
            markerDiv.addEventListener('mouseenter', () => {
                markerDiv.style.transform = 'scale(1.15)';
            });
            markerDiv.addEventListener('mouseleave', () => {
                markerDiv.style.transform = 'scale(1)';
            });

            // Criar InfoWindow
            const infoWindowContent = document.createElement('div');
            infoWindowContent.style.padding = '10px';
            infoWindowContent.style.maxWidth = '250px';

            const nameDiv = document.createElement('div');
            nameDiv.style.fontWeight = 'bold';
            nameDiv.style.fontSize = '14px';
            nameDiv.style.color = '#2196F3';
            nameDiv.style.marginBottom = '6px';
            nameDiv.textContent = `游녻 ${client.name}`;

            const phoneDiv = document.createElement('div');
            phoneDiv.style.fontSize = '12px';
            phoneDiv.style.color = '#666';
            phoneDiv.style.marginBottom = '4px';
            phoneDiv.innerHTML = `游 ${client.phone || 'Sem telefone'}`;

            const addressDiv = document.createElement('div');
            addressDiv.style.fontSize = '12px';
            addressDiv.style.color = '#333';
            addressDiv.style.lineHeight = '1.4';
            addressDiv.innerHTML = `游늸 ${client.address.replace(/\n/g, '<br>')}`;

            infoWindowContent.appendChild(nameDiv);
            infoWindowContent.appendChild(phoneDiv);
            infoWindowContent.appendChild(addressDiv);

            const infoWindow = new google.maps.InfoWindow({
                content: infoWindowContent,
                maxWidth: 280,
                disableAutoPan: true
            });

            try {
                // Criar marcador usando AdvancedMarkerElement
                if (google.maps.marker && google.maps.marker.AdvancedMarkerElement) {
                    const marker = new google.maps.marker.AdvancedMarkerElement({
                        map,
                        position,
                        content: markerDiv,
                        title: client.name
                    });

                    marker.addListener('click', () => {
                        if (currentInfoWindow) {
                            currentInfoWindow.close();
                        }
                        infoWindow.open(map, marker);
                        currentInfoWindow = infoWindow;
                        map.panTo(position);
                    });

                    clientMarkers[client.id] = marker;
                } else {
                    // Fallback: Marcador cl치ssico
                    const marker = new google.maps.Marker({
                        map,
                        position,
                        title: client.name,
                        icon: {
                            path: google.maps.SymbolPath.CIRCLE,
                            fillColor: '#2196F3',
                            fillOpacity: 1,
                            strokeColor: 'white',
                            strokeWeight: 2,
                            scale: 8
                        }
                    });

                    marker.addListener('click', () => {
                        if (currentInfoWindow) {
                            currentInfoWindow.close();
                        }
                        infoWindow.open(map, marker);
                        currentInfoWindow = infoWindow;
                        map.panTo(position);
                    });

                    clientMarkers[client.id] = marker;
                }
            } catch (error) {
                console.error('Erro ao criar marcador:', error);
            }
        });

        clientsVisible = true;
        btnToggleClients.classList.add('active');

        showToast(
            `${clients.length} cliente${clients.length > 1 ? 's' : ''} exibido${clients.length > 1 ? 's' : ''}`,
            'Clientes cadastrados mostrados no mapa',
            'success',
            3000
        );

    } catch (error) {
        console.error('Erro ao carregar clientes:', error);
        showToast(
            'Erro ao carregar clientes',
            'N칚o foi poss칤vel buscar os dados do banco',
            'error',
            4000
        );
    }
}

// Ocultar marcadores dos clientes
function hideClientMarkers() {
    Object.values(clientMarkers).forEach(marker => {
        try {
            if (marker.map !== undefined) {
                marker.map = null; // AdvancedMarkerElement
            } else if (marker.setMap) {
                marker.setMap(null); // Marker cl치ssico
            }
        } catch (e) {
            console.warn('Erro ao remover marcador:', e);
        }
    });

    clientMarkers = {};
    clientsVisible = false;
    btnToggleClients.classList.remove('active');

    showToast(
        'Clientes ocultados',
        'Marcadores removidos do mapa',
        'info',
        2000
    );
}

// ===========================
// MOSTRAR CLIENTES IDENTIFICADOS NA PLANILHA
// ===========================

const btnShowMatchedClients = document.getElementById('btnShowMatchedClients');
let matchedClientMarkers = {};
let matchedClientsVisible = false;

// Toggle clientes identificados na planilha
btnShowMatchedClients.addEventListener('click', async () => {
    if (matchedClientsVisible) {
        hideMatchedClientMarkers();
    } else {
        await showMatchedClientMarkers();
    }
});

// Fun칞칚o para normalizar endere칞o (mesma usada na compara칞칚o)
function normalizeAddressForComparison(address) {
    return address
        .toLowerCase()
        .trim()
        .replace(/\s+/g, ' ')
        .replace(/[.,;:\-]/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
}

// Mostrar marcadores dos clientes identificados na planilha
async function showMatchedClientMarkers() {
    try {
        // 1. Buscar dados da planilha (delivery_data) do Supabase
        const { data: deliveryData, error: deliveryError } = await supabase
            .from('delivery_data')
            .select('*');

        if (deliveryError) {
            console.error('Erro ao buscar delivery_data:', deliveryError);
            throw deliveryError;
        }

        if (!deliveryData || deliveryData.length === 0) {
            showToast(
                'Nenhuma planilha carregada',
                'Fa칞a upload de uma planilha primeiro',
                'warning',
                4000
            );
            return;
        }

        // 2. Buscar todos os clientes do banco
        const { data: clients, error: clientsError } = await supabase
            .from('clients')
            .select('*')
            .order('created_at', { ascending: true });

        if (clientsError) throw clientsError;

        if (!clients || clients.length === 0) {
            showToast(
                'Nenhum cliente cadastrado',
                'N칚o h치 clientes para exibir',
                'warning',
                3000
            );
            return;
        }

        // 3. Criar Set de endere칞os da planilha (normalizados)
        const deliveryAddresses = new Set();
        deliveryData.forEach(delivery => {
            const addr = delivery.destination_address || '';
            if (addr) {
                deliveryAddresses.add(normalizeAddressForComparison(addr));
            }
        });

        // 4. Filtrar apenas clientes cujos endere칞os batem com a planilha
        const matchedClients = clients.filter(client => {
            const clientAddress = client.address || '';
            const clientAddressFirstLine = clientAddress.split('\n')[0];
            const normalizedClient = normalizeAddressForComparison(clientAddressFirstLine);

            return deliveryAddresses.has(normalizedClient);
        });

        if (matchedClients.length === 0) {
            showToast(
                'Nenhum cliente identificado',
                'Os endere칞os da planilha n칚o correspondem aos clientes cadastrados',
                'warning',
                4000
            );
            return;
        }

        console.log(`游늸 Mostrando ${matchedClients.length} clientes identificados na planilha`);

        // Criar marcador para cada cliente identificado
        matchedClients.forEach((client) => {
            if (!client.latitude || !client.longitude) {
                console.warn(`Cliente ${client.name} n칚o tem coordenadas v치lidas`);
                return;
            }

            const position = { lat: client.latitude, lng: client.longitude };

            // Buscar pacotes/entregas deste cliente na planilha
            const clientAddressFirstLine = (client.address || '').split('\n')[0];
            const normalizedClientAddress = normalizeAddressForComparison(clientAddressFirstLine);

            const clientDeliveries = deliveryData.filter(delivery => {
                const deliveryAddr = delivery.destination_address || '';
                const normalizedDeliveryAddr = normalizeAddressForComparison(deliveryAddr);
                return normalizedDeliveryAddr === normalizedClientAddress;
            });

            const deliveryCount = clientDeliveries.length;

            // Criar elemento do marcador com pin VERDE (para diferenciar)
            const markerDiv = document.createElement('div');
            markerDiv.style.cursor = 'pointer';
            markerDiv.style.transition = 'transform 0.2s';

            // Criar pin verde para clientes identificados na planilha
            const pinImg = document.createElement('div');
            pinImg.style.width = '32px';
            pinImg.style.height = '32px';
            pinImg.style.background = '#4CAF50'; // Verde
            pinImg.style.border = '3px solid white';
            pinImg.style.borderRadius = '50% 50% 50% 0';
            pinImg.style.transform = 'rotate(-45deg)';
            pinImg.style.boxShadow = '0 3px 6px rgba(0,0,0,0.4)';
            pinImg.style.display = 'flex';
            pinImg.style.alignItems = 'center';
            pinImg.style.justifyContent = 'center';

            const innerCircle = document.createElement('div');
            innerCircle.style.width = '18px';
            innerCircle.style.height = '18px';
            innerCircle.style.background = 'white';
            innerCircle.style.borderRadius = '50%';
            innerCircle.style.transform = 'rotate(45deg)';
            innerCircle.style.fontSize = '11px';
            innerCircle.style.display = 'flex';
            innerCircle.style.alignItems = 'center';
            innerCircle.style.justifyContent = 'center';
            innerCircle.textContent = '九';

            pinImg.appendChild(innerCircle);
            markerDiv.appendChild(pinImg);

            // Efeito hover
            markerDiv.addEventListener('mouseenter', () => {
                markerDiv.style.transform = 'scale(1.2)';
            });
            markerDiv.addEventListener('mouseleave', () => {
                markerDiv.style.transform = 'scale(1)';
            });

            // Criar InfoWindow
            const infoWindowContent = document.createElement('div');
            infoWindowContent.style.padding = '12px';
            infoWindowContent.style.maxWidth = '280px';

            const badgeDiv = document.createElement('div');
            badgeDiv.style.background = '#4CAF50';
            badgeDiv.style.color = 'white';
            badgeDiv.style.padding = '4px 8px';
            badgeDiv.style.borderRadius = '4px';
            badgeDiv.style.fontSize = '11px';
            badgeDiv.style.fontWeight = 'bold';
            badgeDiv.style.marginBottom = '8px';
            badgeDiv.style.display = 'inline-block';
            badgeDiv.textContent = '九 IDENTIFICADO NA PLANILHA';

            const nameDiv = document.createElement('div');
            nameDiv.style.fontWeight = 'bold';
            nameDiv.style.fontSize = '14px';
            nameDiv.style.color = '#4CAF50';
            nameDiv.style.marginBottom = '6px';
            nameDiv.textContent = `游녻 ${client.name}`;

            const phoneDiv = document.createElement('div');
            phoneDiv.style.fontSize = '12px';
            phoneDiv.style.color = '#666';
            phoneDiv.style.marginBottom = '4px';
            phoneDiv.innerHTML = `游 ${client.phone || 'Sem telefone'}`;

            const addressDiv = document.createElement('div');
            addressDiv.style.fontSize = '12px';
            addressDiv.style.color = '#333';
            addressDiv.style.lineHeight = '1.5';
            addressDiv.style.marginBottom = '8px';
            addressDiv.style.padding = '8px';
            addressDiv.style.background = '#f5f5f5';
            addressDiv.style.borderRadius = '4px';
            addressDiv.innerHTML = `游늸 ${client.address.replace(/\n/g, '<br>')}`;

            infoWindowContent.appendChild(badgeDiv);
            infoWindowContent.appendChild(nameDiv);
            infoWindowContent.appendChild(phoneDiv);
            infoWindowContent.appendChild(addressDiv);

            // Adicionar informa칞칫es de pacotes se houver entregas
            if (clientDeliveries.length > 0) {
                // T칤tulo da lista de pacotes
                const packagesTitle = document.createElement('div');
                packagesTitle.style.fontWeight = 'bold';
                packagesTitle.style.fontSize = '11px';
                packagesTitle.style.color = '#666';
                packagesTitle.style.marginTop = '8px';
                packagesTitle.style.marginBottom = '6px';
                packagesTitle.style.borderTop = '1px solid #eee';
                packagesTitle.style.paddingTop = '8px';
                packagesTitle.textContent = `游닍 ${deliveryCount} pacote${deliveryCount > 1 ? 's' : ''}:`;
                infoWindowContent.appendChild(packagesTitle);

                // Adicionar cada pacote
                clientDeliveries.forEach((delivery, index) => {
                    const deliveryDiv = document.createElement('div');
                    deliveryDiv.style.fontSize = '11px';
                    deliveryDiv.style.color = '#333';
                    deliveryDiv.style.lineHeight = '1.4';
                    deliveryDiv.style.marginBottom = '4px';
                    deliveryDiv.style.paddingBottom = '4px';
                    deliveryDiv.style.paddingLeft = '8px';

                    if (index < clientDeliveries.length - 1) {
                        deliveryDiv.style.borderBottom = '1px solid #eee';
                    }

                    // Linha com Ordem e C칩digo QR
                    const qrDiv = document.createElement('div');
                    qrDiv.style.display = 'flex';
                    qrDiv.style.justifyContent = 'space-between';
                    qrDiv.style.alignItems = 'center';
                    qrDiv.style.gap = '8px';

                    const sequenceSpan = document.createElement('span');
                    sequenceSpan.style.color = '#4CAF50';
                    sequenceSpan.style.fontWeight = 'bold';
                    sequenceSpan.textContent = `Ordem: ${delivery.sequence || (index + 1)}`;

                    const qrSpan = document.createElement('span');
                    qrSpan.style.fontSize = '10px';
                    qrSpan.style.color = '#666';
                    qrSpan.style.fontFamily = 'monospace';
                    qrSpan.textContent = delivery.spx_tn || 'N/A';

                    qrDiv.appendChild(sequenceSpan);
                    qrDiv.appendChild(qrSpan);

                    deliveryDiv.appendChild(qrDiv);
                    infoWindowContent.appendChild(deliveryDiv);
                });
            }

            // Bot칚o de navega칞칚o
            const navigateBtn = document.createElement('button');
            navigateBtn.style.width = '100%';
            navigateBtn.style.padding = '8px 12px';
            navigateBtn.style.marginTop = '8px';
            navigateBtn.style.background = '#4285f4';
            navigateBtn.style.color = 'white';
            navigateBtn.style.border = 'none';
            navigateBtn.style.borderRadius = '6px';
            navigateBtn.style.fontSize = '13px';
            navigateBtn.style.fontWeight = 'bold';
            navigateBtn.style.cursor = 'pointer';
            navigateBtn.style.transition = 'background 0.2s';
            navigateBtn.innerHTML = '游빐 Navegar at칠 cliente';

            navigateBtn.addEventListener('mouseenter', () => {
                navigateBtn.style.background = '#3367d6';
            });
            navigateBtn.addEventListener('mouseleave', () => {
                navigateBtn.style.background = '#4285f4';
            });

            infoWindowContent.appendChild(navigateBtn);

            const infoWindow = new google.maps.InfoWindow({
                content: infoWindowContent,
                maxWidth: 300,
                disableAutoPan: true
            });

            // Vari치vel para armazenar refer칡ncia ao marker
            let currentMarkerRef = null;

            try {
                // Criar marcador usando AdvancedMarkerElement
                if (google.maps.marker && google.maps.marker.AdvancedMarkerElement) {
                    const marker = new google.maps.marker.AdvancedMarkerElement({
                        map,
                        position,
                        content: markerDiv,
                        title: client.name
                    });

                    marker.addListener('click', () => {
                        if (currentInfoWindow) {
                            currentInfoWindow.close();
                        }
                        infoWindow.open(map, marker);
                        currentInfoWindow = infoWindow;
                        map.panTo(position);
                    });

                    matchedClientMarkers[client.id] = marker;
                    currentMarkerRef = marker;
                } else {
                    // Fallback: Marcador cl치ssico
                    const marker = new google.maps.Marker({
                        map,
                        position,
                        title: client.name,
                        icon: {
                            path: google.maps.SymbolPath.CIRCLE,
                            fillColor: '#4CAF50',
                            fillOpacity: 1,
                            strokeColor: 'white',
                            strokeWeight: 2,
                            scale: 10
                        }
                    });

                    marker.addListener('click', () => {
                        if (currentInfoWindow) {
                            currentInfoWindow.close();
                        }
                        infoWindow.open(map, marker);
                        currentInfoWindow = infoWindow;
                        map.panTo(position);
                    });

                    matchedClientMarkers[client.id] = marker;
                    currentMarkerRef = marker;
                }
            } catch (error) {
                console.error('Erro ao criar marcador:', error);
            }

            // Atribuir evento de navega칞칚o ap칩s criar marker e infoWindow
            navigateBtn.addEventListener('click', () => {
                navigateToClient(client, currentMarkerRef, infoWindow);
            });
        });

        matchedClientsVisible = true;
        btnShowMatchedClients.classList.add('active');

        showToast(
            `${matchedClients.length} cliente${matchedClients.length > 1 ? 's' : ''} identificado${matchedClients.length > 1 ? 's' : ''}`,
            'Clientes da planilha mostrados no mapa',
            'success',
            4000
        );

    } catch (error) {
        console.error('Erro ao carregar clientes identificados:', error);
        showToast(
            'Erro ao carregar',
            'N칚o foi poss칤vel mostrar os clientes',
            'error',
            4000
        );
    }
}

// Ocultar marcadores dos clientes identificados
function hideMatchedClientMarkers() {
    Object.values(matchedClientMarkers).forEach(marker => {
        try {
            if (marker.map !== undefined) {
                marker.map = null; // AdvancedMarkerElement
            } else if (marker.setMap) {
                marker.setMap(null); // Marker cl치ssico
            }
        } catch (e) {
            console.warn('Erro ao remover marcador:', e);
        }
    });

    matchedClientMarkers = {};
    matchedClientsVisible = false;
    btnShowMatchedClients.classList.remove('active');

    showToast(
        'Clientes identificados ocultados',
        'Marcadores removidos do mapa',
        'info',
        2000
    );
}

// ===========================
// UPLOAD DE PLANILHA
// ===========================

const modalUploadSpreadsheet = document.getElementById('modal-upload-spreadsheet');
const btnUploadSpreadsheet = document.getElementById('btnUploadSpreadsheet');
const btnModalUploadClose = document.getElementById('modal-upload-close');
const uploadArea = document.getElementById('upload-area');
const fileInput = document.getElementById('file-input');
const uploadProgress = document.getElementById('upload-progress');
const progressBar = document.getElementById('progress-bar');
const progressText = document.getElementById('progress-text');
const uploadResult = document.getElementById('upload-result');
const resultIcon = document.getElementById('result-icon');
const resultText = document.getElementById('result-text');
const resultDetails = document.getElementById('result-details');

// Abrir modal de upload
function openUploadModal() {
    modalUploadSpreadsheet.classList.add('active');
    document.body.style.overflow = 'hidden';

    // Resetar estados
    uploadArea.style.display = 'block';
    uploadProgress.style.display = 'none';
    uploadResult.style.display = 'none';
    progressBar.style.width = '0%';
    fileInput.value = '';
}

// Fechar modal de upload
function closeUploadModal() {
    modalUploadSpreadsheet.classList.remove('active');
    document.body.style.overflow = '';
}

// Vari치vel para controlar estado do bot칚o
let hasSpreadsheetData = false;

// Event listeners do modal
btnUploadSpreadsheet.addEventListener('click', () => {
    if (hasSpreadsheetData) {
        // Se h치 planilha carregada, limpar dados
        clearSpreadsheetData();
    } else {
        // Se n칚o h치 planilha, abrir modal de upload
        openUploadModal();
    }
});
btnModalUploadClose.addEventListener('click', closeUploadModal);

// Fun칞칚o para mudar bot칚o para modo "Limpar planilha"
function setButtonToClearMode() {
    hasSpreadsheetData = true;
    btnUploadSpreadsheet.textContent = '游딈勇';
    btnUploadSpreadsheet.title = 'Limpar planilha do dia';
    btnUploadSpreadsheet.classList.add('active');
}

// Fun칞칚o para mudar bot칚o para modo "Upload planilha"
function setButtonToUploadMode() {
    hasSpreadsheetData = false;
    btnUploadSpreadsheet.textContent = '游늵';
    btnUploadSpreadsheet.title = 'Atualizar planilha do dia';
    btnUploadSpreadsheet.classList.remove('active');
}

// Fun칞칚o para limpar dados da planilha
async function clearSpreadsheetData() {
    // Criar modal de confirma칞칚o customizado
    const modal = document.createElement('div');
    modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
    modal.style.position = 'fixed';
    modal.style.top = '0';
    modal.style.left = '0';
    modal.style.right = '0';
    modal.style.bottom = '0';
    modal.style.backgroundColor = 'rgba(0,0,0,0.5)';
    modal.style.display = 'flex';
    modal.style.alignItems = 'center';
    modal.style.justifyContent = 'center';
    modal.style.zIndex = '10000';

    modal.innerHTML = `
        <div style="background: white; padding: 24px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 400px; width: 90%;">
            <div style="font-size: 20px; font-weight: 600; color: #333; margin-bottom: 16px;">丘멆잺 Confirmar exclus칚o</div>
            <div style="color: #666; margin-bottom: 20px; line-height: 1.6;">
                <p style="margin-bottom: 12px;">Tem certeza que deseja limpar todos os dados da planilha?</p>
                <p style="margin-bottom: 8px; font-weight: 600;">Isso ir치 remover:</p>
                <ul style="margin-left: 20px;">
                    <li>九 Todos os dados de entrega</li>
                    <li>九 Marcadores no mapa</li>
                    <li>九 Rotas planejadas</li>
                </ul>
                <p style="margin-top: 12px; color: #e53e3e; font-weight: 600;">丘멆잺 Essa a칞칚o n칚o pode ser desfeita!</p>
            </div>
            <div style="display: flex; justify-content: flex-end; gap: 12px;">
                <button id="btn-cancel-clear" style="padding: 10px 20px; background: #e5e7eb; color: #333; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Cancelar</button>
                <button id="btn-confirm-clear" style="padding: 10px 20px; background: #dc2626; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Limpar tudo</button>
            </div>
        </div>
    `;

    document.body.appendChild(modal);

    // Criar promise para aguardar resposta do usu치rio
    const userResponse = await new Promise((resolve) => {
        const btnCancel = modal.querySelector('#btn-cancel-clear');
        const btnConfirm = modal.querySelector('#btn-confirm-clear');

        btnCancel.addEventListener('click', () => {
            modal.remove();
            resolve(false);
        });

        btnConfirm.addEventListener('click', () => {
            modal.remove();
            resolve(true);
        });

        // Clicar fora do modal cancela
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                modal.remove();
                resolve(false);
            }
        });
    });

    if (!userResponse) {
        return;
    }

    try {
        // Limpar dados da planilha do Supabase
        const { error: deleteError } = await supabase
            .from('delivery_data')
            .delete()
            .neq('id', '00000000-0000-0000-0000-000000000000');

        if (deleteError) {
            console.error('Erro ao limpar delivery_data:', deleteError);
            showToast(
                'Erro ao limpar planilha',
                'N칚o foi poss칤vel remover os dados',
                'error',
                4000
            );
            return;
        }

        // Limpar marcadores do mapa
        Object.values(deliveryMarkers).forEach(marker => {
            try {
                if (marker.map !== undefined) {
                    marker.map = null;
                } else if (marker.setMap) {
                    marker.setMap(null);
                }
            } catch (e) {
                console.warn('Erro ao remover marcador:', e);
            }
        });
        deliveryMarkers = {};

        // Limpar rotas
        if (directionsRenderer) {
            directionsRenderer.setDirections({routes: []});
            directionsRenderer.setMap(null);
        }
        if (window.routePolylines) {
            window.routePolylines.forEach(polyline => polyline.setMap(null));
            window.routePolylines = [];
        }

        // Voltar bot칚o para modo upload
        setButtonToUploadMode();

        // Resetar estado do bot칚o "Planejar rota de entrega"
        const btnToggleRoute = document.getElementById('btnToggleRoute');
        if (btnToggleRoute) {
            btnToggleRoute.classList.remove('active');
        }
        routeMode = false;

        // Garantir que os bot칫es est칚o na posi칞칚o correta
        document.getElementById('btnClearRoute').style.display = 'none';
        document.getElementById('btnToggleRoute').style.display = 'flex';

        showToast(
            '游딈勇 Planilha limpa!',
            'Todos os dados foram removidos. Sistema pronto para nova planilha.',
            'success',
            4000
        );

        console.log('九 Planilha limpa com sucesso');

    } catch (error) {
        console.error('Erro ao limpar planilha:', error);
        showToast(
            'Erro ao limpar',
            'Ocorreu um erro ao limpar os dados',
            'error',
            4000
        );
    }
}

modalUploadSpreadsheet.addEventListener('click', (e) => {
    if (e.target === modalUploadSpreadsheet) {
        closeUploadModal();
    }
});

// Click na 치rea de upload
uploadArea.addEventListener('click', () => {
    fileInput.click();
});

// Drag and drop
uploadArea.addEventListener('dragover', (e) => {
    e.preventDefault();
    uploadArea.classList.add('dragover');
});

uploadArea.addEventListener('dragleave', () => {
    uploadArea.classList.remove('dragover');
});

uploadArea.addEventListener('drop', (e) => {
    e.preventDefault();
    uploadArea.classList.remove('dragover');

    const files = e.dataTransfer.files;
    if (files.length > 0) {
        handleFile(files[0]);
    }
});

// Sele칞칚o de arquivo
fileInput.addEventListener('change', (e) => {
    const files = e.target.files;
    if (files.length > 0) {
        handleFile(files[0]);
    }
});

// Processar arquivo
async function handleFile(file) {
    const fileName = file.name.toLowerCase();

    // Validar tipo de arquivo
    if (!fileName.endsWith('.xlsx') && !fileName.endsWith('.xls') && !fileName.endsWith('.csv')) {
        showToast(
            'Formato inv치lido',
            'Por favor, selecione um arquivo Excel (.xlsx, .xls) ou CSV (.csv)',
            'error',
            5000
        );
        return;
    }

    // Mostrar progresso
    uploadArea.style.display = 'none';
    uploadProgress.style.display = 'block';
    progressBar.style.width = '30%';
    progressText.textContent = 'Lendo arquivo...';

    try {
        const data = await file.arrayBuffer();
        progressBar.style.width = '50%';
        progressText.textContent = 'Processando dados...';

        // Processar planilha
        const workbook = XLSX.read(data, { type: 'array' });
        const sheetName = workbook.SheetNames[0];
        const worksheet = workbook.Sheets[sheetName];
        const jsonData = XLSX.utils.sheet_to_json(worksheet);

        progressBar.style.width = '70%';
        progressText.textContent = 'Atualizando banco de dados...';

        // Processar e salvar dados
        const result = await processSpreadsheetData(jsonData);

        progressBar.style.width = '100%';
        progressText.textContent = 'Conclu칤do!';

        // Mostrar resultado de sucesso
        setTimeout(() => {
            uploadProgress.style.display = 'none';
            uploadResult.style.display = 'block';
            resultIcon.textContent = '九';
            resultText.textContent = 'Planilha atualizada com sucesso!';
            resultText.style.color = '#4caf50';

            // Exibir estat칤sticas de compara칞칚o de endere칞os
            let detailsHTML = `${result.count} registros processados<br><br>`;
            detailsHTML += `<strong>游늵 An치lise de Endere칞os:</strong><br>`;
            detailsHTML += `九 <strong>${result.matchedCount}</strong> endere칞o${result.matchedCount !== 1 ? 's' : ''} j치 cadastrado${result.matchedCount !== 1 ? 's' : ''}<br>`;
            detailsHTML += `丘멆잺 <strong>${result.notRegisteredCount}</strong> endere칞o${result.notRegisteredCount !== 1 ? 's' : ''} n칚o cadastrado${result.notRegisteredCount !== 1 ? 's' : ''}`;

            resultDetails.innerHTML = detailsHTML;

            // Fechar modal ap칩s 5 segundos (tempo maior para ler as estat칤sticas)
            setTimeout(() => {
                closeUploadModal();

                // Recarregar dados
                loadClients();

                // Mudar bot칚o para modo "Limpar planilha"
                setButtonToClearMode();

                // 游댠 GARANTIR QUE OS BOT칏ES ESTEJAM NA POSI칂츾O CORRETA
                // Esconder bot칚o de limpar rotas e mostrar bot칚o de planejar rota
                document.getElementById('btnClearRoute').style.display = 'none';
                document.getElementById('btnToggleRoute').style.display = 'flex';
                routeMode = false;

                showToast(
                    'Planilha atualizada!',
                    `${result.matchedCount} cadastrados, ${result.notRegisteredCount} n칚o cadastrados`,
                    'success',
                    5000
                );
            }, 5000);
        }, 500);

    } catch (error) {
        console.error('Erro ao processar planilha:', error);

        uploadProgress.style.display = 'none';
        uploadResult.style.display = 'block';
        resultIcon.textContent = '仇';
        resultText.textContent = 'Erro ao processar planilha';
        resultText.style.color = '#ea4335';
        resultDetails.textContent = error.message || 'Verifique o formato do arquivo';

        showToast(
            'Erro no upload',
            'N칚o foi poss칤vel processar a planilha',
            'error',
            5000
        );
    }
}

// Processar dados da planilha e salvar no Supabase
async function processSpreadsheetData(jsonData) {
    try {
        if (!jsonData || jsonData.length === 0) {
            throw new Error('Planilha vazia ou sem dados v치lidos');
        }

        console.log('Processando', jsonData.length, 'linhas da planilha...');

        // 1. Limpar tabela delivery_data
        const { error: deleteDeliveryError } = await supabase
            .from('delivery_data')
            .delete()
            .neq('id', '00000000-0000-0000-0000-000000000000');

        if (deleteDeliveryError) {
            console.warn('Erro ao limpar delivery_data (talvez a tabela n칚o exista ainda):', deleteDeliveryError);
        }

        // 2. Limpar rotas existentes
        if (typeof currentRoute !== 'undefined' && currentRoute) {
            currentRoute.setMap(null);
            currentRoute = null;
        }
        if (typeof directionsRenderer !== 'undefined' && directionsRenderer) {
            directionsRenderer.setMap(null);
        }
        if (typeof window.routePolylines !== 'undefined' && window.routePolylines) {
            window.routePolylines.forEach(polyline => polyline.setMap(null));
            window.routePolylines = [];
        }

        // 3. Processar dados da planilha
        const deliveryDataRecords = [];

        for (const row of jsonData) {
            // Mapear colunas da planilha para o banco
            const spxTn = row['SPX TN'] || row['spx_tn'] || row['QR Code'] || '';
            const destinationAddress = row['Destination Address'] || row['destination_address'] || row['Endere칞o'] || '';
            const bairro = row['Bairro'] || row['bairro'] || '';
            const city = row['City'] || row['city'] || row['Cidade'] || '';
            const zipcode = row['Zipcode/Postal code'] || row['zipcode'] || row['CEP'] || '';
            const latitude = parseFloat(row['Latitude'] || row['latitude'] || 0);
            const longitude = parseFloat(row['Longitude'] || row['longitude'] || 0);
            const sequence = parseInt(row['Sequence'] || row['sequence'] || 0);

            if (!spxTn) {
                console.warn('Linha sem SPX TN, pulando:', row);
                continue;
            }

            deliveryDataRecords.push({
                spx_tn: spxTn,
                destination_address: destinationAddress,
                bairro: bairro,
                city: city,
                zipcode: zipcode,
                latitude: latitude || null,
                longitude: longitude || null,
                sequence: sequence || null,
                status: 'pending' // Status inicial
            });
        }

        if (deliveryDataRecords.length === 0) {
            throw new Error('Nenhum registro v치lido encontrado na planilha. Verifique se as colunas est칚o corretas: SPX TN, Destination Address, Bairro, City, Zipcode/Postal code, Latitude, Longitude');
        }

        // 4. Inserir na tabela delivery_data
        const { data: insertedData, error: insertDeliveryError } = await supabase
            .from('delivery_data')
            .insert(deliveryDataRecords)
            .select();

        if (insertDeliveryError) {
            console.error('Erro ao inserir em delivery_data:', insertDeliveryError);
            throw new Error(`Erro ao salvar na tabela delivery_data: ${insertDeliveryError.message}`);
        }

        console.log(`九 ${deliveryDataRecords.length} registros salvos na tabela delivery_data`);

        // 5. Buscar clientes cadastrados para compara칞칚o
        const { data: clients, error: clientsError } = await supabase
            .from('clients')
            .select('*');

        if (clientsError) {
            console.warn('Erro ao buscar clientes:', clientsError);
        }

        // 6. Comparar endere칞os da planilha com clientes cadastrados (APENAS endere칞o)
        // Usar Sets para contar ENDERE칂OS 칔NICOS (n칚o pacotes duplicados)
        const matchedAddresses = new Set();
        const notRegisteredAddresses = new Set();

        // Fun칞칚o para normalizar endere칞o (remove espa칞os extras, pontua칞칚o, lowercase)
        const normalizeAddress = (address) => {
            return address
                .toLowerCase()
                .trim()
                // Remove m칰ltiplos espa칞os
                .replace(/\s+/g, ' ')
                // Remove pontua칞칚o (v칤rgulas, pontos, etc.)
                .replace(/[.,;:\-]/g, ' ')
                // Remove espa칞os novamente ap칩s remover pontua칞칚o
                .replace(/\s+/g, ' ')
                .trim();
        };

        if (clients && clients.length > 0) {
            console.log(`游댌 Iniciando compara칞칚o de ${deliveryDataRecords.length} pacotes da planilha com ${clients.length} clientes cadastrados...`);

            for (const delivery of deliveryDataRecords) {
                const deliveryAddress = delivery.destination_address || '';
                const normalizedDelivery = normalizeAddress(deliveryAddress);

                // Pular endere칞os vazios
                if (!normalizedDelivery) continue;

                let isMatched = false;

                // Verificar se o endere칞o da planilha bate com algum cliente cadastrado
                for (const client of clients) {
                    const clientAddress = client.address || '';

                    // Extrair APENAS a primeira linha do endere칞o (antes do \n que separa bairro/cidade)
                    const clientAddressFirstLine = clientAddress.split('\n')[0];
                    const normalizedClient = normalizeAddress(clientAddressFirstLine);

                    // Compara칞칚o APENAS por endere칞o normalizado (ignora nome, telefone, bairro, cidade, CEP)
                    if (normalizedClient && normalizedDelivery && normalizedClient === normalizedDelivery) {
                        isMatched = true;

                        // Adicionar ao Set de endere칞os cadastrados (n칚o duplica)
                        if (!matchedAddresses.has(normalizedDelivery)) {
                            console.log(`九 MATCH: "${deliveryAddress}" === "${clientAddressFirstLine}"`);
                            matchedAddresses.add(normalizedDelivery);
                        }
                        break;
                    }
                }

                if (!isMatched && deliveryAddress) {
                    // Adicionar ao Set de endere칞os n칚o cadastrados (n칚o duplica)
                    if (!notRegisteredAddresses.has(normalizedDelivery)) {
                        console.log(`丘멆잺 NO MATCH: "${deliveryAddress}"`);
                        notRegisteredAddresses.add(normalizedDelivery);
                    }
                }
            }
        } else {
            // Se n칚o h치 clientes cadastrados, contar endere칞os 칰nicos da planilha
            const uniqueAddresses = new Set();
            deliveryDataRecords.forEach(delivery => {
                const normalized = normalizeAddress(delivery.destination_address || '');
                if (normalized) {
                    uniqueAddresses.add(normalized);
                }
            });
            uniqueAddresses.forEach(addr => notRegisteredAddresses.add(addr));
        }

        const matchedCount = matchedAddresses.size;
        const notRegisteredCount = notRegisteredAddresses.size;

        console.log(`游늵 An치lise de endere칞os:`);
        console.log(`   九 Cadastrados: ${matchedCount}`);
        console.log(`   丘멆잺 N칚o cadastrados: ${notRegisteredCount}`);

        // Armazenar endere칞os matched globalmente para uso posterior
        window.matchedAddressesFromSpreadsheet = Array.from(matchedAddresses);

        return {
            success: true,
            count: deliveryDataRecords.length,
            matchedCount: matchedCount,
            notRegisteredCount: notRegisteredCount,
            matchedAddresses: Array.from(matchedAddresses),
            message: `${deliveryDataRecords.length} registros salvos com sucesso`
        };

    } catch (error) {
        console.error('Erro ao processar dados da planilha:', error);
        throw error;
    }
}

// ===========================
// CLEANUP
// ===========================

window.addEventListener('beforeunload', () => {
    if (watchId) navigator.geolocation.clearWatch(watchId);
});

// Resetar bot칫es quando usu치rio volta de app externo (tel: ou whatsapp:)
window.addEventListener('pageshow', function(event) {
    // Executar reset quando p치gina 칠 mostrada novamente
    if (event.persisted || performance.getEntriesByType('navigation')[0]?.type === 'back_forward') {
        resetPhoneButtonsFocus();
    }
    // Reset tamb칠m ao voltar de link externo
    setTimeout(() => {
        resetPhoneButtonsFocus();
    }, 100);
});

// ===========================
// ATUALIZA칂츾O GPS AO VOLTAR DO SEGUNDO PLANO
// ===========================
// Quando o usu치rio guarda o celular e depois abre novamente,
// for칞ar atualiza칞칚o imediata do GPS e centralizar no mapa

let lastVisibilityTime = Date.now();
let isPageVisible = true;

document.addEventListener('visibilitychange', async function() {
    if (document.hidden) {
        // P치gina foi para segundo plano
        isPageVisible = false;
        lastVisibilityTime = Date.now();
        console.log('游닚 [VISIBILITY] P치gina em segundo plano');
    } else {
        // P치gina voltou ao primeiro plano
        isPageVisible = true;
        const timeInBackground = Date.now() - lastVisibilityTime;
        console.log(`游님 [VISIBILITY] P치gina vis칤vel novamente (${Math.round(timeInBackground/1000)}s em segundo plano)`);

        // Se ficou mais de 3 segundos em segundo plano, for칞ar atualiza칞칚o
        if (timeInBackground > 3000 && gpsTracker) {
            try {
                updateStatus('游댃 Atualizando GPS...', true);

                // For칞ar atualiza칞칚o e centralizar
                await gpsTracker.forceUpdateAndCenter();

                showToast(
                    'Localiza칞칚o atualizada',
                    'GPS sincronizado com sua posi칞칚o atual',
                    'success',
                    2000
                );
            } catch (error) {
                console.warn('丘멆잺 [VISIBILITY] Erro ao atualizar GPS ao voltar:', error);
                // N칚o mostrar erro ao usu치rio, apenas log
            }
        }
    }
});

// Tamb칠m atualizar quando a janela recebe foco (complementar ao visibilitychange)
window.addEventListener('focus', async function() {
    const timeInBackground = Date.now() - lastVisibilityTime;

    // Se ficou mais de 5 segundos sem foco e o GPS est치 ativo
    if (timeInBackground > 5000 && gpsTracker && !document.hidden) {
        try {
            console.log('游댃 [FOCUS] Atualizando GPS ap칩s recuperar foco...');
            await gpsTracker.forceUpdate();
        } catch (error) {
            console.warn('丘멆잺 [FOCUS] Erro ao atualizar GPS:', error);
        }
    }
});

// Tratamento de erro de carregamento do mapa
window.addEventListener('error', (e) => {
    if (e.message.includes('Google Maps')) {
        hideLoadingScreen();
        showToast(
            'Erro ao carregar mapa',
            'Verifique sua conex칚o com a internet',
            'error',
            8000
        );
    }
}, true);

/* ===========================
   SERVICE WORKER REMOVIDO
   (N칚o funciona em iframes sandboxed)
   =========================== */
</script>

</body>
</html>