<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Mapa de Clientes - Google Maps</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üìç</text></svg>">

<!-- Material Icons -->
<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

<style>
    :root {
        --primary-color: #4285f4;
        --success-color: #34a853;
        --warning-color: #fbbc04;
        --error-color: #ea4335;
        --bg-overlay: rgba(0, 0, 0, 0.5);
        --shadow-sm: 0 2px 6px rgba(0,0,0,0.3);
        --shadow-lg: 0 4px 12px rgba(0,0,0,0.4);
    }

    body, html {
        margin: 0;
        padding: 0;
        height: 100%;
        width: 100%;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        overflow: hidden;
    }

    #map {
        height: 100%;
        width: 100%;
        position: absolute;
        top: 0;
        left: 0;
        opacity: 0;
        transition: opacity 0.5s ease-in-out;
        /* GPU acceleration para melhor performance */
        transform: translateZ(0);
        will-change: transform, opacity;
        backface-visibility: hidden;
        -webkit-font-smoothing: antialiased;
    }

    #map.loaded {
        opacity: 1;
        will-change: auto; /* Remove will-change ap√≥s carregamento */
    }

    /* ===========================
       LOADING SCREEN
       =========================== */
    #loading-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        transition: opacity 0.5s ease-in-out, visibility 0.5s;
    }

    #loading-screen.hidden {
        opacity: 0;
        visibility: hidden;
    }

    .loading-content {
        text-align: center;
        color: white;
    }

    .spinner {
        width: 60px;
        height: 60px;
        margin: 0 auto 24px;
        position: relative;
    }

    .spinner::before {
        content: '';
        box-sizing: border-box;
        position: absolute;
        top: 50%;
        left: 50%;
        width: 60px;
        height: 60px;
        margin-top: -30px;
        margin-left: -30px;
        border-radius: 50%;
        border: 4px solid rgba(255, 255, 255, 0.2);
        border-top-color: white;
        animation: spinner 0.8s linear infinite;
    }

    @keyframes spinner {
        to { transform: rotate(360deg); }
    }

    .loading-text {
        font-size: 18px;
        font-weight: 600;
        margin-bottom: 8px;
        animation: pulse-text 2s ease-in-out infinite;
    }

    .loading-subtext {
        font-size: 14px;
        opacity: 0.9;
        font-weight: 400;
    }

    @keyframes pulse-text {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.6; }
    }

    /* ===========================
       CONTROLES DO MAPA
       =========================== */
    .map-control {
        position: fixed;
        top: 90px;
        right: 20px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        z-index: 9999;
        opacity: 0;
        transform: translateX(100px);
        transition: opacity 0.5s ease-in-out 0.3s, transform 0.5s ease-in-out 0.3s;
    }

    .map-control.visible {
        opacity: 1;
        transform: translateX(0);
    }

    .control-btn {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        border: none;
        background: white;
        box-shadow: var(--shadow-sm);
        font-size: 18px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        position: relative;
        color: #333;
        /* Centralizar √≠cone perfeitamente */
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0;
        line-height: 1;
    }

    .control-btn:hover {
        box-shadow: var(--shadow-lg);
        transform: translateY(-2px);
    }

    .control-btn:active {
        transform: translateY(0) scale(0.95);
    }

    .control-btn.active {
        background: var(--primary-color);
        color: white;
    }

    .control-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none !important;
    }

    /* Bot√£o Parar Navega√ß√£o */
    .stop-navigation-btn {
        position: fixed;
        bottom: 100px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 1000;
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 12px 20px;
        background: linear-gradient(135deg, #ea4335 0%, #c5221f 100%);
        color: white;
        border: none;
        border-radius: 30px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(234, 67, 53, 0.4);
        transition: all 0.3s ease;
        animation: pulseNav 2s infinite;
    }

    .stop-navigation-btn:hover {
        transform: translateX(-50%) scale(1.05);
        box-shadow: 0 6px 20px rgba(234, 67, 53, 0.5);
    }

    .stop-navigation-btn:active {
        transform: translateX(-50%) scale(0.98);
    }

    .stop-nav-icon {
        font-size: 16px;
        font-weight: bold;
    }

    @keyframes pulseNav {
        0%, 100% { box-shadow: 0 4px 15px rgba(234, 67, 53, 0.4); }
        50% { box-shadow: 0 4px 25px rgba(234, 67, 53, 0.6); }
    }

    /* Indicador de carregamento no bot√£o */
    .control-btn.loading::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 20px;
        height: 20px;
        margin-top: -10px;
        margin-left: -10px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-top-color: white;
        border-radius: 50%;
        animation: spinner 0.6s linear infinite;
    }

    .control-btn.loading {
        color: transparent;
    }

    /* ===========================
       MARCADOR DA LOCALIZA√á√ÉO (Estilo Google Maps)
       =========================== */
    .location-marker {
        position: relative;
        width: 22px;
        height: 22px;
    }

    /* Anel de precis√£o/accuracy (c√≠rculo azul claro pulsante) */
    .location-marker-pulse {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 80px;
        height: 80px;
        background: rgba(66, 133, 244, 0.15);
        border-radius: 50%;
        z-index: 1;
    }

    /* Bolinha azul principal (estilo Google Maps) */
    .location-marker-dot {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 18px;
        height: 18px;
        background: #4285F4;
        border: 3px solid white;
        border-radius: 50%;
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
        z-index: 3;
    }

    /* Anima√ß√£o do anel de precis√£o */
    @keyframes pulse {
        0% {
            transform: translate(-50%, -50%) scale(0.5);
            opacity: 1;
        }
        100% {
            transform: translate(-50%, -50%) scale(1.2);
            opacity: 0.4;
        }
    }

    .location-marker.active .location-marker-pulse {
        animation: pulse 2s ease-out infinite;
    }

    /* ===========================
       BOT√ÉO DE CENTRALIZAR LOCALIZA√á√ÉO (Estilo Google Maps)
       =========================== */
    .gps-center-button {
        background-color: #fff;
        border: 0;
        border-radius: 2px;
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
        cursor: pointer;
        width: 40px;
        height: 40px;
        padding: 0;
        margin: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.2s ease;
    }

    .gps-center-button:hover {
        background-color: #f5f5f5;
    }

    .gps-center-button:active {
        background-color: #e8e8e8;
    }

    .gps-center-button .material-icons {
        color: #666;
        font-size: 20px;
    }

    .gps-center-button.active .material-icons {
        color: #4285F4;
    }

    /* ===========================
       SISTEMA DE NOTIFICA√á√ïES
       =========================== */
    #toast-container {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10001;
        display: flex;
        flex-direction: column;
        gap: 10px;
        max-width: 90%;
        width: 400px;
    }

    .toast {
        background: white;
        padding: 16px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        display: flex;
        align-items: center;
        gap: 12px;
        animation: slideDown 0.3s ease-out;
        border-left: 4px solid var(--primary-color);
    }

    .toast.success { border-left-color: var(--success-color); }
    .toast.warning { border-left-color: var(--warning-color); }
    .toast.error { border-left-color: var(--error-color); }

    @keyframes slideDown {
        from {
            opacity: 0;
            transform: translateY(-20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .toast.hiding {
        animation: slideUp 0.3s ease-out forwards;
    }

    @keyframes slideUp {
        from {
            opacity: 1;
            transform: translateY(0);
        }
        to {
            opacity: 0;
            transform: translateY(-20px);
        }
    }

    .toast-icon {
        font-size: 20px;
        flex-shrink: 0;
    }

    .toast-content {
        flex: 1;
    }

    .toast-title {
        font-weight: 600;
        margin-bottom: 4px;
        color: #333;
    }

    .toast-message {
        font-size: 14px;
        color: #666;
    }

    /* ===========================
       STATUS BAR
       =========================== */
    #status-bar {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        padding: 12px 20px;
        border-radius: 24px;
        box-shadow: var(--shadow-sm);
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 14px;
        color: #333;
        z-index: 9999;
        opacity: 0;
        transition: opacity 0.3s ease;
    }

    #status-bar.visible {
        opacity: 1;
    }

    .status-indicator {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: var(--success-color);
        animation: blink 2s infinite;
    }

    @keyframes blink {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.3; }
    }

    .status-indicator.inactive {
        background: #ccc;
        animation: none;
    }

    /* ===========================
       BOT√ÉO ADICIONAR CLIENTE
       =========================== */
    #btn-add-client {
        position: fixed;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%);
        background: var(--primary-color);
        color: white;
        border: none;
        padding: 16px 32px;
        border-radius: 30px;
        font-size: 16px;
        font-weight: 600;
        box-shadow: var(--shadow-lg);
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 10px;
        z-index: 9999;
        opacity: 0;
        transition: all 0.3s ease;
    }

    #btn-add-client.visible {
        opacity: 1;
    }

    #btn-add-client:hover {
        transform: translateX(-50%) translateY(-3px);
        box-shadow: 0 6px 20px rgba(66, 133, 244, 0.4);
    }

    #btn-add-client:active {
        transform: translateX(-50%) translateY(-1px);
    }

    /* ===========================
       MODAL ADICIONAR CLIENTE
       =========================== */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: var(--bg-overlay);
        z-index: 10004;
        display: none;
        align-items: center;
        justify-content: center;
        opacity: 0;
        transition: opacity 0.3s ease;
    }

    .modal-overlay.active {
        display: flex;
        opacity: 1;
    }

    .modal-container {
        background: white;
        border-radius: 16px;
        width: 90%;
        max-width: 500px;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        transform: scale(0.9);
        transition: transform 0.3s ease;
    }

    .modal-overlay.active .modal-container {
        transform: scale(1);
    }

    .modal-close {
        width: 32px;
        height: 32px;
        border: none;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 50%;
        font-size: 18px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
        box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        flex-shrink: 0;
    }

    .modal-close:hover {
        background: white;
        transform: rotate(90deg);
    }

    .modal-body {
        padding: 24px;
    }

    /* Custom Dropdown para Sele√ß√£o de Endere√ßo */
    .custom-dropdown {
        position: relative;
        width: 100%;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }

    .custom-dropdown-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 14px;
        background: #fff;
        border: 2px solid #e0e0e0;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-size: 14px;
        color: #333;
    }

    .dark .custom-dropdown-header {
        background: #2d2d2d;
        border-color: #444;
        color: #e0e0e0;
    }

    .custom-dropdown-header:hover {
        border-color: #4285f4;
    }

    .custom-dropdown.open .custom-dropdown-header {
        border-color: #4285f4;
        border-bottom-left-radius: 0;
        border-bottom-right-radius: 0;
    }

    .dropdown-placeholder {
        color: #888;
    }

    .dropdown-arrow {
        font-size: 10px;
        color: #666;
        transition: transform 0.2s ease;
    }

    .custom-dropdown.open .dropdown-arrow {
        transform: rotate(180deg);
    }

    .custom-dropdown-list {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        max-height: 250px;
        overflow-y: auto;
        background: #fff;
        border: 2px solid #4285f4;
        border-top: none;
        border-radius: 0 0 8px 8px;
        display: none;
        z-index: 1000;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }

    .dark .custom-dropdown-list {
        background: #2d2d2d;
        border-color: #4285f4;
    }

    .custom-dropdown.open .custom-dropdown-list {
        display: block;
    }

    .dropdown-item {
        display: flex;
        align-items: flex-start;
        padding: 10px 14px;
        cursor: pointer;
        border-bottom: 1px solid #f0f0f0;
        transition: background 0.15s ease;
        gap: 10px;
    }

    .dark .dropdown-item {
        border-bottom-color: #3d3d3d;
    }

    .dropdown-item:last-child {
        border-bottom: none;
    }

    .dropdown-item:hover {
        background: #f5f8ff;
    }

    .dark .dropdown-item:hover {
        background: #3a3a4a;
    }

    .dropdown-item-number {
        font-weight: 700;
        color: #EA4335;
        font-size: 14px;
        min-width: 28px;
        flex-shrink: 0;
    }

    .dropdown-item-address {
        flex: 1;
        font-size: 13px;
        color: #333;
        line-height: 1.4;
    }

    .dark .dropdown-item-address {
        color: #e0e0e0;
    }

    .dropdown-item-empty {
        padding: 16px 14px;
        text-align: center;
        color: #888;
        font-style: italic;
        font-size: 13px;
    }

    .dropdown-item-success {
        color: #34A853;
        font-weight: 500;
    }

    /* Scrollbar customizada para a lista */
    .custom-dropdown-list::-webkit-scrollbar {
        width: 6px;
    }

    .custom-dropdown-list::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 3px;
    }

    .custom-dropdown-list::-webkit-scrollbar-thumb {
        background: #c1c1c1;
        border-radius: 3px;
    }

    .custom-dropdown-list::-webkit-scrollbar-thumb:hover {
        background: #a1a1a1;
    }

    .dark .custom-dropdown-list::-webkit-scrollbar-track {
        background: #3d3d3d;
    }

    .dark .custom-dropdown-list::-webkit-scrollbar-thumb {
        background: #666;
    }

    /* QR Code Scanner */
    .qr-scanner-section {
        margin-bottom: 24px;
    }

    .scanner-title {
        font-size: 14px;
        font-weight: 600;
        color: #666;
        margin-bottom: 12px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .qr-camera-container {
        position: relative;
        width: 100%;
        max-width: 400px;
        margin: 0 auto;
        background: #000;
        border-radius: 12px;
        overflow: hidden;
        display: none;
    }

    .qr-camera-container.active {
        display: block;
    }

    #qr-video {
        width: 100%;
        height: auto;
        max-height: 300px;
        min-height: 200px;
        object-fit: cover;
        display: block;
        background: #000;
    }

    #qr-video:not([src]) {
        opacity: 0.3;
    }

    /* V√≠deo do scanner de pacotes - mesmos estilos */
    #qr-package-video {
        width: 100%;
        height: auto;
        max-height: 300px;
        min-height: 200px;
        object-fit: cover;
        display: block;
        background: #000;
    }

    #qr-package-video:not([src]) {
        opacity: 0.3;
    }

    #qr-canvas,
    #qr-package-canvas {
        display: none;
    }

    .qr-overlay {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 200px;
        height: 200px;
        border: 2px solid rgba(255, 255, 255, 0.5);
        border-radius: 12px;
        pointer-events: none;
    }

    .qr-overlay::before,
    .qr-overlay::after {
        content: '';
        position: absolute;
        width: 20px;
        height: 20px;
        border: 3px solid white;
    }

    .qr-overlay::before {
        top: -3px;
        left: -3px;
        border-right: none;
        border-bottom: none;
    }

    .qr-overlay::after {
        top: -3px;
        right: -3px;
        border-left: none;
        border-bottom: none;
    }

    .qr-overlay-bottom-left::before,
    .qr-overlay-bottom-right::after {
        content: '';
        position: absolute;
        width: 20px;
        height: 20px;
        border: 3px solid white;
    }

    .qr-overlay-bottom-left::before {
        bottom: -3px;
        left: -3px;
        border-right: none;
        border-top: none;
    }

    .qr-overlay-bottom-right::after {
        bottom: -3px;
        right: -3px;
        border-left: none;
        border-top: none;
    }

    .scanning-line {
        position: absolute;
        width: 100%;
        height: 2px;
        background: linear-gradient(90deg, transparent, var(--success-color), transparent);
        top: 50%;
        animation: scan 2s linear infinite;
        pointer-events: none;
    }

    @keyframes scan {
        0% { top: 25%; opacity: 0; }
        50% { opacity: 1; }
        100% { top: 75%; opacity: 0; }
    }

    .camera-controls {
        position: absolute;
        bottom: 12px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 10px;
        z-index: 10;
    }

    .camera-btn {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        border: none;
        background: rgba(255, 255, 255, 0.9);
        color: #333;
        font-size: 18px;
        cursor: pointer;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        transition: all 0.2s ease;
    }

    .camera-btn:hover {
        background: white;
        transform: scale(1.1);
    }

    .camera-btn:active {
        transform: scale(0.95);
    }

    .address-display {
        margin-bottom: 24px;
        padding: 16px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 12px;
        color: white;
        display: none;
        animation: slideIn 0.3s ease-out;
    }

    .address-display.active {
        display: block;
    }

    @keyframes slideIn {
        from {
            opacity: 0;
            transform: translateY(-10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    @keyframes highlight-pulse {
        0% {
            background: #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transform: scale(1);
        }
        50% {
            background: #e3f2fd;
            box-shadow: 0 4px 12px rgba(33,150,243,0.3);
            transform: scale(1.02);
        }
        100% {
            background: #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transform: scale(1);
        }
    }

    .address-label {
        font-size: 12px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        opacity: 0.9;
        margin-bottom: 8px;
    }

    .address-text {
        font-size: 15px;
        font-weight: 500;
        line-height: 1.5;
    }

    .address-icon {
        font-size: 20px;
        margin-right: 8px;
    }

    .qr-status {
        position: absolute;
        top: 12px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 6px 12px;
        border-radius: 16px;
        font-size: 12px;
        font-weight: 500;
        z-index: 10;
        white-space: nowrap;
    }

    .qr-status.success {
        background: rgba(52, 168, 83, 0.9);
    }

    .qr-result {
        margin-top: 12px;
        padding: 12px;
        background: #e8f5e9;
        border-left: 4px solid var(--success-color);
        border-radius: 4px;
        display: none;
    }

    .qr-result.active {
        display: block;
    }

    .qr-result-text {
        font-size: 13px;
        color: #2e7d32;
        word-break: break-all;
    }

    /* Formul√°rio */
    .form-group {
        margin-bottom: 20px;
    }

    .form-label {
        display: block;
        font-size: 14px;
        font-weight: 600;
        color: #333;
        margin-bottom: 8px;
    }

    .form-input {
        width: 100%;
        padding: 12px 16px;
        border: 1px solid #ddd;
        border-radius: 8px;
        font-size: 16px;
        font-family: inherit;
        transition: all 0.2s ease;
        box-sizing: border-box;
    }

    .form-input:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 3px rgba(66, 133, 244, 0.1);
    }

    .form-input:disabled {
        background: #f5f5f5;
        color: #999;
        cursor: not-allowed;
    }

    .form-input::placeholder {
        color: #999;
    }

    .form-textarea {
        min-height: 80px;
        resize: vertical;
        font-family: inherit;
    }

    .form-footer {
        padding: 16px 24px;
        border-top: 1px solid #e0e0e0;
        display: flex;
        gap: 12px;
        justify-content: flex-end;
    }

    .btn {
        padding: 12px 24px;
        border: none;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .btn-secondary {
        background: #f5f5f5;
        color: #666;
    }

    .btn-secondary:hover {
        background: #e0e0e0;
    }

    .btn-primary {
        background: var(--primary-color);
        color: white;
    }

    .btn-primary:hover {
        background: #3367d6;
    }

    .btn-primary:disabled {
        background: #ccc;
        cursor: not-allowed;
    }

    /* Loading no modal */
    .btn.loading {
        position: relative;
        color: transparent;
    }

    .btn.loading::after {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 16px;
        height: 16px;
        margin-top: -8px;
        margin-left: -8px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-top-color: white;
        border-radius: 50%;
        animation: spinner 0.6s linear infinite;
    }

    /* ===========================
       MENU LATERAL (SIDEBAR)
       =========================== */
    .sidebar {
        position: fixed;
        top: 0;
        left: -400px;
        width: 400px;
        height: 100%;
        background: white;
        box-shadow: 2px 0 12px rgba(0,0,0,0.15);
        z-index: 10003;
        transition: left 0.3s ease;
        display: flex;
        flex-direction: column;
    }

    .sidebar.open {
        left: 0;
    }

    .sidebar-header {
        padding: 20px;
        border-bottom: 2px solid #e0e0e0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
    }

    .sidebar-title {
        font-size: 20px;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .sidebar-close {
        width: 32px;
        height: 32px;
        border: none;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 50%;
        color: white;
        font-size: 18px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
    }

    .sidebar-close:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: rotate(90deg);
    }

    .sidebar-search {
        padding: 16px;
        border-bottom: 1px solid #e0e0e0;
    }

    .search-container {
        position: relative;
        display: flex;
        gap: 8px;
        align-items: center;
    }

    .search-input-wrapper {
        position: relative;
        flex: 1;
    }

    .search-icon {
        position: absolute;
        left: 12px;
        top: 50%;
        transform: translateY(-50%);
        font-size: 18px;
        color: #999;
        pointer-events: none;
    }

    .search-input {
        width: 100%;
        padding: 12px 12px 12px 42px;
        border: 2px solid #e0e0e0;
        border-radius: 24px;
        font-size: 15px;
        font-family: inherit;
        transition: all 0.2s ease;
        box-sizing: border-box;
    }

    .search-input:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 3px rgba(66, 133, 244, 0.1);
    }

    .search-input::placeholder {
        color: #999;
    }

    .btn-scan-package {
        background: var(--primary-color);
        color: white;
        border: none;
        border-radius: 50%;
        width: 44px;
        height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        cursor: pointer;
        transition: all 0.2s ease;
        flex-shrink: 0;
        box-shadow: 0 2px 4px rgba(0,0,0,0.15);
    }

    .btn-scan-package:hover {
        background: #1976D2;
        transform: scale(1.05);
        box-shadow: 0 3px 6px rgba(33,150,243,0.4);
    }

    .btn-scan-package:active {
        transform: scale(0.95);
    }

    /* Resultado do scanner de pacotes */
    .scan-result {
        display: none;
        margin-top: 20px;
        padding: 16px;
        background: #f5f5f5;
        border-radius: 8px;
    }

    .scan-result.active {
        display: block;
    }

    .scan-result-label {
        font-weight: 600;
        color: #333;
        margin-bottom: 8px;
    }

    .scan-result-text {
        color: #666;
    }

    /* Upload de Planilha */
    .upload-area {
        border: 2px dashed #ccc;
        border-radius: 12px;
        padding: 40px 20px;
        text-align: center;
        cursor: pointer;
        transition: all 0.3s ease;
        background: #fafafa;
    }

    .upload-area:hover {
        border-color: var(--primary-color);
        background: #f0f7ff;
    }

    .upload-area.dragover {
        border-color: var(--primary-color);
        background: #e3f2fd;
        transform: scale(1.02);
    }

    .upload-icon {
        font-size: 48px;
        margin-bottom: 12px;
    }

    .upload-text {
        font-size: 16px;
        font-weight: 600;
        color: #333;
        margin-bottom: 4px;
    }

    .upload-subtext {
        font-size: 14px;
        color: #666;
        margin-bottom: 8px;
    }

    .upload-formats {
        font-size: 12px;
        color: #999;
    }

    .upload-progress {
        text-align: center;
        padding: 20px;
    }

    .progress-bar-container {
        width: 100%;
        height: 8px;
        background: #e0e0e0;
        border-radius: 4px;
        overflow: hidden;
        margin-bottom: 12px;
    }

    .progress-bar {
        height: 100%;
        background: linear-gradient(90deg, var(--primary-color), #1976D2);
        width: 0%;
        transition: width 0.3s ease;
        animation: progress-pulse 1.5s ease-in-out infinite;
    }

    @keyframes progress-pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
    }

    .progress-text {
        font-size: 14px;
        color: #666;
    }

    .upload-result {
        text-align: center;
        padding: 20px;
    }

    .result-icon {
        font-size: 48px;
        margin-bottom: 12px;
    }

    .result-text {
        font-size: 16px;
        font-weight: 600;
        margin-bottom: 8px;
    }

    .result-details {
        font-size: 14px;
        color: #666;
        margin-top: 10px;
        line-height: 1.6;
    }

    .sidebar-content {
        flex: 1;
        overflow-y: auto;
        padding: 16px;
    }

    .clients-list {
        display: flex;
        flex-direction: column;
        gap: 12px;
    }

    .client-card {
        background: white;
        border: 1px solid #e0e0e0;
        border-radius: 12px;
        padding: 16px;
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .client-card:hover {
        border-color: var(--primary-color);
        box-shadow: 0 2px 8px rgba(66, 133, 244, 0.15);
        transform: translateY(-2px);
    }

    .client-card-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 8px;
        gap: 8px;
    }

    .client-name {
        font-size: 16px;
        font-weight: 600;
        color: #333;
        display: flex;
        align-items: center;
        gap: 8px;
        flex: 1;
    }

    .client-actions {
        display: flex;
        gap: 8px;
        opacity: 1;
    }

    .client-action-btn {
        background: none;
        border: none;
        padding: 6px 10px;
        cursor: pointer;
        font-size: 20px;
        border-radius: 6px;
        transition: all 0.2s ease;
        line-height: 1;
        min-width: 38px;
        min-height: 38px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .client-action-btn:hover {
        background: #f0f0f0;
        transform: scale(1.1);
    }

    .client-action-btn.navigate-btn:hover {
        background: #e8f5e9;
    }

    .client-action-btn.edit-btn:hover {
        background: #e3f2fd;
    }

    .client-action-btn.delete-btn:hover {
        background: #ffebee;
    }

    .client-info {
        font-size: 14px;
        color: #666;
        margin-bottom: 4px;
        display: flex;
        align-items: flex-start;
        gap: 8px;
    }

    .client-info.phone-info {
        align-items: center;
        justify-content: space-between;
    }

    .client-info-icon {
        font-size: 14px;
        opacity: 0.7;
        flex-shrink: 0;
        margin-top: 2px;
    }

    .phone-actions {
        display: flex;
        gap: 12px;
        margin-left: auto;
    }

    .phone-action-btn {
        border: none;
        padding: 0;
        cursor: pointer;
        border-radius: 50%;
        transition: all 0.2s ease;
        text-decoration: none;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 38px;
        height: 38px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.15);
    }

    .phone-action-btn svg {
        width: 20px;
        height: 20px;
    }

    .phone-action-btn svg {
        transition: all 0.2s ease;
    }

    /* Classes para estado resetado - for√ßa re-render */
    .phone-action-btn.btn-reset {
        pointer-events: auto !important;
        outline: none !important;
    }

    .phone-action-btn.call-btn {
        background: #2196F3;
        box-shadow: 0 2px 4px rgba(0,0,0,0.15);
        transform: scale(1);
    }

    .phone-action-btn.call-btn:link,
    .phone-action-btn.call-btn:visited,
    .phone-action-btn.call-btn:focus,
    .phone-action-btn.call-btn:active,
    .phone-action-btn.call-btn:focus-visible {
        background: #2196F3;
        box-shadow: 0 2px 4px rgba(0,0,0,0.15);
        transform: scale(1);
    }

    /* Hover apenas em desktop - n√£o em touch */
    @media (hover: hover) and (pointer: fine) {
        .phone-action-btn.call-btn:hover:not(:active) {
            background: #1976D2;
            transform: scale(1.1);
            box-shadow: 0 3px 6px rgba(33,150,243,0.4);
        }
    }

    .phone-action-btn.whatsapp-btn {
        background: #25D366;
        box-shadow: 0 2px 4px rgba(0,0,0,0.15);
        transform: scale(1);
    }

    .phone-action-btn.whatsapp-btn:link,
    .phone-action-btn.whatsapp-btn:visited,
    .phone-action-btn.whatsapp-btn:focus,
    .phone-action-btn.whatsapp-btn:active,
    .phone-action-btn.whatsapp-btn:focus-visible {
        background: #25D366;
        box-shadow: 0 2px 4px rgba(0,0,0,0.15);
        transform: scale(1);
    }

    /* Hover apenas em desktop - n√£o em touch */
    @media (hover: hover) and (pointer: fine) {
        .phone-action-btn.whatsapp-btn:hover:not(:active) {
            background: #128C7E;
            transform: scale(1.1);
            box-shadow: 0 3px 6px rgba(37,211,102,0.4);
        }
    }

    .empty-state {
        text-align: center;
        padding: 40px 20px;
        color: #999;
    }

    .empty-state-icon {
        font-size: 48px;
        margin-bottom: 16px;
        opacity: 0.5;
    }

    .empty-state-text {
        font-size: 16px;
        font-weight: 500;
        margin-bottom: 8px;
    }

    .empty-state-subtext {
        font-size: 14px;
    }

    .sidebar-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 10002;
        display: none;
        opacity: 0;
        transition: opacity 0.3s ease;
    }

    .sidebar-overlay.active {
        display: block;
        opacity: 1;
    }

    .client-count {
        display: inline-block;
        background: rgba(255, 255, 255, 0.2);
        padding: 4px 10px;
        border-radius: 12px;
        font-size: 13px;
        font-weight: 600;
    }

    /* ===========================
       RESPONSIVO
       =========================== */
    @media (max-width: 768px) {
        .map-control {
            top: 70px;
            right: 10px;
        }

        .control-btn {
            width: 44px;
            height: 44px;
            font-size: 16px;
        }

        #toast-container {
            width: calc(100% - 40px);
        }

        .toast {
            padding: 12px 16px;
        }

        .loading-text {
            font-size: 16px;
        }

        .loading-subtext {
            font-size: 13px;
        }

        #status-bar {
            bottom: 10px;
            font-size: 13px;
            padding: 10px 16px;
        }

        #btn-add-client {
            bottom: 60px;
            padding: 14px 24px;
            font-size: 15px;
        }

        /* Ajustes para mobile - bot√µes maiores */
        .phone-action-btn {
            width: 42px;
            height: 42px;
        }

        .phone-action-btn svg {
            width: 22px;
            height: 22px;
        }

        .phone-actions {
            gap: 14px;
        }

        .client-action-btn {
            font-size: 22px;
            min-width: 42px;
            min-height: 42px;
            padding: 8px 12px;
        }

        .client-actions {
            gap: 10px;
        }

        /* Desabilitar hover em mobile - evitar estados persistentes */
        .phone-action-btn {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        .phone-action-btn.call-btn,
        .phone-action-btn.call-btn:link,
        .phone-action-btn.call-btn:visited,
        .phone-action-btn.call-btn:focus,
        .phone-action-btn.call-btn:active,
        .phone-action-btn.call-btn:focus-visible,
        .phone-action-btn.call-btn:hover {
            background: #2196F3;
            box-shadow: 0 2px 4px rgba(0,0,0,0.15);
            transform: scale(1);
        }

        .phone-action-btn.whatsapp-btn,
        .phone-action-btn.whatsapp-btn:link,
        .phone-action-btn.whatsapp-btn:visited,
        .phone-action-btn.whatsapp-btn:focus,
        .phone-action-btn.whatsapp-btn:active,
        .phone-action-btn.whatsapp-btn:focus-visible,
        .phone-action-btn.whatsapp-btn:hover {
            background: #25D366;
            box-shadow: 0 2px 4px rgba(0,0,0,0.15);
            transform: scale(1);
        }

        .modal-container {
            width: 95%;
            max-height: 95vh;
        }

        .modal-body {
            padding: 20px;
        }

        .scanner-title {
            font-size: 13px;
        }

        .modal-close {
            width: 28px;
            height: 28px;
            font-size: 16px;
        }

        .qr-camera-container {
            max-width: 100%;
        }

        #qr-video,
        #qr-package-video {
            max-height: 250px;
        }

        .qr-overlay {
            width: 180px;
            height: 180px;
        }

        .qr-upload-area {
            padding: 24px;
        }

        .qr-icon {
            font-size: 40px;
        }

        .form-footer {
            padding: 12px 20px;
            flex-direction: column-reverse;
        }

        .btn {
            width: 100%;
        }

        .sidebar {
            width: 100%;
            left: -100%;
        }

        .sidebar.open {
            left: 0;
        }

        .sidebar-title {
            font-size: 18px;
        }

        .sidebar-content {
            padding: 12px;
        }

        .client-card {
            padding: 14px;
        }
    }

    /* Esconder o bot√£o X padr√£o do Google Maps InfoWindow */
    .gm-style-iw-chr {
        display: none !important;
    }

    .gm-ui-hover-effect {
        display: none !important;
    }
</style>
</head>
<body>

<!-- Loading Screen -->
<div id="loading-screen">
    <div class="loading-content">
        <div class="spinner"></div>
        <div class="loading-text" id="loading-text">Inicializando mapa...</div>
        <div class="loading-subtext" id="loading-subtext">Aguarde um momento</div>
    </div>
</div>

<!-- Mapa -->
<div id="map"></div>

<!-- Controles -->
<div class="map-control">
    <button id="btnToggle3D" class="control-btn" title="Alternar visualiza√ß√£o 3D">3D</button>
    <button id="btnToggleRoute" class="control-btn" title="Planejar rota de entrega">üöó</button>
    <button id="btnClearRoute" class="control-btn" title="Limpar rotas e marcadores" style="display: none;">üóëÔ∏è</button>
    <button id="btnOpenSidebar" class="control-btn" title="Ver lista de clientes">üë•</button>
    <button id="btnUploadSpreadsheet" class="control-btn" title="Atualizar planilha do dia">üìä</button>
    <button id="btnToggleClients" class="control-btn" title="Mostrar/Ocultar clientes no mapa">üë§</button>
    <button id="btnShowMatchedClients" class="control-btn" title="Mostrar clientes identificados na planilha">üìç</button>
</div>

<!-- Bot√£o Parar Navega√ß√£o (flutuante) -->
<button id="btnStopNavigation" class="stop-navigation-btn" style="display: none;">
    <span class="stop-nav-icon">‚úï</span>
    <span class="stop-nav-text">Parar Navega√ß√£o</span>
</button>

<!-- Container de Notifica√ß√µes -->
<div id="toast-container"></div>

<!-- Status Bar -->
<div id="status-bar">
    <div class="status-indicator" id="status-indicator"></div>
    <span id="status-text">Rastreando localiza√ß√£o</span>
</div>

<!-- Bot√£o Adicionar Cliente -->
<button id="btn-add-client">
    <span>‚ûï</span>
    <span>Adicionar Cliente</span>
</button>

<!-- Sidebar - Menu Lateral -->
<div class="sidebar-overlay" id="sidebar-overlay"></div>

<div class="sidebar" id="sidebar">
    <div class="sidebar-header">
        <div class="sidebar-title">
            <span>üë•</span>
            <span>Clientes</span>
            <span class="client-count" id="client-count">0</span>
        </div>
        <button class="sidebar-close" id="sidebar-close">‚úï</button>
    </div>

    <div class="sidebar-search">
        <div class="search-container">
            <div class="search-input-wrapper">
                <span class="search-icon">üîç</span>
                <input
                    type="text"
                    class="search-input"
                    id="search-input"
                    placeholder="Buscar por nome, endere√ßo ou telefone..."
                >
            </div>
            <button class="btn-scan-package" id="btn-scan-package" title="Escanear c√≥digo QR do pacote">üì¶</button>
        </div>
    </div>

    <div class="sidebar-content">
        <div class="clients-list" id="clients-list">
            <!-- Lista de clientes ser√° inserida aqui -->
            <div class="empty-state">
                <div class="empty-state-icon">üìã</div>
                <div class="empty-state-text">Nenhum cliente cadastrado</div>
                <div class="empty-state-subtext">Adicione clientes para v√™-los aqui</div>
            </div>
        </div>
    </div>
</div>

<!-- Modal Adicionar Cliente -->
<div class="modal-overlay" id="modal-add-client">
    <div class="modal-container">
        <div class="modal-body">
            <!-- Scanner QR Code -->
            <div class="qr-scanner-section">
                <div class="scanner-title">
                    <span>üì∏ Aponte a c√¢mera para o QR Code</span>
                    <button class="modal-close" id="modal-close">‚úï</button>
                </div>

                <div class="qr-camera-container active" id="qr-camera-container">
                    <video id="qr-video" autoplay playsinline></video>
                    <canvas id="qr-canvas"></canvas>

                    <div class="qr-overlay">
                        <div class="qr-overlay-bottom-left"></div>
                        <div class="qr-overlay-bottom-right"></div>
                    </div>

                    <div class="scanning-line"></div>

                    <div class="qr-status" id="qr-status">Procurando QR Code...</div>

                    <div class="camera-controls">
                        <button class="camera-btn" id="btn-stop-camera" title="Fechar c√¢mera">‚úï</button>
                        <button class="camera-btn" id="btn-switch-camera" title="Trocar c√¢mera">üîÑ</button>
                    </div>
                </div>
            </div>

            <!-- Display do Endere√ßo -->
            <div class="address-display" id="address-display">
                <div class="address-label">üìç Endere√ßo do Cliente</div>
                <div class="address-text" id="address-text"></div>
            </div>

            <!-- Formul√°rio -->
            <form id="form-add-client">

                <div class="form-group">
                    <label class="form-label" for="input-name">Nome do Cliente *</label>
                    <input
                        type="text"
                        class="form-input"
                        id="input-name"
                        placeholder="Digite o nome do cliente"
                        required
                    >
                </div>

                <div class="form-group">
                    <label class="form-label" for="input-phone">Telefone</label>
                    <input
                        type="tel"
                        class="form-input"
                        id="input-phone"
                        placeholder="(91)9 9942-1942"
                        maxlength="16"
                    >
                </div>

                <div class="form-group">
                    <label class="form-label">üìã Selecionar Endere√ßo Manualmente</label>

                    <!-- Dropdown Customizado -->
                    <div class="custom-dropdown" id="address-dropdown">
                        <div class="custom-dropdown-header" id="dropdown-header">
                            <span class="dropdown-placeholder">-- Escolha um endere√ßo da planilha --</span>
                            <span class="dropdown-arrow">‚ñº</span>
                        </div>
                        <div class="custom-dropdown-list" id="dropdown-list">
                            <!-- Itens ser√£o inseridos via JS -->
                        </div>
                    </div>

                    <div class="address-list-hint" style="font-size: 11px; color: #666; margin-top: 4px;">
                        üí° Use quando n√£o for poss√≠vel ler o QR Code
                    </div>
                </div>
            </form>
        </div>

        <div class="form-footer">
            <button type="button" class="btn btn-secondary" id="btn-cancel">Cancelar</button>
            <button type="submit" class="btn btn-primary" id="btn-save" form="form-add-client">Salvar Cliente</button>
        </div>
    </div>
</div>

<!-- Modal Scanner de Pacotes -->
<div class="modal-overlay" id="modal-scan-package">
    <div class="modal-container">
        <div class="modal-body">
            <!-- Scanner QR Code -->
            <div class="qr-scanner-section">
                <div class="scanner-title">
                    <span>üì¶ Escanear C√≥digo do Pacote</span>
                    <button class="modal-close" id="modal-scan-close">‚úï</button>
                </div>

                <div class="qr-camera-container" id="qr-package-camera-container">
                    <video id="qr-package-video" autoplay playsinline></video>
                    <canvas id="qr-package-canvas"></canvas>

                    <div class="qr-overlay">
                        <div class="qr-overlay-bottom-left"></div>
                        <div class="qr-overlay-bottom-right"></div>
                    </div>

                    <div class="scanning-line"></div>

                    <div class="qr-status" id="qr-package-status">Procurando c√≥digo QR...</div>

                    <div class="camera-controls">
                        <button class="camera-btn" id="btn-package-stop-camera" title="Fechar c√¢mera">‚úï</button>
                        <button class="camera-btn" id="btn-package-switch-camera" title="Trocar c√¢mera">üîÑ</button>
                    </div>
                </div>
            </div>

            <!-- Resultado da busca -->
            <div class="scan-result" id="scan-result">
                <div class="scan-result-label">üìã Cliente Encontrado:</div>
                <div class="scan-result-text" id="scan-result-text"></div>
            </div>
        </div>

        <div class="form-footer">
            <button type="button" class="btn btn-secondary" id="btn-package-close">Fechar</button>
        </div>
    </div>
</div>

<!-- Modal Upload de Planilha -->
<div class="modal-overlay" id="modal-upload-spreadsheet">
    <div class="modal-container">
        <div class="modal-body">
            <div class="scanner-title">
                <span>üìä Atualizar Planilha do Dia</span>
                <button class="modal-close" id="modal-upload-close">‚úï</button>
            </div>

            <div class="upload-info" style="background: #fff3cd; padding: 12px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #ffc107;">
                <div style="font-weight: 600; color: #856404; margin-bottom: 4px;">‚ö†Ô∏è Aten√ß√£o</div>
                <div style="font-size: 13px; color: #856404;">
                    Ao fazer upload de uma nova planilha, todos os dados anteriores ser√£o substitu√≠dos e a roteiriza√ß√£o ser√° resetada.
                </div>
            </div>

            <div class="upload-area" id="upload-area">
                <div class="upload-icon">üìä</div>
                <div class="upload-text">Arraste a planilha aqui</div>
                <div class="upload-subtext">ou clique para selecionar</div>
                <div class="upload-formats">Formatos: Excel (.xlsx, .xls) ou CSV (.csv)</div>
                <input type="file" id="file-input" accept=".xlsx,.xls,.csv" style="display: none;">
            </div>

            <div class="upload-progress" id="upload-progress" style="display: none;">
                <div class="progress-bar-container">
                    <div class="progress-bar" id="progress-bar"></div>
                </div>
                <div class="progress-text" id="progress-text">Processando planilha...</div>
            </div>

            <div class="upload-result" id="upload-result" style="display: none;">
                <div class="result-icon" id="result-icon"></div>
                <div class="result-text" id="result-text"></div>
                <div class="result-details" id="result-details"></div>
            </div>
        </div>
    </div>
</div>

<!-- SheetJS - Biblioteca para processamento de Excel -->
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

<!-- Tween.js - Biblioteca para anima√ß√µes fluidas -->
<script src="https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@23.1.3/dist/tween.umd.js"></script>

<!-- Supabase -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<!-- jsQR - Carregado sob demanda via Lazy Loading -->

<script>
    const SUPABASE_URL = "https://dctlgztkqtktxnmiuqgr.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRjdGxnenRrcXRrdHhubWl1cWdyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ2MzMwNDIsImV4cCI6MjA4MDIwOTA0Mn0.Ctlx8A4QBFxa7Iu6fObw_OthHfA2XrzY47UiMMIhbIU";

    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    // Dados da planilha Excel - Mapeamento de QR codes para endere√ßos
    const addressDatabase = {
  "BR2548334621214": {
    "address": "Alameda Moraes, 246, Rua ao lado do Conselho tutela\nBairro: Praia Grande (Mosqueiro)\nBel√©m - 66914-090",
    "latitude": -1.1424655,
    "longitude": -48.4652878,
    "city": "Bel√©m",
    "zipcode": "66914-090",
    "sequence": 1
  },
  "BR258090515239N": {
    "address": "Alameda Moraes, 246, Rua ao lado do Conselho tutela\nBairro: Praia Grande (Mosqueiro)\nBel√©m - 66914-090",
    "latitude": -1.1424655,
    "longitude": -48.4652878,
    "city": "Bel√©m",
    "zipcode": "66914-090",
    "sequence": 2
  },
  "BR2543386241922": {
    "address": "Alameda Moraes, 246\nBairro: Praia Grande (Mosqueiro)\nBel√©m - 66914-090",
    "latitude": -1.1424655,
    "longitude": -48.4652878,
    "city": "Bel√©m",
    "zipcode": "66914-090",
    "sequence": 3
  },
  "BR257485707468Y": {
    "address": "Alameda Moraes, 246\nBairro: Praia Grande (Mosqueiro)\nBel√©m - 66914-090",
    "latitude": -1.1424655,
    "longitude": -48.4652878,
    "city": "Bel√©m",
    "zipcode": "66914-090",
    "sequence": 4
  },
  "BR2590650161019": {
    "address": "Alameda Petr√≥polis, 42, Casa branca com muro baixinho\nBairro: Praia Grande (Mosqueiro)\nBel√©m - 66914-100",
    "latitude": -1.1432,
    "longitude": -48.4659004,
    "city": "Bel√©m",
    "zipcode": "66914-100",
    "sequence": 5
  },
  "BR259792298200M": {
    "address": "Alameda Ribamar Santos, 15, Ao lado da LR mat. De constru√ß\nBairro: Praia Grande\nBel√©m - 66911-120",
    "latitude": -1.1438776,
    "longitude": -48.4640884,
    "city": "Bel√©m",
    "zipcode": "66911-120",
    "sequence": 6
  },
  "BR255026824340N": {
    "address": "Avenida Beira-Mar - Rua: Dos Escoteiros Pr√≥ximo A Rua: Alameda Moraes, 1657, Condominio prive do farol, Bel√©m, Par√°, 66910150\nBel√©m - 66910150",
    "latitude": -1.1451693,
    "longitude": -48.4655266,
    "city": "Bel√©m",
    "zipcode": "66910150",
    "sequence": 7
  },
  "BR255669520013M": {
    "address": "Passagem S√£o Domingos, 33, Pr√≥ximo √† Rua das Mangueiras\nBairro: Praia Grande (Mosqueiro)\nBel√©m - 66914-080",
    "latitude": -1.1456899,
    "longitude": -48.4648368,
    "city": "Bel√©m",
    "zipcode": "66914-080",
    "sequence": 8
  },
  "BR2532092523217": {
    "address": "Rua Raimundo Cintra, 39, Entre S√£o Domingos e Santa Ter\nBairro: Mangueiras (Mosqueiro)\nBel√©m - 66912-220",
    "latitude": -1.1466,
    "longitude": -48.462101,
    "city": "Bel√©m",
    "zipcode": "66912-220",
    "sequence": 9
  },
  "BR252457049287C": {
    "address": "Rua Raimundo Cintra, 12\nBairro: Mangueiras (Mosqueiro)\nBel√©m - 66912-220",
    "latitude": -1.1470315,
    "longitude": -48.4626465,
    "city": "Bel√©m",
    "zipcode": "66912-220",
    "sequence": 10
  },
  "BR257080667441M": {
    "address": "Passg Santa Rita De Kace, 31\nBairro: Ariramba (Mosqueiro)\nBel√©m - 66914-110",
    "latitude": -1.1463585,
    "longitude": -48.4638905,
    "city": "Bel√©m",
    "zipcode": "66914-110",
    "sequence": 11
  },
  "BR259832570656I": {
    "address": "Passg Santa Rita De Kace, 31\nBairro: Ariramba (Mosqueiro)\nBel√©m - 66914-110",
    "latitude": -1.1463585,
    "longitude": -48.4638905,
    "city": "Bel√©m",
    "zipcode": "66914-110",
    "sequence": 12
  },
  "BR2555419499636": {
    "address": "Passagem Mirim, 2, Av. Beira Mar\nBairro: Praia grande mosqueiro\nBel√©m - 66914-510",
    "latitude": -1.15,
    "longitude": -48.4671,
    "city": "Bel√©m",
    "zipcode": "66914-510",
    "sequence": 13
  },
  "BR2510739661481": {
    "address": "Rua do Carmo, 83, Casa\nBairro: Praia Grande (Mosqueiro)\nBel√©m - 66914-040",
    "latitude": -1.1504477,
    "longitude": -48.4675026,
    "city": "Bel√©m",
    "zipcode": "66914-040",
    "sequence": 14
  },
  "BR256427341903Q": {
    "address": "Rua Quinze de Novembro, 39, Praia grande casa verde\nBairro: Vila (Mosqueiro)\nBel√©m - 66910-000",
    "latitude": -1.1509,
    "longitude": -48.4693985,
    "city": "Bel√©m",
    "zipcode": "66910-000",
    "sequence": 15
  },
  "BR252765984646G": {
    "address": "Rua Quinze de Novembro, 39, Praia grande casa verde\nBairro: Vila (Mosqueiro)\nBel√©m - 66910-000",
    "latitude": -1.1509,
    "longitude": -48.4693985,
    "city": "Bel√©m",
    "zipcode": "66910-000",
    "sequence": 16
  },
  "BR2508214594606": {
    "address": "Alameda Fran√ßa, 33\nBairro: Praia Grande (Mosqueiro)\nBel√©m - 66914-230",
    "latitude": -1.151652,
    "longitude": -48.4677925,
    "city": "Bel√©m",
    "zipcode": "66914-230",
    "sequence": 17
  },
  "BR257708180761F": {
    "address": "Avenida Beira-Mar, 1076, Proximo a barraca carioquinha\nBairro: Vila (Mosqueiro)\nBel√©m - 66910-150",
    "latitude": -1.1522,
    "longitude": -48.4702988,
    "city": "Bel√©m",
    "zipcode": "66910-150",
    "sequence": 18
  },
  "BR2570195095799": {
    "address": "Rua Coronel Jos√© do √ì, 137, Pr√≥ximo a alameda Raimunda\nBairro: Vila (Mosqueiro)\nBel√©m - 66910-010",
    "latitude": -1.1536975,
    "longitude": -48.4707031,
    "city": "Bel√©m",
    "zipcode": "66910-010",
    "sequence": 19
  },
  "BR252206059319K": {
    "address": "Travessa Lauro Sodr√©, 198 a\nBairro: Vila (Mosqueiro)\nBel√©m - 66910-170",
    "latitude": -1.154588,
    "longitude": -48.4708481,
    "city": "Bel√©m",
    "zipcode": "66910-170",
    "sequence": 20
  },
  "BR258463997845D": {
    "address": "Travessa Lauro Sodr√©, 156, Pr√≥ximo ao Hospital Municipal\nBairro: Vila (Mosqueiro)\nBel√©m - 66910-170",
    "latitude": -1.154617,
    "longitude": -48.470768,
    "city": "Bel√©m",
    "zipcode": "66910-170",
    "sequence": 21
  },
  "BR250808162475E": {
    "address": "Travessa Lauro Sodr√©, 235, Ao lado do hospital geral\nBairro: Vila (Mosqueiro)\nBel√©m - 66910-170",
    "latitude": -1.1545,
    "longitude": -48.4700012,
    "city": "Bel√©m",
    "zipcode": "66910-170",
    "sequence": 22
  },
  "BR250622958347D": {
    "address": "Rua Quinze de Novembro, 728\nBairro: Vila (Mosqueiro)\nBel√©m - 66910-000",
    "latitude": -1.1571,
    "longitude": -48.4695015,
    "city": "Bel√©m",
    "zipcode": "66910-000",
    "sequence": 23
  },
  "BR253698799515E": {
    "address": "Rua Quinze de Novembro, 688, Entre o hospital e as 5 bocas\nBairro: Vila (Mosqueiro)\nBel√©m - 66910-000",
    "latitude": -1.1568567,
    "longitude": -48.4692841,
    "city": "Bel√©m",
    "zipcode": "66910-000",
    "sequence": 24
  },
  "BR257375048849G": {
    "address": "Rua Quinze de Novembro, 830\nBairro: Vila (Mosqueiro)\nBel√©m - 66910-000",
    "latitude": -1.1584749,
    "longitude": -48.4690933,
    "city": "Bel√©m",
    "zipcode": "66910-000",
    "sequence": 25
  },
  "BR2570810926273": {
    "address": "Travessa Coronel Jos√© Mota, 263, Proximidade da Av 16 de Novemb\nBairro: Vila (Mosqueiro)\nBel√©m - 66910-680",
    "latitude": -1.1585106,
    "longitude": -48.4683007,
    "city": "Bel√©m",
    "zipcode": "66910-680",
    "sequence": 26
  },
  "BR2589228991775": {
    "address": "Rua Quinze de Novembro, 18, Passagem sao sebastiao\nBairro: Vila (Mosqueiro)\nBel√©m - 66910-000",
    "latitude": -1.1597145,
    "longitude": -48.469059,
    "city": "Bel√©m",
    "zipcode": "66910-000",
    "sequence": 27
  },
  "BR255892110928M": {
    "address": "Rua Quinze de Novembro, 18, Passagem sao sebastiao\nBairro: Vila (Mosqueiro)\nBel√©m - 66910-000",
    "latitude": -1.1597145,
    "longitude": -48.469059,
    "city": "Bel√©m",
    "zipcode": "66910-000",
    "sequence": 28
  },
  "BR254165660090X": {
    "address": "Rua Quinze de Novembro, 18, Ao lado da NutriPets ra√ß√µes\nBairro: Vila (Mosqueiro)\nBel√©m - 66910-000",
    "latitude": -1.1597145,
    "longitude": -48.469059,
    "city": "Bel√©m",
    "zipcode": "66910-000",
    "sequence": 29
  },
  "BR255864217202N": {
    "address": "Rua Quinze de Novembro, 18, Ao lado da NutriPets ra√ß√µes\nBairro: Vila (Mosqueiro)\nBel√©m - 66910-000",
    "latitude": -1.1597145,
    "longitude": -48.469059,
    "city": "Bel√©m",
    "zipcode": "66910-000",
    "sequence": 30
  },
  "BR2559482212905": {
    "address": "Rua Quinze de Novembro, 1021, Entre cinco bocas e Get√∫lio\nBairro: Vila (Mosqueiro)\nBel√©m - 66910-000",
    "latitude": -1.1600853,
    "longitude": -48.4689713,
    "city": "Bel√©m",
    "zipcode": "66910-000",
    "sequence": 31
  },
  "BR257588309119A": {
    "address": "Rua Quinze de Novembro, 121, Pr√≥ximo as cinco bocas\nBairro: Vila (Mosqueiro)\nBel√©m - 66910-000",
    "latitude": -1.1589,
    "longitude": -48.4688988,
    "city": "Bel√©m",
    "zipcode": "66910-000",
    "sequence": 32
  },
  "BR256931637480Z": {
    "address": "Rua Quinze de Novembro, 10, Alemeda terra prometida, Bel√©m, Par√°, 66910000\nBel√©m - 66910000",
    "latitude": -1.1587799,
    "longitude": -48.4689636,
    "city": "Bel√©m",
    "zipcode": "66910000",
    "sequence": 33
  },
  "BR2558435081671": {
    "address": "Avenida Dezesseis de Novembro, 2909, Em frente ao quiosque ki gosto\nBairro: Vila (Mosqueiro)\nBel√©m - 66910-140",
    "latitude": -1.1566,
    "longitude": -48.467701,
    "city": "Bel√©m",
    "zipcode": "66910-140",
    "sequence": 34
  },
  "BR258040408902Y": {
    "address": "Rua Padre Manoel Raiol, 220, Muro amarelo com telhas vermel\nBairro: Vila (Mosqueiro)\nBel√©m - 66910-040",
    "latitude": -1.1570348,
    "longitude": -48.467514,
    "city": "Bel√©m",
    "zipcode": "66910-040",
    "sequence": 35
  },
  "BR257612403013T": {
    "address": "Avenida Dezesseis de Novembro, 72, Em frente dep√≥sito Xavier ao lado Jo√£o motos\nBairro: Vila (Mosqueiro)\nBel√©m - 66910-140",
    "latitude": -1.1532554,
    "longitude": -48.466176,
    "city": "Bel√©m",
    "zipcode": "66910-140",
    "sequence": 36
  },
  "BR258316357232J": {
    "address": "Avenida Dezesseis de Novembro, 72, Em frente dep√≥sito Xavier ao lado Jo√£o motos\nBairro: Vila (Mosqueiro)\nBel√©m - 66910-140",
    "latitude": -1.1532554,
    "longitude": -48.466176,
    "city": "Bel√©m",
    "zipcode": "66910-140",
    "sequence": 37
  },
  "BR2553020039350": {
    "address": "Avenida Dezesseis de Novembro, 72, Em frente dep√≥sito Xavier ao lado Jo√£o motos\nBairro: Vila (Mosqueiro)\nBel√©m - 66910-140",
    "latitude": -1.1532554,
    "longitude": -48.466176,
    "city": "Bel√©m",
    "zipcode": "66910-140",
    "sequence": 38
  },
  "BR257648789028P": {
    "address": "Avenida Dezesseis de Novembro, 72, Em frente dep√≥sito Xavier ao lado Jo√£o motos\nBairro: Vila (Mosqueiro)\nBel√©m - 66910-140",
    "latitude": -1.1532554,
    "longitude": -48.466176,
    "city": "Bel√©m",
    "zipcode": "66910-140",
    "sequence": 39
  },
  "BR258126401029R": {
    "address": "Avenida Dezesseis de Novembro, 72\nBairro: Vila (Mosqueiro)\nBel√©m - 66910-140",
    "latitude": -1.1532554,
    "longitude": -48.466176,
    "city": "Bel√©m",
    "zipcode": "66910-140",
    "sequence": 40
  },
  "BR2531457461885": {
    "address": "Avenida Dezesseis de Novembro, 72, Em frente deposito Xavier ao lado Jo√£o motos\nBairro: Vila (Mosqueiro)\nBel√©m - 66910-140",
    "latitude": -1.1532554,
    "longitude": -48.466176,
    "city": "Bel√©m",
    "zipcode": "66910-140",
    "sequence": 41
  },
  "BR253333999131P": {
    "address": "Avenida Dezesseis de Novembro, 2391, Ao lado da barbearia adryan\nBairro: Vila (Mosqueiro)\nBel√©m - 66910-140",
    "latitude": -1.1524897,
    "longitude": -48.4659386,
    "city": "Bel√©m",
    "zipcode": "66910-140",
    "sequence": 42
  },
  "BR253625124030V": {
    "address": "Passagem Atl√¢ntida, 03, Em frente ao Cantinho Azulino\nBairro: Vila (Mosqueiro)\nBel√©m - 66910-520",
    "latitude": -1.1530946,
    "longitude": -48.4672508,
    "city": "Bel√©m",
    "zipcode": "66910-520",
    "sequence": 43
  },
  "BR257518523148D": {
    "address": "Alameda Ferreira, 28, Ao lado do comercial Ant√¥nio\nBairro: Vila (Mosqueiro)\nBel√©m - 66910-050",
    "latitude": -1.1531883,
    "longitude": -48.466831,
    "city": "Bel√©m",
    "zipcode": "66910-050",
    "sequence": 44
  },
  "BR259312148009G": {
    "address": "Passagem Atl√¢ntida, 03, Ao lado da  antena\nBairro: Vila (Mosqueiro)\nBel√©m - 66910-520",
    "latitude": -1.1530946,
    "longitude": -48.4672508,
    "city": "Bel√©m",
    "zipcode": "66910-520",
    "sequence": 45
  },
  "BR256031024378C": {
    "address": "Alameda Bela Vista, 6, 16 de novembro/ Camilo salgado\nBairro: Vila (Mosqueiro)\nBel√©m - 66910-390",
    "latitude": -1.1538,
    "longitude": -48.4674988,
    "city": "Bel√©m",
    "zipcode": "66910-390",
    "sequence": 46
  },
  "BR252838900075R": {
    "address": "Travessa Bela Vista, 2, Pr√≥ximo ao hospital geral\nBairro: Praia Grande\nBel√©m - 66912-140",
    "latitude": -1.1538016,
    "longitude": -48.4650497,
    "city": "Bel√©m",
    "zipcode": "66912-140",
    "sequence": 47
  },
  "BR250305017276D": {
    "address": "Rua Sandro Carvalho, 68-A, Paquet√°\nBairro: Mangueiras (Mosqueiro)\nBel√©m - 66912-180",
    "latitude": -1.1528,
    "longitude": -48.4622993,
    "city": "Bel√©m",
    "zipcode": "66912-180",
    "sequence": 48
  },
  "BR259426316988F": {
    "address": "Rua Sandro Carvalho, 68-A, Paquet√°\nBairro: Mangueiras (Mosqueiro)\nBel√©m - 66912-180",
    "latitude": -1.1528,
    "longitude": -48.4622993,
    "city": "Bel√©m",
    "zipcode": "66912-180",
    "sequence": 49
  },
  "BR2573946235544": {
    "address": "Rua Bariloche, 30, Casa\nBairro: Mangueiras (Mosqueiro)\nBel√©m - 66912-130",
    "latitude": -1.1523347,
    "longitude": -48.4615555,
    "city": "Bel√©m",
    "zipcode": "66912-130",
    "sequence": 50
  },
  "BR258040312070F": {
    "address": "Rua Bariloche, 30, Casa\nBairro: Mangueiras (Mosqueiro)\nBel√©m - 66912-130",
    "latitude": -1.1523347,
    "longitude": -48.4615555,
    "city": "Bel√©m",
    "zipcode": "66912-130",
    "sequence": 52
  },
  "BR2561235030362": {
    "address": "Alameda Paquet√°, 4, pr√≥ximo ao comercial Caroline\nBairro: Mangueiras (Mosqueiro)\nBel√©m - 66912-210",
    "latitude": -1.1530893,
    "longitude": -48.4613724,
    "city": "Bel√©m",
    "zipcode": "66912-210",
    "sequence": 53
  },
  "BR252010309093W": {
    "address": "Alameda Paquet√°, 4, pr√≥ximo ao comercial Caroline\nBairro: Mangueiras (Mosqueiro)\nBel√©m - 66912-210",
    "latitude": -1.1530893,
    "longitude": -48.4613724,
    "city": "Bel√©m",
    "zipcode": "66912-210",
    "sequence": 54
  },
  "BR2512319420247": {
    "address": "Travessa Santa Helena, O1, Atr√°s da loja Dluna Beach\nBairro: Mangueiras (Mosqueiro)\nBel√©m - 66912-200",
    "latitude": -1.1548012,
    "longitude": -48.4614143,
    "city": "Bel√©m",
    "zipcode": "66912-200",
    "sequence": 55
  },
  "BR254841014012P": {
    "address": "Pra√ßa do carmo, 27, Bar do seu bene\nBairro: Cidade velha\nBel√©m - 66912-230",
    "latitude": -1.1591978,
    "longitude": -48.4569525,
    "city": "Bel√©m",
    "zipcode": "66912-230",
    "sequence": 56
  },
  "BR258670218678R": {
    "address": "Travessa Bela Vista, 87\nBairro: Mangueiras (Mosqueiro)\nBel√©m - 66912-140",
    "latitude": -1.1542,
    "longitude": -48.4594002,
    "city": "Bel√©m",
    "zipcode": "66912-140",
    "sequence": 57
  },
  "BR254442724443V": {
    "address": "Alameda Paquet√°, 900, Final do asfalto lado direito\nBairro: Mangueiras (Mosqueiro)\nBel√©m - 66912-210",
    "latitude": -1.1533793,
    "longitude": -48.4588051,
    "city": "Bel√©m",
    "zipcode": "66912-210",
    "sequence": 58
  },
  "BR257300548797C": {
    "address": "Rua Bahamas, 26\nBairro: Mangueiras (Mosqueiro)\nBel√©m - 66912-120",
    "latitude": -1.1521145,
    "longitude": -48.4601555,
    "city": "Bel√©m",
    "zipcode": "66912-120",
    "sequence": 59
  },
  "BR255604031541B": {
    "address": "Alameda do Carmo, 33, Pr√≥ximo a igreja Reis dos Reis\nBairro: Mangueiras (Mosqueiro)\nBel√©m - 66912-230",
    "latitude": -1.1513,
    "longitude": -48.4594002,
    "city": "Bel√©m",
    "zipcode": "66912-230",
    "sequence": 60
  },
  "BR258852981488Q": {
    "address": "Rua Nova, 255\nBairro: Mangueiras (Mosqueiro)\nBel√©m - 66912-080",
    "latitude": -1.1500554,
    "longitude": -48.461853,
    "city": "Bel√©m",
    "zipcode": "66912-080",
    "sequence": 61
  },
  "BR2530998956863": {
    "address": "Avenida Camilo Salgado Filho, 612, Centro Educacional L√°pis na M√£\nBairro: Mangueiras (Mosqueiro)\nBel√©m - 66912-250",
    "latitude": -1.1501131,
    "longitude": -48.4624329,
    "city": "Bel√©m",
    "zipcode": "66912-250",
    "sequence": 62
  },
  "BR2556101372242": {
    "address": "Rua do Carmo, 26\nBairro: Praia Grande (Mosqueiro)\nBel√©m - 66914-040",
    "latitude": -1.151163,
    "longitude": -48.4636841,
    "city": "Bel√©m",
    "zipcode": "66914-040",
    "sequence": 63
  },
  "BR257690813744P": {
    "address": "Rua Raimundo Cintra, 33, Atraz da panificadora Martinez\nBairro: Mangueiras (Mosqueiro)\nBel√©m - 66912-220",
    "latitude": -1.1497903,
    "longitude": -48.4638405,
    "city": "Bel√©m",
    "zipcode": "66912-220",
    "sequence": 64
  },
  "BR251048356165R": {
    "address": "Rua Bariloche, 17, Acesso pela sta terezinha\nBairro: Mangueiras (Mosqueiro)\nBel√©m - 66912-130",
    "latitude": -1.1482842,
    "longitude": -48.4596596,
    "city": "Bel√©m",
    "zipcode": "66912-130",
    "sequence": 65
  },
  "BR251297883486O": {
    "address": "Rua Bariloche, 17, Acesso pela rua santa Terezinh\nBairro: Mangueiras (Mosqueiro)\nBel√©m - 66912-130",
    "latitude": -1.1482842,
    "longitude": -48.4596596,
    "city": "Bel√©m",
    "zipcode": "66912-130",
    "sequence": 66
  },
  "BR2502916709275": {
    "address": "Ria nova, 195\nBairro: Mangueiras (Mosqueiro)\nBel√©m - 66912-060",
    "latitude": -1.1469001,
    "longitude": -48.4600983,
    "city": "Bel√©m",
    "zipcode": "66912-060",
    "sequence": 67
  },
  "BR250880859719J": {
    "address": "Avenida Principal, 14, Rua ao lado do varej√£o do cime\nBairro: Mangueiras (Mosqueiro)\nBel√©m - 66912-040",
    "latitude": -1.1448848,
    "longitude": -48.4607849,
    "city": "Bel√©m",
    "zipcode": "66912-040",
    "sequence": 68
  },
  "BR258628300510C": {
    "address": "Avenida Principal, 14, Rua ao lado do varej√£o do cime\nBairro: Mangueiras (Mosqueiro)\nBel√©m - 66912-040",
    "latitude": -1.1448848,
    "longitude": -48.4607849,
    "city": "Bel√©m",
    "zipcode": "66912-040",
    "sequence": 69
  },
  "BR257630269023H": {
    "address": "Avenida Principal, 14, Rua ao lado do varej√£o do cime\nBairro: Mangueiras (Mosqueiro)\nBel√©m - 66912-040",
    "latitude": -1.1448848,
    "longitude": -48.4607849,
    "city": "Bel√©m",
    "zipcode": "66912-040",
    "sequence": 70
  },
  "BR252728742822U": {
    "address": "Alameda Teres√≥polis, 182, Rua da creche\nBairro: Mangueiras (Mosqueiro)\nBel√©m - 66912-060",
    "latitude": -1.143436,
    "longitude": -48.4600372,
    "city": "Bel√©m",
    "zipcode": "66912-060",
    "sequence": 71
  },
  "BR255642613681K": {
    "address": "Alameda Petr√≥polis, 1000, Casa amarela con rosa\nBairro: Praia Grande (Mosqueiro)\nBel√©m - 66914-100",
    "latitude": -1.1434402,
    "longitude": -48.4619141,
    "city": "Bel√©m",
    "zipcode": "66914-100",
    "sequence": 72
  },
  "BR251146466899J": {
    "address": "Avenida Dezesseis de Novembro, 1220, Mundo dos colch√µes ao lado do\nBairro: Vila (Mosqueiro)\nBel√©m - 66910-140",
    "latitude": -1.1423743,
    "longitude": -48.461216,
    "city": "Bel√©m",
    "zipcode": "66910-140",
    "sequence": 73
  },
  "BR256373097735V": {
    "address": "Avenida Dezesseis de Novembro, 1220, Mundo dos colch√µes ao lado do\nBairro: Vila (Mosqueiro)\nBel√©m - 66910-140",
    "latitude": -1.1423743,
    "longitude": -48.461216,
    "city": "Bel√©m",
    "zipcode": "66910-140",
    "sequence": 74
  }
};
</script>

<!-- Google Maps -->
<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyApaDb9rSw2sNTaY7fjBqmrgjWYD9xwjcU&loading=async&callback=initMap&v=beta&libraries=places,geometry,marker,maps3d"></script>

<script>
'use strict';

/* ===========================
   GLOBAL VARIABLES
   =========================== */
let map;
let is3D = false;
let routeMode = false;
let currentInfoWindow = null;

// Legacy global variables (mantidas para compatibilidade)
let userLocationMarker = null;
let watchId = null;
let _animating3D = false;
let locationAccuracy = null;
let deliveryMarkers = {};
let directionsService = null;
let directionsRenderer = null;
let currentTween = null;
let markerCoords = { lat: 0, lng: 0 };

// IMPORTANTE: Inicializar array de polylines globalmente
if (!window.routePolylines) {
    window.routePolylines = [];
}

// ===========================
// FUN√á√ÉO DE DEBOUNCE (OTIMIZA√á√ÉO DE PERFORMANCE)
// ===========================
// Evita executar fun√ß√µes m√∫ltiplas vezes durante intera√ß√µes do mapa (drag, zoom, etc)
function debounce(func, wait = 500) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// ===========================
// MODO DE NAVEGA√á√ÉO EM TEMPO REAL
// ===========================
let navigationMode = {
    active: false,
    destination: null,
    destinationName: '',
    destinationMarker: null,
    destinationInfoWindow: null,
    lastHeading: 0,
    lastPosition: null,
    followInterval: null,
    lastRerouteTime: null, // Para controlar frequ√™ncia de rec√°lculo de rota
    userInteracting: false, // Flag para detectar intera√ß√£o do usu√°rio
    lastUserInteraction: null, // Timestamp da √∫ltima intera√ß√£o
    autoResumeTimeout: null // Timeout para retomar controle autom√°tico
};

// Marcar intera√ß√£o do usu√°rio durante navega√ß√£o (helper function)
// NOTA: Fun√ß√£o mantida para compatibilidade, mas n√£o √© mais necess√°ria
// pois o mapa est√° totalmente livre durante a navega√ß√£o
function markUserInteraction() {
    // Fun√ß√£o vazia - mapa sempre livre
}

// Detectar quando usu√°rio interage com o mapa durante navega√ß√£o
// NOTA: Fun√ß√£o mantida para compatibilidade, mas n√£o faz mais nada
// pois o mapa est√° totalmente livre durante a navega√ß√£o
function setupNavigationMapInteraction() {
    console.log('‚úÖ Modo de navega√ß√£o livre - usu√°rio tem controle total do mapa');
}

// Calcular heading (dire√ß√£o) entre duas posi√ß√µes
function calculateHeading(from, to) {
    const lat1 = from.lat * Math.PI / 180;
    const lat2 = to.lat * Math.PI / 180;
    const dLng = (to.lng - from.lng) * Math.PI / 180;

    const y = Math.sin(dLng) * Math.cos(lat2);
    const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLng);

    let heading = Math.atan2(y, x) * 180 / Math.PI;
    heading = (heading + 360) % 360; // Normalizar para 0-360

    return heading;
}

// Calcular dist√¢ncia entre duas posi√ß√µes em metros
function calculateDistanceMeters(from, to) {
    const R = 6371000; // Raio da Terra em metros
    const lat1 = from.lat * Math.PI / 180;
    const lat2 = to.lat * Math.PI / 180;
    const dLat = (to.lat - from.lat) * Math.PI / 180;
    const dLng = (to.lng - from.lng) * Math.PI / 180;

    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1) * Math.cos(lat2) *
              Math.sin(dLng/2) * Math.sin(dLng/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

    return R * c;
}

// Iniciar modo de navega√ß√£o
function startNavigationMode(destination, destinationName, marker = null, infoWindow = null) {
    navigationMode.active = true;
    navigationMode.destination = destination;
    navigationMode.destinationName = destinationName;
    navigationMode.destinationMarker = marker;
    navigationMode.destinationInfoWindow = infoWindow;
    navigationMode.lastPosition = null;

    console.log('üß≠ Modo de navega√ß√£o iniciado:', destinationName);

    // Fechar InfoWindow atual
    if (currentInfoWindow) {
        currentInfoWindow.close();
        currentInfoWindow = null;
    }

    // Mostrar bot√£o de parar navega√ß√£o
    const btnStopNav = document.getElementById('btnStopNavigation');
    if (btnStopNav) {
        btnStopNav.style.display = 'flex';
    }

    // Ocultar bot√£o adicionar cliente
    const btnAddClient = document.getElementById('btn-add-client');
    if (btnAddClient) {
        btnAddClient.style.display = 'none';
    }

    // Mostrar toast informativo
    showToast(
        'üß≠ Navega√ß√£o ativa',
        'Voc√™ pode mover o mapa livremente!',
        'info',
        4000
    );

    // Iniciar acompanhamento
    if (navigationMode.followInterval) {
        clearInterval(navigationMode.followInterval);
    }

    navigationMode.followInterval = setInterval(() => {
        updateNavigationView();
    }, 200); // Atualizar a cada 200ms para acompanhar em tempo real
}

// Parar modo de navega√ß√£o
function stopNavigationMode() {
    navigationMode.active = false;
    navigationMode.destination = null;
    navigationMode.destinationName = '';
    navigationMode.userInteracting = false; // Resetar flag de intera√ß√£o

    if (navigationMode.followInterval) {
        clearInterval(navigationMode.followInterval);
        navigationMode.followInterval = null;
    }

    // Limpar timeout de retomada autom√°tica
    if (navigationMode.autoResumeTimeout) {
        clearTimeout(navigationMode.autoResumeTimeout);
        navigationMode.autoResumeTimeout = null;
    }

    // Esconder bot√£o de parar navega√ß√£o
    const btnStopNav = document.getElementById('btnStopNavigation');
    if (btnStopNav) {
        btnStopNav.style.display = 'none';
    }

    // Mostrar bot√£o adicionar cliente novamente
    const btnAddClient = document.getElementById('btn-add-client');
    if (btnAddClient) {
        btnAddClient.style.display = 'flex';
    }

    // Limpar linha azul do trajeto
    if (window.routePolylines && window.routePolylines.length > 0) {
        window.routePolylines.forEach(polyline => {
            if (polyline && polyline.setMap) {
                polyline.setMap(null);
            }
        });
        window.routePolylines = [];
    }

    // Resetar rota√ß√£o e inclina√ß√£o do mapa
    if (map) {
        if (map.setHeading) {
            map.setHeading(0);
        }
        if (map.setTilt) {
            map.setTilt(0);
        }
    }

    console.log('üõë Modo de navega√ß√£o encerrado');

    showToast(
        'üõë Navega√ß√£o encerrada',
        'Modo de acompanhamento desativado',
        'info',
        3000
    );
}

// REC√ÅLCULO AUTOM√ÅTICO DE ROTA (quando sai do trajeto)
// ‚ú® Fun√ß√£o original (ser√° chamada com debounce)
async function checkAndRerouteIfNeededCore(currentPos) {
    // S√≥ verifica se h√° uma rota ativa
    if (!window.routePolylines || window.routePolylines.length === 0) return;

    const routePath = window.routePolylines[0].getPath();
    if (!routePath || routePath.getLength() === 0) return;

    // Calcular dist√¢ncia m√≠nima at√© a linha da rota
    let minDistance = Infinity;
    for (let i = 0; i < routePath.getLength(); i++) {
        const point = routePath.getAt(i);
        const distance = calculateDistanceMeters(currentPos, { lat: point.lat(), lng: point.lng() });
        if (distance < minDistance) {
            minDistance = distance;
        }
    }

    // Se est√° a mais de 50 metros da rota, recalcular
    const REROUTE_THRESHOLD = 50; // metros

    if (minDistance > REROUTE_THRESHOLD) {
        // Evitar rec√°lculos muito frequentes (apenas 1 vez a cada 10 segundos)
        const now = Date.now();
        if (!navigationMode.lastRerouteTime || (now - navigationMode.lastRerouteTime) > 10000) {
            navigationMode.lastRerouteTime = now;

            console.log(`üîÑ Fora da rota (${minDistance.toFixed(0)}m). Recalculando...`);

            showToast(
                'üîÑ Recalculando rota...',
                'Voc√™ saiu do trajeto planejado',
                'info',
                2000
            );

            // Recalcular rota do ponto atual at√© o destino
            await recalculateRoute(currentPos, navigationMode.destination);
        }
    }
}

// ‚ú® Vers√£o com debounce (evita rec√°lculos excessivos durante movimenta√ß√£o)
const checkAndRerouteIfNeeded = debounce(checkAndRerouteIfNeededCore, 500);

// Recalcular rota com nova origem
async function recalculateRoute(origin, destination) {
    try {
        const directionsService = new google.maps.DirectionsService();

        const request = {
            origin: origin,
            destination: destination,
            travelMode: google.maps.TravelMode.DRIVING,
            optimizeWaypoints: false,
            language: 'pt-BR',
            region: 'BR'
        };

        const result = await directionsService.route(request);

        if (result.status === 'OK') {
            // Limpar rota antiga
            if (window.routePolylines && window.routePolylines.length > 0) {
                window.routePolylines.forEach(polyline => {
                    if (polyline.setMap) {
                        polyline.setMap(null);
                    }
                });
                window.routePolylines = [];
            }

            // Desenhar nova rota
            const route = result.routes[0];
            const leg = route.legs[0];

            const polyline = new google.maps.Polyline({
                path: route.overview_path,
                geodesic: true,
                strokeColor: '#4285f4',
                strokeOpacity: 0.8,
                strokeWeight: 5,
                map: map
            });

            window.routePolylines = [polyline];

            // Formatar dist√¢ncia e dura√ß√£o
            const distance = leg.distance.text;
            const duration = leg.duration.text;

            showToast(
                '‚úÖ Nova rota calculada',
                `üìè ${distance} ‚Ä¢ ‚è±Ô∏è ${duration}`,
                'success',
                3000
            );

            console.log('‚úÖ Rota recalculada:', {
                distance: leg.distance,
                duration: leg.duration
            });

        } else {
            console.error('Erro ao recalcular rota:', result.status);
        }

    } catch (error) {
        console.error('Erro ao recalcular rota:', error);
    }
}

// Atualizar visualiza√ß√£o durante navega√ß√£o
function updateNavigationView() {
    if (!navigationMode.active || !navigationMode.destination) return;

    // Obter posi√ß√£o atual do GPS
    let currentPos = null;
    if (gpsTracker && gpsTracker.marker) {
        const pos = gpsTracker.marker.position || (gpsTracker.marker.getPosition && gpsTracker.marker.getPosition());
        if (pos) {
            currentPos = { lat: pos.lat, lng: pos.lng };
        }
    } else if (userLocationMarker) {
        const pos = userLocationMarker.position || (userLocationMarker.getPosition && userLocationMarker.getPosition());
        if (pos) {
            currentPos = { lat: pos.lat, lng: pos.lng };
        }
    }

    if (!currentPos) return;

    // Calcular dist√¢ncia at√© o destino
    const distanceToDestination = calculateDistanceMeters(currentPos, navigationMode.destination);

    // VERIFICAR SE EST√Å FORA DA ROTA (Rec√°lculo autom√°tico)
    checkAndRerouteIfNeeded(currentPos);

    // Verificar se chegou ao destino (< 30 metros)
    if (distanceToDestination < 30) {
        // Salvar refer√™ncias antes de parar navega√ß√£o
        const arrivedMarker = navigationMode.destinationMarker;
        const arrivedInfoWindow = navigationMode.destinationInfoWindow;
        const arrivedDestination = navigationMode.destination;

        showToast(
            'üéâ Voc√™ chegou!',
            `Destino: ${navigationMode.destinationName}`,
            'success',
            5000
        );

        stopNavigationMode();

        // Reabrir InfoWindow do destino ap√≥s pequeno delay
        setTimeout(() => {
            if (arrivedInfoWindow && arrivedMarker) {
                // Centralizar no destino
                if (arrivedDestination) {
                    map.panTo(arrivedDestination);
                    map.setZoom(18);
                }
                // Abrir InfoWindow
                arrivedInfoWindow.open(map, arrivedMarker);
                currentInfoWindow = arrivedInfoWindow;
            }
        }, 500);

        return;
    }

    // ‚ú® NAVEGA√á√ÉO SEM CONTROLE AUTOM√ÅTICO DO MAPA
    // O mapa agora fica TOTALMENTE livre para o usu√°rio controlar
    // Apenas mantemos o tracking de dist√¢ncia e verifica√ß√£o de chegada
    navigationMode.lastPosition = currentPos;

    console.log(`üìç Navega√ß√£o ativa - Dist√¢ncia at√© destino: ${Math.round(distanceToDestination)}m`);
}

// Loop de anima√ß√£o Tween.js (sincronizado com requestAnimationFrame)
function animateTweens(time) {
    requestAnimationFrame(animateTweens);
    TWEEN.update(time);
}
requestAnimationFrame(animateTweens);

/* ===========================
   M√ìDULO: GPS TRACKER (HIGH PRECISION)
   =========================== */
class GPSTracker {
    constructor() {
        this.marker = null;
        this.watchId = null;
        this.accuracy = null;
        this.positionHistory = [];
        this.lastUpdate = 0;
        this.currentTween = null;
        this.markerCoords = { lat: 0, lng: 0 };
        this.animationFrameId = null; // Para anima√ß√£o suave com requestAnimationFrame

        // Kalman Filter state
        this.kalman = {
            lat: null,
            lng: null,
            variance: null // Incerteza estimada
        };
        this.kalmanQ = 0.1; // MUITO ALTO - confiar quase totalmente nas novas leituras
        this.lastGoodPosition = null;
        this.consecutiveGoodReadings = 0;

        // Configura√ß√µes ULTRA AGRESSIVAS para rastreamento instant√¢neo de ve√≠culo
        this.config = {
            updateThrottle: 0,          // SEM throttle - atualizar IMEDIATAMENTE
            maxAccuracyThreshold: 500,  // Aceitar qualquer leitura at√© 500m
            targetAccuracy: 50,         // Meta relaxada para ve√≠culo
            historySize: 1,             // Sem hist√≥rico - usar √∫ltima leitura
            highAccuracy: true,
            timeout: 30000,             // Timeout 30s para n√£o perder leituras
            maximumAge: 0,              // Sempre dados frescos
            minReadingsForStable: 1     // 1 leitura √© suficiente
        };
    }

    async start() {
        if (!navigator.geolocation) {
            throw new Error('Geolocaliza√ß√£o n√£o suportada');
        }

        const options = {
            enableHighAccuracy: this.config.highAccuracy,
            timeout: this.config.timeout,
            maximumAge: this.config.maximumAge
        };

        return new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    this.createMarker(position);
                    this.startWatching(options);
                    resolve(position);
                },
                (error) => reject(error),
                options
            );
        });
    }

    createMarker(position) {
        const coords = {
            lat: position.coords.latitude,
            lng: position.coords.longitude
        };

        this.accuracy = position.coords.accuracy;
        this.markerCoords = coords;

        // Container principal do marcador
        const markerDiv = document.createElement('div');
        markerDiv.className = 'location-marker active';

        // Anel de precis√£o (pulso)
        const pulseDiv = document.createElement('div');
        pulseDiv.className = 'location-marker-pulse';
        markerDiv.appendChild(pulseDiv);

        // Bolinha azul central
        const dotDiv = document.createElement('div');
        dotDiv.className = 'location-marker-dot';
        markerDiv.appendChild(dotDiv);

        // Guardar refer√™ncias para contra-rota√ß√£o
        this.markerElement = markerDiv;
        this.pulseElement = pulseDiv;
        this.dotElement = dotDiv;

        if (google.maps.marker && google.maps.marker.AdvancedMarkerElement) {
            this.marker = new google.maps.marker.AdvancedMarkerElement({
                map: map,
                position: coords,
                content: markerDiv,
                title: "Sua Localiza√ß√£o"
            });
        } else {
            this.marker = new google.maps.Marker({
                map: map,
                position: coords,
                title: "Sua Localiza√ß√£o",
                icon: {
                    path: google.maps.SymbolPath.CIRCLE,
                    scale: 8,
                    fillColor: "#4285f4",
                    fillOpacity: 1,
                    strokeColor: "white",
                    strokeWeight: 3
                }
            });
        }

        // Atualizar refer√™ncias globais (compatibilidade)
        userLocationMarker = this.marker;
        locationAccuracy = this.accuracy;
        markerCoords = this.markerCoords;

        // Listener para contra-rotacionar o marcador quando o mapa gira
        // Mant√©m o marcador sempre na posi√ß√£o fixa (n√£o gira com o mapa)
        this.headingListener = map.addListener('heading_changed', () => {
            this.counterRotateMarker();
        });

        // Aplicar contra-rota√ß√£o inicial
        this.counterRotateMarker();
    }

    // Contra-rotaciona o marcador para manter orienta√ß√£o fixa
    counterRotateMarker() {
        if (!this.pulseElement || !this.dotElement) return;

        const heading = map.getHeading() || 0;
        // Aplicar rota√ß√£o inversa aos elementos internos
        this.pulseElement.style.transform = `translate(-50%, -50%) rotate(${-heading}deg)`;
        this.dotElement.style.transform = `translate(-50%, -50%) rotate(${-heading}deg)`;
    }

    startWatching(options) {
        this.watchId = navigator.geolocation.watchPosition(
            (position) => this.updatePosition(position),
            (error) => this.handleError(error),
            options
        );
        watchId = this.watchId; // Compatibilidade global
    }

    updatePosition(position) {
        const accuracy = position.coords.accuracy;
        const lat = position.coords.latitude;
        const lng = position.coords.longitude;

        // Usar posi√ß√£o direta
        const newPos = { lat, lng };

        // Atualizar marcador com anima√ß√£o suave
        if (this.marker) {
            this.animateMarkerSmooth(newPos);
            this.accuracy = accuracy;
            locationAccuracy = accuracy;

            // Indicador visual de qualidade do sinal
            const qualityIcon = accuracy <= 10 ? 'üéØ' : accuracy <= 30 ? 'üìç' : 'üì°';
            updateStatus(`${qualityIcon} GPS: ${accuracy.toFixed(0)}m`, true);
        }
    }

    // Anima√ß√£o suave usando requestAnimationFrame (como Google Maps)
    animateMarkerSmooth(newPosition) {
        if (!this.marker) return;

        // Cancelar anima√ß√£o anterior se existir
        if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
        }

        const startPos = { ...this.markerCoords };
        const endPos = newPosition;
        const duration = 250; // 250ms - suave mas r√°pido
        const startTime = performance.now();

        // Se √© a primeira posi√ß√£o, definir diretamente
        if (startPos.lat === 0 && startPos.lng === 0) {
            this.markerCoords = endPos;
            markerCoords = endPos;
            this.setMarkerPosition(endPos);
            return;
        }

        const animate = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);

            // Easing suave (ease-out cubic)
            const easeProgress = 1 - Math.pow(1 - progress, 3);

            // Interpolar posi√ß√£o
            const currentPos = {
                lat: startPos.lat + (endPos.lat - startPos.lat) * easeProgress,
                lng: startPos.lng + (endPos.lng - startPos.lng) * easeProgress
            };

            // Atualizar marcador
            this.setMarkerPosition(currentPos);
            this.markerCoords = currentPos;
            markerCoords = currentPos;

            // Continuar anima√ß√£o se n√£o terminou
            if (progress < 1) {
                this.animationFrameId = requestAnimationFrame(animate);
            } else {
                // Garantir posi√ß√£o final exata
                this.markerCoords = endPos;
                markerCoords = endPos;
                this.setMarkerPosition(endPos);
                this.animationFrameId = null;
            }
        };

        this.animationFrameId = requestAnimationFrame(animate);
    }

    // Fun√ß√£o auxiliar para definir posi√ß√£o do marcador
    setMarkerPosition(position) {
        if (!this.marker) return;

        if (this.marker.position !== undefined) {
            // AdvancedMarkerElement
            this.marker.position = position;
        } else if (this.marker.setPosition) {
            // Marker cl√°ssico
            this.marker.setPosition(position);
        }
    }

    // Filtro de Kalman 1D aplicado a lat/lng
    applyKalmanFilter(lat, lng, accuracy) {
        // Vari√¢ncia da medi√ß√£o (baseada na precis√£o GPS)
        const measurementVariance = accuracy * accuracy;

        // Primeira medi√ß√£o - inicializar
        if (this.kalman.lat === null) {
            this.kalman.lat = lat;
            this.kalman.lng = lng;
            this.kalman.variance = measurementVariance;
            return { lat, lng };
        }

        // Predi√ß√£o: aumentar incerteza com o tempo
        this.kalman.variance += this.kalmanQ;

        // Ganho de Kalman: quanto confiar na nova medi√ß√£o
        const kalmanGain = this.kalman.variance / (this.kalman.variance + measurementVariance);

        // Atualiza√ß√£o: combinar predi√ß√£o com medi√ß√£o
        this.kalman.lat = this.kalman.lat + kalmanGain * (lat - this.kalman.lat);
        this.kalman.lng = this.kalman.lng + kalmanGain * (lng - this.kalman.lng);

        // Atualizar vari√¢ncia
        this.kalman.variance = (1 - kalmanGain) * this.kalman.variance;

        return {
            lat: this.kalman.lat,
            lng: this.kalman.lng
        };
    }

    calculateSmoothedPosition() {
        if (this.positionHistory.length === 0) return null;

        // Se temos uma posi√ß√£o est√°vel recente, usar ela
        if (this.lastGoodPosition && this.consecutiveGoodReadings >= this.config.minReadingsForStable) {
            return {
                lat: this.lastGoodPosition.lat,
                lng: this.lastGoodPosition.lng
            };
        }

        if (this.positionHistory.length === 1) {
            return {
                lat: this.positionHistory[0].lat,
                lng: this.positionHistory[0].lng
            };
        }

        // M√©dia ponderada com peso exponencial (leituras recentes valem mais)
        let totalWeight = 0;
        let weightedLat = 0;
        let weightedLng = 0;

        this.positionHistory.forEach((pos, index) => {
            // Peso baseado na precis√£o E na rec√™ncia
            const recencyWeight = Math.pow(1.5, index); // Mais recente = maior peso
            const accuracyWeight = 1 / (pos.accuracy + 1);
            const weight = recencyWeight * accuracyWeight;

            weightedLat += pos.lat * weight;
            weightedLng += pos.lng * weight;
            totalWeight += weight;
        });

        return {
            lat: weightedLat / totalWeight,
            lng: weightedLng / totalWeight
        };
    }

    animateMarkerTo(newPosition, duration = 600) {
        if (!this.marker) return;

        // Primeira posi√ß√£o - sem anima√ß√£o
        if (this.markerCoords.lat === 0 && this.markerCoords.lng === 0) {
            this.markerCoords = newPosition;
            markerCoords = newPosition; // Atualizar global
            if (this.marker.position !== undefined) {
                this.marker.position = newPosition;
            } else if (this.marker.setPosition) {
                this.marker.setPosition(newPosition);
            }
            return;
        }

        // Parar anima√ß√£o anterior
        if (this.currentTween) {
            this.currentTween.stop();
        }
        if (currentTween) {
            currentTween.stop();
        }

        // Animar com Tween.js - Linear para movimento mais direto
        this.currentTween = new TWEEN.Tween(this.markerCoords)
            .to(newPosition, duration)
            .easing(TWEEN.Easing.Linear.None) // Linear para movimento mais natural de ve√≠culo
            .onUpdate(() => {
                const pos = {
                    lat: this.markerCoords.lat,
                    lng: this.markerCoords.lng
                };
                if (this.marker.position !== undefined) {
                    this.marker.position = pos;
                } else if (this.marker.setPosition) {
                    this.marker.setPosition(pos);
                }
                markerCoords = this.markerCoords; // Sync global
            })
            .start();

        currentTween = this.currentTween; // Atualizar global
    }

    centerOnUser() {
        if (this.marker) {
            const position = this.marker.position || this.marker.getPosition();
            if (position) {
                map.panTo(position);
            }
        }
    }

    handleError(error) {
        console.warn('GPS Error:', error);
    }

    stop() {
        if (this.watchId) {
            navigator.geolocation.clearWatch(this.watchId);
            this.watchId = null;
            watchId = null;
        }

        // Remover listener de heading
        if (this.headingListener) {
            google.maps.event.removeListener(this.headingListener);
            this.headingListener = null;
        }
    }

    getPosition() {
        if (!this.marker) return null;
        return this.marker.position || this.marker.getPosition();
    }

    getAccuracy() {
        return this.accuracy;
    }
}

// Inst√¢ncia global do GPS Tracker
let gpsTracker = null;

/* ===========================
   M√ìDULO: LAZY LOADER
   =========================== */
class LazyLoader {
    constructor() {
        this.loadedScripts = new Set();
        this.loadingPromises = new Map();
    }

    async loadScript(url, name) {
        // Se j√° foi carregado, retornar imediatamente
        if (this.loadedScripts.has(name)) {
            return Promise.resolve();
        }

        // Se est√° sendo carregado, retornar a promise existente
        if (this.loadingPromises.has(name)) {
            return this.loadingPromises.get(name);
        }

        // Criar nova promise de carregamento
        const loadingPromise = new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = url;
            script.async = true;

            script.onload = () => {
                this.loadedScripts.add(name);
                this.loadingPromises.delete(name);
                console.log(`‚úÖ [LAZY] ${name} carregado (economizou tempo de inicializa√ß√£o)`);
                resolve();
            };

            script.onerror = () => {
                this.loadingPromises.delete(name);
                console.error(`‚ùå [LAZY] Erro ao carregar ${name}`);
                reject(new Error(`Failed to load ${name}`));
            };

            document.head.appendChild(script);
        });

        this.loadingPromises.set(name, loadingPromise);
        return loadingPromise;
    }

    async loadJsQR() {
        return this.loadScript(
            'https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js',
            'jsQR'
        );
    }

    isLoaded(name) {
        return this.loadedScripts.has(name);
    }
}

// Inst√¢ncia global do Lazy Loader
const lazyLoader = new LazyLoader();

const MAP_ID = "ebb7ca4503045feabc75b373";

// IMPORTANTE: Substitua pelo seu Project ID do Google Cloud Platform
// Encontre em: https://console.cloud.google.com/ ‚Üí Configura√ß√µes do projeto
const GOOGLE_CLOUD_PROJECT_ID = "mapas-clientes-479801"; // ‚úÖ Configurado!
const GOOGLE_MAPS_API_KEY = "AIzaSyApaDb9rSw2sNTaY7fjBqmrgjWYD9xwjcU"; // API Key para Fleet Routing

// ===========================
// SISTEMA DE NOTIFICA√á√ïES
// ===========================

function showToast(title, message, type = 'info', duration = 4000) {
    const container = document.getElementById('toast-container');
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;

    const icons = {
        success: '‚úì',
        error: '‚úï',
        warning: '‚ö†',
        info: '‚Ñπ'
    };

    toast.innerHTML = `
        <div class="toast-icon">${icons[type] || icons.info}</div>
        <div class="toast-content">
            <div class="toast-title">${title}</div>
            ${message ? `<div class="toast-message">${message}</div>` : ''}
        </div>
    `;

    container.appendChild(toast);

    setTimeout(() => {
        toast.classList.add('hiding');
        setTimeout(() => toast.remove(), 300);
    }, duration);
}

function updateLoadingScreen(text, subtext) {
    document.getElementById('loading-text').textContent = text;
    document.getElementById('loading-subtext').textContent = subtext;
}

function hideLoadingScreen() {
    const loadingScreen = document.getElementById('loading-screen');
    const mapElement = document.getElementById('map');
    const controls = document.querySelector('.map-control');

    loadingScreen.classList.add('hidden');
    mapElement.classList.add('loaded');
    controls.classList.add('visible');

    setTimeout(() => {
        document.getElementById('status-bar').classList.add('visible');
    }, 500);
}

function updateStatus(text, active = true) {
    document.getElementById('status-text').textContent = text;
    const indicator = document.getElementById('status-indicator');

    if (active) {
        indicator.classList.remove('inactive');
    } else {
        indicator.classList.add('inactive');
    }
}

// ===========================
// INICIALIZA√á√ÉO DO MAPA
// ===========================

// Adicionar bot√£o de GPS customizado (estilo Google Maps)
function addGPSCenterButton() {
    // Criar bot√£o
    const gpsCenterButton = document.createElement('button');
    gpsCenterButton.className = 'gps-center-button';
    gpsCenterButton.type = 'button';
    gpsCenterButton.title = 'Centralizar na minha localiza√ß√£o';

    // √çcone Material Icons
    const icon = document.createElement('i');
    icon.className = 'material-icons';
    icon.textContent = 'gps_fixed'; // √çcone de GPS/mira
    gpsCenterButton.appendChild(icon);

    // Adicionar evento de clique
    gpsCenterButton.addEventListener('click', () => {
        // Usar GPS Tracker modular se dispon√≠vel
        if (gpsTracker) {
            gpsTracker.centerOnUser();
            gpsCenterButton.classList.add('active');

            showToast('Centralizado', 'Mapa centralizado na sua localiza√ß√£o', 'info', 2000);

            // Remover classe active ap√≥s 2 segundos
            setTimeout(() => {
                gpsCenterButton.classList.remove('active');
            }, 2000);
            return;
        }

        // Fallback para c√≥digo legado
        if (!userLocationMarker) {
            showToast('Localiza√ß√£o n√£o dispon√≠vel', 'Aguarde obter sua posi√ß√£o GPS', 'warning', 3000);
            return;
        }

        // Pega a posi√ß√£o atual do marcador (compat√≠vel com ambos os tipos)
        let currentPosition;
        if (userLocationMarker.position) {
            currentPosition = userLocationMarker.position;
        } else if (userLocationMarker.getPosition) {
            currentPosition = userLocationMarker.getPosition();
        }

        if (!currentPosition) {
            showToast('Erro ao centralizar', 'Posi√ß√£o n√£o encontrada', 'error', 3000);
            return;
        }

        // Anima o zoom e centraliza
        map.panTo(currentPosition);
        map.setZoom(17);

        gpsCenterButton.classList.add('active');
        showToast('Centralizado', 'Mapa centralizado na sua localiza√ß√£o', 'info', 2000);

        // Remover classe active ap√≥s 2 segundos
        setTimeout(() => {
            gpsCenterButton.classList.remove('active');
        }, 2000);
    });

    // Adicionar ao mapa usando controls API do Google Maps
    map.controls[google.maps.ControlPosition.RIGHT_BOTTOM].push(gpsCenterButton);
}

window.initMap = function () {
    console.log('üöÄüöÄüöÄ VERS√ÉO COM MAPA LIVRE v2.0 - Iniciando mapa...');
    updateLoadingScreen('Carregando mapa...', 'Preparando visualiza√ß√£o');

    try {
        map = new google.maps.Map(document.getElementById("map"), {
            center: {lat: -23.5505, lng: -46.6333},
            zoom: 17,
            mapId: MAP_ID,
            tilt: 0,
            heading: 0,
            gestureHandling: "greedy",
            rotateControl: true,
            zoomControl: true,
            streetViewControl: false,
            fullscreenControl: true,
            // Otimiza√ß√µes de performance
            disableDefaultUI: false,
            clickableIcons: false, // Desabilita cliques em POIs para melhor performance
            minZoom: 3, // Permite zoom global
            maxZoom: 22 // Zoom m√°ximo detalhado
        });

        // Inicializar servi√ßos de rota
        directionsService = new google.maps.DirectionsService();
        directionsRenderer = new google.maps.DirectionsRenderer({
            map: map,
            suppressMarkers: false, // N√£o suprimir marcadores (A, B, C, etc.)
            polylineOptions: {
                strokeColor: '#4285f4',
                strokeWeight: 5,
                strokeOpacity: 0.7
            }
        });

        // Adicionar bot√£o de centralizar localiza√ß√£o (estilo Google Maps)
        addGPSCenterButton();

        // Configurar detec√ß√£o de intera√ß√£o do usu√°rio durante navega√ß√£o
        setupNavigationMapInteraction();

        // Fechar InfoWindow ao clicar no mapa (fora dos marcadores)
        map.addListener('click', () => {
            if (currentInfoWindow) {
                currentInfoWindow.close();
                currentInfoWindow = null;
            }
        });

        console.log('Mapa criado, aguardando tiles...');

        // Timeout de seguran√ßa: se o mapa n√£o carregar em 15s, for√ßa o in√≠cio do tracking
        const safetyTimeout = setTimeout(() => {
            console.warn('Timeout: for√ßando in√≠cio do tracking de localiza√ß√£o');
            updateLoadingScreen('Obtendo sua localiza√ß√£o...', 'Ative o GPS para melhor precis√£o');
            startLocationTracking();
        }, 15000);

        // Espera o mapa carregar completamente
        google.maps.event.addListenerOnce(map, 'tilesloaded', () => {
            clearTimeout(safetyTimeout);
            console.log('Tiles carregados, iniciando tracking...');
            updateLoadingScreen('Obtendo sua localiza√ß√£o...', 'Ative o GPS para melhor precis√£o');
            startLocationTracking();
        });
    } catch (error) {
        console.error('Erro ao criar mapa:', error);
        hideLoadingScreen();
        showToast('Erro ao inicializar mapa', error.message, 'error', 8000);
    }
}

// ===========================
// RASTREAMENTO EM TEMPO REAL
// ===========================

async function startLocationTracking() {
    console.log('‚úÖ [MODULAR] Iniciando GPS Tracker...');

    try {
        // Criar inst√¢ncia do GPS Tracker modular
        gpsTracker = new GPSTracker();

        // Iniciar rastreamento
        const position = await gpsTracker.start();

        console.log('‚úÖ Posi√ß√£o obtida:', position.coords.latitude, position.coords.longitude);

        // Centralizar mapa na posi√ß√£o
        map.setCenter({
            lat: position.coords.latitude,
            lng: position.coords.longitude
        });
        map.setZoom(17);

        // Esconder loading screen
        hideLoadingScreen();
        showAddClientButton();

        showToast(
            'Localiza√ß√£o obtida!',
            `Precis√£o: ${Math.round(position.coords.accuracy)}m`,
            'success',
            3000
        );

        console.log('‚úÖ GPS Tracker iniciado com sucesso!');

    } catch (error) {
        console.error('‚ùå Erro ao iniciar GPS:', error);
        hideLoadingScreen();
        handleGeoError(error, true);
    }
}

// ===========================
// FUN√á√ïES GPS ANTIGAS REMOVIDAS
// Agora todas dentro da classe GPSTracker
// ===========================

function handleGeoError(error, isInitial = false) {
    console.warn("Erro de geolocaliza√ß√£o:", error);

    let errorTitle = 'Erro de GPS';
    let errorMessage = '';

    switch(error.code) {
        case error.PERMISSION_DENIED:
            errorTitle = 'Permiss√£o negada';
            errorMessage = 'Por favor, permita o acesso √† localiza√ß√£o';
            break;
        case error.POSITION_UNAVAILABLE:
            errorTitle = 'Localiza√ß√£o indispon√≠vel';
            errorMessage = 'N√£o foi poss√≠vel obter sua posi√ß√£o';
            break;
        case error.TIMEOUT:
            errorTitle = 'Tempo esgotado';
            errorMessage = 'A solicita√ß√£o demorou muito. Tentando novamente...';
            break;
        default:
            errorMessage = 'Erro desconhecido ao obter localiza√ß√£o';
    }

    showToast(errorTitle, errorMessage, 'error', 6000);
    updateStatus('GPS com erro', false);

    if (isInitial) {
        map.setCenter({ lat: -23.5505, lng: -46.6333 });
    }
}

// ===========================
// MARCADORES DE ENTREGAS
// ===========================

// Fun√ß√£o auxiliar para criar SVG de pin do Google Maps com n√∫mero (suporta 1-99)
function createPinSVG(number) {
    // Ajustar tamanho da fonte baseado no n√∫mero de d√≠gitos
    const fontSize = number >= 10 ? '11' : '13';

    // SVG do pin do Google Maps (formato teardrop/gota invertida)
    const svg = `
        <svg width="32" height="44" viewBox="0 0 32 44" xmlns="http://www.w3.org/2000/svg">
            <!-- Sombra -->
            <ellipse cx="16" cy="42" rx="6.5" ry="2" fill="rgba(0,0,0,0.35)"/>

            <!-- Pin vermelho com gradiente sutil -->
            <defs>
                <linearGradient id="pinGradient${number}" x1="0%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" style="stop-color:#EA4335;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#C5221F;stop-opacity:1" />
                </linearGradient>
            </defs>
            <path d="M16 0 C7.164 0 0 7.164 0 16 C0 28 16 44 16 44 S32 28 32 16 C32 7.164 24.836 0 16 0 Z"
                  fill="url(#pinGradient${number})"
                  stroke="#FFFFFF"
                  stroke-width="2"/>

            <!-- C√≠rculo branco interno maior -->
            <circle cx="16" cy="16" r="10" fill="#FFFFFF"/>

            <!-- Sombra interna sutil no c√≠rculo -->
            <circle cx="16" cy="16" r="10" fill="none" stroke="rgba(0,0,0,0.08)" stroke-width="0.5"/>

            <!-- N√∫mero com contorno para melhor legibilidade -->
            <text x="16" y="17"
                  text-anchor="middle"
                  dominant-baseline="central"
                  font-family="'Arial Black', Arial, sans-serif"
                  font-size="${fontSize}"
                  font-weight="900"
                  fill="#EA4335"
                  stroke="#FFFFFF"
                  stroke-width="0.8"
                  paint-order="stroke">${number}</text>
        </svg>
    `;

    return 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(svg);
}

// Fun√ß√£o para marcar entregas como conclu√≠das
async function markAsDelivered(deliveries, client, marker, coordKey, deliveredBtn) {
    try {
        console.log('üì¶ Marcando entregas como conclu√≠das:', deliveries);

        // Atualizar status no Supabase para cada entrega
        const deliveryIds = deliveries.map(d => d.id);

        const { error } = await supabase
            .from('delivery_data')
            .update({
                status: 'delivered',
                delivered_at: new Date().toISOString()
            })
            .in('id', deliveryIds);

        if (error) {
            console.error('Erro ao atualizar Supabase:', error);
            throw error;
        }

        console.log(`‚úÖ ${deliveryIds.length} entrega(s) atualizada(s) no banco de dados`);

        // Marcar como entregue (tornar cinza e semi-transparente)
        if (marker) {
            marker.isDelivered = true; // Flag para identificar marcadores entregues

            // Salvar informa√ß√µes originais para poder desfazer
            if (!marker.originalState) {
                marker.originalState = {
                    deliveries: deliveries,
                    client: client,
                    coordKey: coordKey,
                    isGreen: !!client // Se tem client, √© verde
                };
            }

            // Tornar o marcador cinza e semi-transparente
            if (marker.content) {
                // AdvancedMarkerElement com conte√∫do personalizado
                const markerElement = marker.content;
                markerElement.style.opacity = '0.4';
                markerElement.style.filter = 'grayscale(100%)';

                // Se for marcador verde (pin customizado), mudar cor para cinza
                const pinDiv = markerElement.querySelector('div');
                if (pinDiv) {
                    pinDiv.style.background = '#9E9E9E'; // Cinza
                    const innerCircle = pinDiv.querySelector('div');
                    if (innerCircle) {
                        innerCircle.style.color = '#9E9E9E';
                    }
                }
            } else if (marker.setIcon) {
                // Marker cl√°ssico - mudar para √≠cone cinza
                const currentIcon = marker.getIcon();
                if (currentIcon && currentIcon.path) {
                    marker.setIcon({
                        ...currentIcon,
                        fillColor: '#9E9E9E',
                        strokeColor: '#757575'
                    });
                } else if (currentIcon && currentIcon.url) {
                    // Marcador vermelho com SVG - recriar em cinza
                    const deliveryCount = deliveries.length;
                    marker.setIcon({
                        url: createPinSVG(deliveryCount, '#9E9E9E'),
                        scaledSize: new google.maps.Size(32, 44),
                        anchor: new google.maps.Point(16, 44)
                    });
                }
                marker.setOpacity(0.4);
            }
        }

        // Atualizar o bot√£o para "Desfazer"
        if (deliveredBtn) {
            deliveredBtn.innerHTML = '‚Ü© Desfazer';
            deliveredBtn.style.background = '#FF9800'; // Laranja
            deliveredBtn.removeEventListener('mouseenter', deliveredBtn._hoverIn);
            deliveredBtn.removeEventListener('mouseleave', deliveredBtn._hoverOut);
            deliveredBtn._hoverIn = () => { deliveredBtn.style.background = '#F57C00'; };
            deliveredBtn._hoverOut = () => { deliveredBtn.style.background = '#FF9800'; };
            deliveredBtn.addEventListener('mouseenter', deliveredBtn._hoverIn);
            deliveredBtn.addEventListener('mouseleave', deliveredBtn._hoverOut);
        }

        // Obter posi√ß√£o do marcador atual para encontrar o mais pr√≥ximo
        let currentMarkerPosition = null;
        if (marker) {
            if (marker.position) {
                currentMarkerPosition = marker.position;
            } else if (marker.getPosition) {
                currentMarkerPosition = marker.getPosition();
            }
        }

        // Fechar InfoWindow
        if (currentInfoWindow) {
            currentInfoWindow.close();
            currentInfoWindow = null;
        }

        // Toast de sucesso
        showToast(
            '‚úÖ Entrega conclu√≠da!',
            `${deliveries.length} pacote${deliveries.length > 1 ? 's' : ''} marcado${deliveries.length > 1 ? 's' : ''} como entregue${deliveries.length > 1 ? 's' : ''}`,
            'success',
            3000
        );

        // Navegar para o pr√≥ximo marcador mais pr√≥ximo
        await navigateToNextMarker(currentMarkerPosition);

    } catch (error) {
        console.error('Erro ao marcar entregas:', error);
        showToast(
            '‚ùå Erro ao marcar entrega',
            error.message || 'N√£o foi poss√≠vel atualizar o status',
            'error',
            4000
        );
    }
}

// Fun√ß√£o para desfazer a marca√ß√£o de entrega
async function undoDelivery(marker, deliveredBtn) {
    try {
        if (!marker.originalState) {
            console.error('Estado original n√£o encontrado');
            return;
        }

        const { deliveries, client, coordKey, isGreen } = marker.originalState;
        console.log('‚Ü© Desfazendo marca√ß√£o de entrega:', deliveries);

        // Atualizar status no Supabase de volta para pending
        const deliveryIds = deliveries.map(d => d.id);

        const { error } = await supabase
            .from('delivery_data')
            .update({
                status: 'pending',
                delivered_at: null
            })
            .in('id', deliveryIds);

        if (error) {
            console.error('Erro ao atualizar Supabase:', error);
            throw error;
        }

        console.log(`‚úÖ ${deliveryIds.length} entrega(s) revertida(s) para pendente`);

        // Restaurar apar√™ncia original do marcador
        marker.isDelivered = false;

        if (marker.content) {
            // AdvancedMarkerElement - restaurar opacidade e cor
            const markerElement = marker.content;
            markerElement.style.opacity = '1';
            markerElement.style.filter = 'none';

            // Restaurar cor original
            const pinDiv = markerElement.querySelector('div');
            if (pinDiv) {
                pinDiv.style.background = isGreen ? '#4CAF50' : '#EA4335'; // Verde ou Vermelho
                const innerCircle = pinDiv.querySelector('div');
                if (innerCircle) {
                    innerCircle.style.color = isGreen ? '#4CAF50' : '#EA4335';
                }
            }
        } else if (marker.setIcon) {
            // Marker cl√°ssico - restaurar √≠cone original
            const deliveryCount = deliveries.length;
            const originalColor = isGreen ? '#4CAF50' : '#EA4335';

            const currentIcon = marker.getIcon();
            if (currentIcon && currentIcon.path) {
                marker.setIcon({
                    ...currentIcon,
                    fillColor: originalColor,
                    strokeColor: 'white'
                });
            } else {
                marker.setIcon({
                    url: createPinSVG(deliveryCount, originalColor),
                    scaledSize: new google.maps.Size(32, 44),
                    anchor: new google.maps.Point(16, 44)
                });
            }
            marker.setOpacity(1);
        }

        // Restaurar bot√£o para "Entregue"
        if (deliveredBtn) {
            deliveredBtn.innerHTML = '‚úì Entregue';
            deliveredBtn.style.background = '#34A853'; // Verde
            deliveredBtn.removeEventListener('mouseenter', deliveredBtn._hoverIn);
            deliveredBtn.removeEventListener('mouseleave', deliveredBtn._hoverOut);
            deliveredBtn._hoverIn = () => { deliveredBtn.style.background = '#2d8e47'; };
            deliveredBtn._hoverOut = () => { deliveredBtn.style.background = '#34A853'; };
            deliveredBtn.addEventListener('mouseenter', deliveredBtn._hoverIn);
            deliveredBtn.addEventListener('mouseleave', deliveredBtn._hoverOut);
        }

        // Toast de sucesso
        showToast(
            '‚Ü© Entrega revertida!',
            `${deliveries.length} pacote${deliveries.length > 1 ? 's' : ''} marcado${deliveries.length > 1 ? 's' : ''} como pendente novamente`,
            'info',
            3000
        );

    } catch (error) {
        console.error('Erro ao desfazer entrega:', error);
        showToast(
            '‚ùå Erro ao desfazer',
            error.message || 'N√£o foi poss√≠vel reverter o status',
            'error',
            4000
        );
    }
}

// Fun√ß√£o para calcular dist√¢ncia entre dois pontos (em metros)
function calculateDistance(lat1, lng1, lat2, lng2) {
    const R = 6371000; // Raio da Terra em metros
    const œÜ1 = lat1 * Math.PI / 180;
    const œÜ2 = lat2 * Math.PI / 180;
    const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
    const ŒîŒª = (lng2 - lng1) * Math.PI / 180;

    const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
              Math.cos(œÜ1) * Math.cos(œÜ2) *
              Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

    return R * c;
}

// Fun√ß√£o para navegar para o pr√≥ximo marcador usando rota real de tr√°fego
async function navigateToNextMarker(currentPosition = null) {
    // Filtrar apenas marcadores n√£o entregues
    const remainingMarkers = Object.values(deliveryMarkers).filter(m => m !== null && !m.isDelivered);

    if (remainingMarkers.length === 0) {
        showToast(
            'üéâ Todas entregas conclu√≠das!',
            'N√£o h√° mais entregas pendentes',
            'success',
            5000
        );
        return;
    }

    let nextMarker = null;
    let nextPosition = null;

    // Se temos posi√ß√£o atual, encontrar o marcador com menor tempo de viagem REAL
    if (currentPosition) {
        console.log('üöó Calculando rotas reais de tr√°fego para TODOS os marcadores...');

        // PASSO 1: Preparar lista de marcadores com suas posi√ß√µes
        const markersList = [];

        remainingMarkers.forEach(marker => {
            let markerPosition = null;

            if (marker.position) {
                markerPosition = marker.position;
            } else if (marker.getPosition) {
                markerPosition = marker.getPosition();
            }

            if (markerPosition) {
                markersList.push({
                    marker,
                    position: markerPosition
                });
            }
        });

        if (markersList.length === 0) {
            console.warn('Nenhum marcador com posi√ß√£o v√°lida encontrado');
            return;
        }

        console.log(`üìä Calculando rotas para ${markersList.length} destinos...`);

        try {
            // PASSO 2: Dividir em lotes de 25 (limite da Distance Matrix API)
            const MAX_DESTINATIONS = 25;
            const batches = [];
            for (let i = 0; i < markersList.length; i += MAX_DESTINATIONS) {
                batches.push(markersList.slice(i, i + MAX_DESTINATIONS));
            }

            console.log(`üì¶ Dividido em ${batches.length} lote(s) de at√© ${MAX_DESTINATIONS} destinos`);

            // PASSO 3: Processar todos os lotes em paralelo
            const service = new google.maps.DistanceMatrixService();
            const origin = new google.maps.LatLng(currentPosition.lat, currentPosition.lng);

            const batchPromises = batches.map((batch, batchIndex) => {
                const destinations = batch.map(item =>
                    new google.maps.LatLng(item.position.lat, item.position.lng)
                );

                const request = {
                    origins: [origin],
                    destinations: destinations,
                    travelMode: google.maps.TravelMode.DRIVING,
                    unitSystem: google.maps.UnitSystem.METRIC,
                    avoidHighways: false,
                    avoidTolls: false,
                    drivingOptions: {
                        departureTime: new Date(),
                        trafficModel: google.maps.TrafficModel.BEST_GUESS
                    }
                };

                return new Promise((resolve, reject) => {
                    // Delay entre requisi√ß√µes para evitar rate limiting
                    setTimeout(() => {
                        service.getDistanceMatrix(request, (response, status) => {
                            if (status === 'OK') {
                                resolve({ response, batch, batchIndex });
                            } else {
                                reject(new Error(`Lote ${batchIndex + 1} falhou: ${status}`));
                            }
                        });
                    }, batchIndex * 200); // 200ms entre cada lote
                });
            });

            // Aguardar todos os lotes
            const batchResults = await Promise.all(batchPromises);

            // PASSO 4: Encontrar o destino com MENOR DIST√ÇNCIA REAL (n√£o tempo)
            let minDistance = Infinity;
            let bestMarker = null;
            let bestPosition = null;
            let bestDistanceText = null;
            let bestDurationText = null;

            batchResults.forEach(({ response, batch, batchIndex }) => {
                response.rows[0].elements.forEach((element, index) => {
                    if (element.status === 'OK') {
                        const duration = element.duration.value; // Tempo em segundos (apenas para mostrar)
                        const distance = element.distance.value; // Dist√¢ncia em metros

                        console.log(`üìç Lote ${batchIndex + 1}, Destino ${index + 1}: ${Math.round(distance)}m (${Math.round(duration / 60)} min)`);

                        // Escolher pela MENOR DIST√ÇNCIA, n√£o pelo menor tempo
                        if (distance < minDistance) {
                            minDistance = distance;
                            bestMarker = batch[index].marker;
                            bestPosition = batch[index].position;
                            bestDistanceText = element.distance.text;
                            bestDurationText = element.duration.text;
                        }
                    }
                });
            });

            if (bestMarker) {
                nextMarker = bestMarker;
                nextPosition = bestPosition;

                console.log(`‚úÖ Rota mais curta (de ${markersList.length} destinos): ${bestDistanceText} (tempo estimado: ${bestDurationText})`);

                showToast(
                    'üìè Pr√≥xima entrega',
                    `${bestDistanceText} de dist√¢ncia`,
                    'info',
                    3000
                );
            } else {
                console.warn('Nenhuma rota v√°lida encontrada');
                nextMarker = markersList[0].marker;
                nextPosition = markersList[0].position;
            }

        } catch (error) {
            console.error('Erro ao calcular rotas:', error);
            // Fallback: pegar o primeiro marcador
            nextMarker = remainingMarkers[0];

            if (nextMarker.position) {
                nextPosition = nextMarker.position;
            } else if (nextMarker.getPosition) {
                nextPosition = nextMarker.getPosition();
            }

            showToast(
                '‚ö†Ô∏è Usando pr√≥ximo dispon√≠vel',
                'N√£o foi poss√≠vel calcular rota de tr√°fego',
                'warning',
                3000
            );
        }
    } else {
        // Se n√£o temos posi√ß√£o atual, pegar o primeiro marcador
        nextMarker = remainingMarkers[0];

        if (nextMarker.position) {
            nextPosition = nextMarker.position;
        } else if (nextMarker.getPosition) {
            nextPosition = nextMarker.getPosition();
        }
    }

    if (nextPosition) {
        // Centralizar no pr√≥ximo marcador
        map.panTo(nextPosition);

        // Dar zoom se estiver muito longe
        const currentZoom = map.getZoom();
        if (currentZoom < 16) {
            map.setZoom(16);
        }
    }
}

async function addDeliveryMarkers() {
    console.log('üîµ Adicionando marcadores de entrega...');

    // PASSO 1: Remover TODOS os marcadores anteriores
    const markerCount = Object.keys(deliveryMarkers).length;
    if (markerCount > 0) {
        console.log(`üóëÔ∏è Removendo ${markerCount} marcadores anteriores...`);
        Object.values(deliveryMarkers).forEach(marker => {
            try {
                if (marker.map !== undefined) {
                    marker.map = null; // AdvancedMarkerElement
                } else if (marker.setMap) {
                    marker.setMap(null); // Marker cl√°ssico
                }
            } catch (e) {
                console.warn('Erro ao remover marcador:', e);
            }
        });
    }

    // PASSO 2: Resetar objeto completamente
    deliveryMarkers = {};

    // PASSO 2.5: Buscar clientes cadastrados para verificar quais endere√ßos j√° existem
    let registeredClients = [];
    let registeredClientsByAddress = new Map(); // Mapa de endere√ßo normalizado -> cliente
    try {
        const { data: clients, error: clientsError } = await supabase
            .from('clients')
            .select('*');

        if (clientsError) throw clientsError;
        registeredClients = clients || [];
        console.log(`üìã ${registeredClients.length} clientes cadastrados encontrados`);

        // Criar mapa de endere√ßos normalizados -> dados do cliente
        registeredClients.forEach(client => {
            const clientAddress = client.address || '';
            const clientAddressFirstLine = clientAddress.split('\n')[0];
            const normalized = normalizeAddressForComparison(clientAddressFirstLine);
            if (normalized && client.latitude && client.longitude) {
                registeredClientsByAddress.set(normalized, client);
            }
        });
        console.log(`‚úÖ ${registeredClientsByAddress.size} endere√ßos √∫nicos cadastrados com coordenadas`);
    } catch (error) {
        console.warn('Aviso: N√£o foi poss√≠vel buscar clientes cadastrados:', error);
        // Continuar mesmo se n√£o conseguir buscar clientes (todos ser√£o vermelhos)
    }

    // PASSO 3: Buscar dados da planilha (delivery_data) do Supabase
    // Apenas entregas pendentes
    let deliveryData = [];
    try {
        const { data, error } = await supabase
            .from('delivery_data')
            .select('*')
            .eq('status', 'pending') // Apenas entregas pendentes
            .order('sequence', { ascending: true });

        if (error) throw error;
        deliveryData = data || [];
    } catch (error) {
        console.error('Erro ao buscar delivery_data:', error);
        showToast(
            'Erro ao carregar dados',
            'N√£o foi poss√≠vel buscar os dados da planilha',
            'error',
            4000
        );
        return;
    }

    if (deliveryData.length === 0) {
        console.log('‚ö†Ô∏è Nenhum dado encontrado na planilha');
        showToast(
            'Nenhuma entrega encontrada',
            'Fa√ßa upload de uma planilha para planejar rotas',
            'warning',
            4000
        );
        return;
    }

    // PASSO 4: Separar entregas em cadastradas vs n√£o cadastradas
    const groupedByRegistered = new Map(); // Cliente cadastrado -> entregas
    const groupedByUnregistered = {}; // Coordenada -> entregas n√£o cadastradas

    deliveryData.forEach((delivery) => {
        if (!delivery.latitude || !delivery.longitude) {
            console.warn(`Entrega ${delivery.spx_tn} n√£o tem coordenadas v√°lidas`);
            return;
        }

        // Verificar se o endere√ßo est√° cadastrado
        const deliveryAddress = delivery.destination_address || '';
        const normalized = normalizeAddressForComparison(deliveryAddress);
        const registeredClient = registeredClientsByAddress.get(normalized);

        if (registeredClient) {
            // Endere√ßo CADASTRADO: agrupar por cliente
            if (!groupedByRegistered.has(registeredClient.id)) {
                groupedByRegistered.set(registeredClient.id, {
                    client: registeredClient,
                    deliveries: []
                });
            }
            groupedByRegistered.get(registeredClient.id).deliveries.push({
                id: delivery.id,
                spx_tn: delivery.spx_tn,
                sequence: delivery.sequence,
                destination_address: delivery.destination_address
            });
        } else {
            // Endere√ßo N√ÉO CADASTRADO: agrupar por coordenada da planilha
            const coordKey = `${delivery.latitude.toFixed(6)},${delivery.longitude.toFixed(6)}`;
            if (!groupedByUnregistered[coordKey]) {
                groupedByUnregistered[coordKey] = {
                    position: { lat: delivery.latitude, lng: delivery.longitude },
                    address: delivery.destination_address,
                    bairro: delivery.bairro,
                    city: delivery.city,
                    zipcode: delivery.zipcode,
                    deliveries: []
                };
            }
            groupedByUnregistered[coordKey].deliveries.push({
                id: delivery.id,
                spx_tn: delivery.spx_tn,
                sequence: delivery.sequence || groupedByUnregistered[coordKey].deliveries.length + 1,
                destination_address: delivery.destination_address
            });
        }
    });

    console.log(`üì¶ Total de entregas: ${deliveryData.length}`);
    console.log(`‚úÖ Clientes cadastrados com entregas: ${groupedByRegistered.size}`);
    console.log(`‚ùå Locais n√£o cadastrados: ${Object.keys(groupedByUnregistered).length}`);

    const bounds = new google.maps.LatLngBounds();
    let registeredMarkersCount = 0;
    let unregisteredMarkersCount = 0;

    // PASSO 5: Criar marcadores VERDES para clientes cadastrados (reutilizar marcadores existentes)
    // PASSO 5: Criar marcadores VERDES para clientes cadastrados
    groupedByRegistered.forEach((data, clientId) => {
        const client = data.client;
        const deliveries = data.deliveries;
        const deliveryCount = deliveries.length;
        const position = { lat: client.latitude, lng: client.longitude };

        console.log(`‚úÖ Criando marcador verde para cliente: ${client.name} (${deliveryCount} entregas)`);

        // Criar marcador VERDE estilo pin do Google Maps
        const markerDiv = document.createElement('div');
        markerDiv.style.cursor = 'pointer';
        markerDiv.style.transition = 'transform 0.2s';

        // Pin verde
        const pinImg = document.createElement('div');
        pinImg.style.width = '32px';
        pinImg.style.height = '32px';
        pinImg.style.background = '#4CAF50';
        pinImg.style.border = '3px solid white';
        pinImg.style.borderRadius = '50% 50% 50% 0';
        pinImg.style.transform = 'rotate(-45deg)';
        pinImg.style.boxShadow = '0 3px 6px rgba(0,0,0,0.4)';
        pinImg.style.display = 'flex';
        pinImg.style.alignItems = 'center';
        pinImg.style.justifyContent = 'center';

        const innerCircle = document.createElement('div');
        innerCircle.style.width = '18px';
        innerCircle.style.height = '18px';
        innerCircle.style.background = 'white';
        innerCircle.style.borderRadius = '50%';
        innerCircle.style.transform = 'rotate(45deg)';
        innerCircle.style.fontSize = '11px';
        innerCircle.style.fontWeight = 'bold';
        innerCircle.style.color = '#4CAF50';
        innerCircle.style.display = 'flex';
        innerCircle.style.alignItems = 'center';
        innerCircle.style.justifyContent = 'center';
        innerCircle.textContent = deliveryCount;

        pinImg.appendChild(innerCircle);
        markerDiv.appendChild(pinImg);

        // Efeito hover
        markerDiv.addEventListener('mouseenter', () => { markerDiv.style.transform = 'scale(1.2)'; });
        markerDiv.addEventListener('mouseleave', () => { markerDiv.style.transform = 'scale(1)'; });

        // Criar InfoWindow
        const infoWindowContent = document.createElement('div');
        infoWindowContent.style.padding = '12px';
        infoWindowContent.style.maxWidth = '300px';
        infoWindowContent.style.maxHeight = '400px';
        infoWindowContent.style.overflowY = 'auto';

        // Badge
        const badgeDiv = document.createElement('div');
        badgeDiv.style.background = '#4CAF50';
        badgeDiv.style.color = 'white';
        badgeDiv.style.padding = '4px 8px';
        badgeDiv.style.borderRadius = '4px';
        badgeDiv.style.fontSize = '11px';
        badgeDiv.style.fontWeight = 'bold';
        badgeDiv.style.marginBottom = '8px';
        badgeDiv.style.display = 'inline-block';
        badgeDiv.textContent = '‚úì CLIENTE CADASTRADO';

        // Nome
        const nameDiv = document.createElement('div');
        nameDiv.style.fontWeight = 'bold';
        nameDiv.style.fontSize = '14px';
        nameDiv.style.color = '#4CAF50';
        nameDiv.style.marginBottom = '6px';
        nameDiv.textContent = `üë§ ${client.name}`;

        // Telefone
        const phoneDiv = document.createElement('div');
        phoneDiv.style.fontSize = '12px';
        phoneDiv.style.color = '#666';
        phoneDiv.style.marginBottom = '4px';
        phoneDiv.innerHTML = `üìû ${client.phone || 'Sem telefone'}`;

        // Endere√ßo
        const addressDiv = document.createElement('div');
        addressDiv.style.fontSize = '12px';
        addressDiv.style.color = '#333';
        addressDiv.style.lineHeight = '1.5';
        addressDiv.style.marginBottom = '8px';
        addressDiv.style.padding = '8px';
        addressDiv.style.background = '#f5f5f5';
        addressDiv.style.borderRadius = '4px';
        addressDiv.innerHTML = `üìç ${client.address.replace(/\n/g, '<br>')}`;

        infoWindowContent.appendChild(badgeDiv);
        infoWindowContent.appendChild(nameDiv);
        infoWindowContent.appendChild(phoneDiv);
        infoWindowContent.appendChild(addressDiv);

        // Lista de entregas
        const packagesTitle = document.createElement('div');
        packagesTitle.style.fontWeight = 'bold';
        packagesTitle.style.fontSize = '11px';
        packagesTitle.style.color = '#666';
        packagesTitle.style.marginTop = '8px';
        packagesTitle.style.marginBottom = '6px';
        packagesTitle.style.borderTop = '1px solid #eee';
        packagesTitle.style.paddingTop = '8px';
        packagesTitle.textContent = `üì¶ ${deliveryCount} pacote${deliveryCount > 1 ? 's' : ''}:`;
        infoWindowContent.appendChild(packagesTitle);

        deliveries.forEach((delivery, index) => {
            const deliveryDiv = document.createElement('div');
            deliveryDiv.style.fontSize = '11px';
            deliveryDiv.style.color = '#333';
            deliveryDiv.style.lineHeight = '1.4';
            deliveryDiv.style.marginBottom = '4px';
            deliveryDiv.style.paddingBottom = '4px';
            deliveryDiv.style.paddingLeft = '8px';
            if (index < deliveries.length - 1) deliveryDiv.style.borderBottom = '1px solid #eee';

            const qrDiv = document.createElement('div');
            qrDiv.style.display = 'flex';
            qrDiv.style.justifyContent = 'space-between';
            qrDiv.style.alignItems = 'center';
            qrDiv.style.gap = '8px';

            const sequenceSpan = document.createElement('span');
            sequenceSpan.style.color = '#4CAF50';
            sequenceSpan.style.fontWeight = 'bold';
            sequenceSpan.textContent = `Ordem: ${delivery.sequence || (index + 1)}`;

            const qrSpan = document.createElement('span');
            qrSpan.style.fontSize = '10px';
            qrSpan.style.color = '#666';
            qrSpan.style.fontFamily = 'monospace';
            qrSpan.textContent = delivery.spx_tn || 'N/A';

            qrDiv.appendChild(sequenceSpan);
            qrDiv.appendChild(qrSpan);
            deliveryDiv.appendChild(qrDiv);
            infoWindowContent.appendChild(deliveryDiv);
        });

        // Container de bot√µes (ser√° preenchido ap√≥s criar o marker)
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.display = 'flex';
        buttonsContainer.style.gap = '6px';
        buttonsContainer.style.marginTop = '10px';
        infoWindowContent.appendChild(buttonsContainer);

        const infoWindow = new google.maps.InfoWindow({
            content: infoWindowContent,
            maxWidth: 280,
            disableAutoPan: true
        });

        // Vari√°vel para armazenar o marker
        let marker;

        try {
            if (google.maps.marker && google.maps.marker.AdvancedMarkerElement) {
                marker = new google.maps.marker.AdvancedMarkerElement({
                    map,
                    position,
                    content: markerDiv,
                    title: client.name
                });

                marker.addListener('click', () => {
                    if (currentInfoWindow) currentInfoWindow.close();
                    infoWindow.open(map, marker);
                    currentInfoWindow = infoWindow;
                    map.panTo(position);
                    markUserInteraction(); // Detectar intera√ß√£o durante navega√ß√£o
                });

                deliveryMarkers[`registered_${clientId}`] = marker;
                registeredMarkersCount++;
            } else {
                marker = new google.maps.Marker({
                    map,
                    position,
                    title: client.name,
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        fillColor: '#4CAF50',
                        fillOpacity: 1,
                        strokeColor: 'white',
                        strokeWeight: 2,
                        scale: 10
                    }
                });

                marker.addListener('click', () => {
                    if (currentInfoWindow) currentInfoWindow.close();
                    infoWindow.open(map, marker);
                    currentInfoWindow = infoWindow;
                    map.panTo(position);
                    markUserInteraction(); // Detectar intera√ß√£o durante navega√ß√£o
                });

                deliveryMarkers[`registered_${clientId}`] = marker;
                registeredMarkersCount++;
            }

            // Adicionar bot√µes ao container (agora que o marker foi criado)
            // Bot√£o de navega√ß√£o
            const navigateBtn = document.createElement('button');
            navigateBtn.style.flex = '1';
            navigateBtn.style.padding = '6px 10px';
            navigateBtn.style.background = '#4285f4';
            navigateBtn.style.color = 'white';
            navigateBtn.style.border = 'none';
            navigateBtn.style.borderRadius = '4px';
            navigateBtn.style.fontSize = '12px';
            navigateBtn.style.fontWeight = '600';
            navigateBtn.style.cursor = 'pointer';
            navigateBtn.style.transition = 'background 0.2s';
            navigateBtn.style.whiteSpace = 'nowrap';
            navigateBtn.innerHTML = 'üß≠ Navegar';
            navigateBtn.addEventListener('mouseenter', () => { navigateBtn.style.background = '#3367d6'; });
            navigateBtn.addEventListener('mouseleave', () => { navigateBtn.style.background = '#4285f4'; });
            navigateBtn.addEventListener('click', () => { navigateToClient(client, marker, infoWindow); });

            // Bot√£o marcar como entregue / desfazer
            const deliveredBtn = document.createElement('button');
            deliveredBtn.style.flex = '1';
            deliveredBtn.style.padding = '6px 10px';
            deliveredBtn.style.background = '#34A853';
            deliveredBtn.style.color = 'white';
            deliveredBtn.style.border = 'none';
            deliveredBtn.style.borderRadius = '4px';
            deliveredBtn.style.fontSize = '12px';
            deliveredBtn.style.fontWeight = '600';
            deliveredBtn.style.cursor = 'pointer';
            deliveredBtn.style.transition = 'background 0.2s';
            deliveredBtn.style.whiteSpace = 'nowrap';
            deliveredBtn.innerHTML = '‚úì Entregue';

            // Armazenar fun√ß√µes de hover para poder remov√™-las depois
            deliveredBtn._hoverIn = () => { deliveredBtn.style.background = '#2d8e47'; };
            deliveredBtn._hoverOut = () => { deliveredBtn.style.background = '#34A853'; };
            deliveredBtn.addEventListener('mouseenter', deliveredBtn._hoverIn);
            deliveredBtn.addEventListener('mouseleave', deliveredBtn._hoverOut);

            // Handler do clique - alterna entre entregar e desfazer
            deliveredBtn.addEventListener('click', async () => {
                if (marker.isDelivered) {
                    console.log('‚Ü© Bot√£o Desfazer clicado (marcador verde)');
                    await undoDelivery(marker, deliveredBtn);
                } else {
                    console.log('üîò Bot√£o Entregue clicado (marcador verde)');
                    await markAsDelivered(deliveries, client, marker, null, deliveredBtn);
                }
            });

            buttonsContainer.appendChild(navigateBtn);
            buttonsContainer.appendChild(deliveredBtn);

            bounds.extend(position);
        } catch (error) {
            console.error('Erro ao criar marcador verde:', error);
        }
    });

    // PASSO 6: Criar marcadores VERMELHOS para endere√ßos n√£o cadastrados
    Object.entries(groupedByUnregistered).forEach(([coordKey, locationData]) => {
        const position = locationData.position;
        const deliveryCount = locationData.deliveries.length;

        console.log(`‚ùå Criando marcador vermelho para local n√£o cadastrado: ${locationData.address} (${deliveryCount} entregas)`);

        // Criar marcador vermelho (mesmo estilo do verde)
        const markerDiv = document.createElement('div');
        markerDiv.style.cursor = 'pointer';
        markerDiv.style.transition = 'transform 0.2s';

        // Pin vermelho
        const pinImg = document.createElement('div');
        pinImg.style.width = '32px';
        pinImg.style.height = '32px';
        pinImg.style.background = '#EA4335'; // Vermelho
        pinImg.style.border = '3px solid white';
        pinImg.style.borderRadius = '50% 50% 50% 0';
        pinImg.style.transform = 'rotate(-45deg)';
        pinImg.style.boxShadow = '0 3px 6px rgba(0,0,0,0.4)';
        pinImg.style.display = 'flex';
        pinImg.style.alignItems = 'center';
        pinImg.style.justifyContent = 'center';

        const innerCircle = document.createElement('div');
        innerCircle.style.width = '18px';
        innerCircle.style.height = '18px';
        innerCircle.style.background = 'white';
        innerCircle.style.borderRadius = '50%';
        innerCircle.style.transform = 'rotate(45deg)';
        innerCircle.style.fontSize = '11px';
        innerCircle.style.fontWeight = 'bold';
        innerCircle.style.color = '#EA4335'; // Vermelho
        innerCircle.style.display = 'flex';
        innerCircle.style.alignItems = 'center';
        innerCircle.style.justifyContent = 'center';
        innerCircle.textContent = deliveryCount;

        pinImg.appendChild(innerCircle);
        markerDiv.appendChild(pinImg);

        // Efeito hover (mesmo do verde)
        markerDiv.addEventListener('mouseenter', () => { markerDiv.style.transform = 'scale(1.2)'; });
        markerDiv.addEventListener('mouseleave', () => { markerDiv.style.transform = 'scale(1)'; });

        // Criar InfoWindow
        const infoWindowContent = document.createElement('div');
        infoWindowContent.style.padding = '8px';
        infoWindowContent.style.maxWidth = '250px';
        infoWindowContent.style.maxHeight = '300px';
        infoWindowContent.style.overflowY = 'auto';

        // Badge de n√£o cadastrado
        const statusBadge = document.createElement('div');
        statusBadge.style.background = '#FF9800';
        statusBadge.style.color = 'white';
        statusBadge.style.padding = '4px 8px';
        statusBadge.style.borderRadius = '4px';
        statusBadge.style.fontSize = '11px';
        statusBadge.style.fontWeight = 'bold';
        statusBadge.style.marginBottom = '8px';
        statusBadge.style.display = 'inline-block';
        statusBadge.textContent = '‚ö† CLIENTE N√ÉO CADASTRADO';
        infoWindowContent.appendChild(statusBadge);

        // Endere√ßo
        const addressInfoDiv = document.createElement('div');
        addressInfoDiv.style.fontSize = '12px';
        addressInfoDiv.style.color = '#333';
        addressInfoDiv.style.lineHeight = '1.5';
        addressInfoDiv.style.marginBottom = '10px';
        addressInfoDiv.style.padding = '8px';
        addressInfoDiv.style.background = '#f5f5f5';
        addressInfoDiv.style.borderRadius = '4px';

        let fullAddress = locationData.address || '';
        if (locationData.bairro) fullAddress += `\nBairro: ${locationData.bairro}`;
        if (locationData.city && locationData.zipcode) fullAddress += `\n${locationData.city} - ${locationData.zipcode}`;
        addressInfoDiv.innerHTML = fullAddress.replace(/\n/g, '<br>');
        infoWindowContent.appendChild(addressInfoDiv);

        // Lista de pacotes
        const packagesTitle = document.createElement('div');
        packagesTitle.style.fontWeight = 'bold';
        packagesTitle.style.fontSize = '11px';
        packagesTitle.style.color = '#666';
        packagesTitle.style.marginTop = '8px';
        packagesTitle.style.marginBottom = '6px';
        packagesTitle.style.borderTop = '1px solid #eee';
        packagesTitle.style.paddingTop = '8px';
        packagesTitle.textContent = `üì¶ ${deliveryCount} pacote${deliveryCount > 1 ? 's' : ''}:`;
        infoWindowContent.appendChild(packagesTitle);

        locationData.deliveries.forEach((delivery, index) => {
            const deliveryDiv = document.createElement('div');
            deliveryDiv.style.fontSize = '11px';
            deliveryDiv.style.color = '#333';
            deliveryDiv.style.lineHeight = '1.4';
            deliveryDiv.style.marginBottom = '4px';
            deliveryDiv.style.paddingBottom = '4px';
            deliveryDiv.style.paddingLeft = '8px';
            if (index < locationData.deliveries.length - 1) deliveryDiv.style.borderBottom = '1px solid #eee';

            const qrDiv = document.createElement('div');
            qrDiv.style.display = 'flex';
            qrDiv.style.justifyContent = 'space-between';
            qrDiv.style.alignItems = 'center';
            qrDiv.style.gap = '8px';

            const sequenceSpan = document.createElement('span');
            sequenceSpan.style.color = '#EA4335';
            sequenceSpan.style.fontWeight = 'bold';
            sequenceSpan.textContent = `Ordem: ${delivery.sequence}`;

            const qrSpan = document.createElement('span');
            qrSpan.style.fontSize = '10px';
            qrSpan.style.color = '#666';
            qrSpan.style.fontFamily = 'monospace';
            qrSpan.textContent = delivery.spx_tn;

            qrDiv.appendChild(sequenceSpan);
            qrDiv.appendChild(qrSpan);
            deliveryDiv.appendChild(qrDiv);
            infoWindowContent.appendChild(deliveryDiv);
        });

        // Container de bot√µes (ser√° preenchido ap√≥s criar o marker)
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.display = 'flex';
        buttonsContainer.style.gap = '6px';
        buttonsContainer.style.marginTop = '10px';
        infoWindowContent.appendChild(buttonsContainer);

        const infoWindow = new google.maps.InfoWindow({
            content: infoWindowContent,
            maxWidth: 280,
            disableAutoPan: true
        });

        // Vari√°vel para armazenar o marker
        let marker;

        try {
            if (google.maps.marker && google.maps.marker.AdvancedMarkerElement) {
                marker = new google.maps.marker.AdvancedMarkerElement({
                    map,
                    position,
                    content: markerDiv,
                    title: `${deliveryCount} entrega${deliveryCount > 1 ? 's' : ''} neste local`
                });

                marker.addListener('click', () => {
                    if (currentInfoWindow) currentInfoWindow.close();
                    const savedHeading = map.getHeading() || 0;
                    const savedTilt = map.getTilt() || 0;
                    const headingListener = map.addListener('heading_changed', () => {
                        if (map.getHeading() !== savedHeading) map.setHeading(savedHeading);
                    });
                    const tiltListener = map.addListener('tilt_changed', () => {
                        if (map.getTilt() !== savedTilt) map.setTilt(savedTilt);
                    });
                    map.panTo(position);
                    infoWindow.open(map, marker);
                    currentInfoWindow = infoWindow;
                    markUserInteraction(); // Detectar intera√ß√£o durante navega√ß√£o
                    setTimeout(() => {
                        google.maps.event.removeListener(headingListener);
                        google.maps.event.removeListener(tiltListener);
                    }, 500);
                });

                deliveryMarkers[coordKey] = marker;
                unregisteredMarkersCount++;
            } else {
                marker = new google.maps.Marker({
                    map,
                    position,
                    title: `${deliveryCount} entrega${deliveryCount > 1 ? 's' : ''} neste local`,
                    icon: {
                        url: createPinSVG(deliveryCount, '#EA4335'),
                        scaledSize: new google.maps.Size(32, 44),
                        anchor: new google.maps.Point(16, 44)
                    }
                });

                marker.addListener('click', () => {
                    if (currentInfoWindow) currentInfoWindow.close();
                    const savedHeading = map.getHeading() || 0;
                    const savedTilt = map.getTilt() || 0;
                    const headingListener = map.addListener('heading_changed', () => {
                        if (map.getHeading() !== savedHeading) map.setHeading(savedHeading);
                    });
                    const tiltListener = map.addListener('tilt_changed', () => {
                        if (map.getTilt() !== savedTilt) map.setTilt(savedTilt);
                    });
                    map.panTo(position);
                    infoWindow.open(map, marker);
                    currentInfoWindow = infoWindow;
                    markUserInteraction(); // Detectar intera√ß√£o durante navega√ß√£o
                    setTimeout(() => {
                        google.maps.event.removeListener(headingListener);
                        google.maps.event.removeListener(tiltListener);
                    }, 500);
                });

                deliveryMarkers[coordKey] = marker;
                unregisteredMarkersCount++;
            }

            // Adicionar bot√µes ao container (agora que o marker foi criado)
            // Bot√£o de navega√ß√£o
            const navigateBtn = document.createElement('button');
            navigateBtn.style.flex = '1';
            navigateBtn.style.padding = '6px 10px';
            navigateBtn.style.background = '#4285f4';
            navigateBtn.style.color = 'white';
            navigateBtn.style.border = 'none';
            navigateBtn.style.borderRadius = '4px';
            navigateBtn.style.fontSize = '12px';
            navigateBtn.style.fontWeight = '600';
            navigateBtn.style.cursor = 'pointer';
            navigateBtn.style.transition = 'background 0.2s';
            navigateBtn.style.whiteSpace = 'nowrap';
            navigateBtn.innerHTML = 'üß≠ Navegar';
            navigateBtn.addEventListener('mouseenter', () => { navigateBtn.style.background = '#3367d6'; });
            navigateBtn.addEventListener('mouseleave', () => { navigateBtn.style.background = '#4285f4'; });
            navigateBtn.addEventListener('click', () => {
                const clientData = {
                    name: locationData.address || 'Cliente',
                    latitude: position.lat,
                    longitude: position.lng,
                    address: fullAddress
                };
                navigateToClient(clientData, marker, infoWindow);
            });

            // Bot√£o marcar como entregue / desfazer
            const deliveredBtn = document.createElement('button');
            deliveredBtn.style.flex = '1';
            deliveredBtn.style.padding = '6px 10px';
            deliveredBtn.style.background = '#34A853';
            deliveredBtn.style.color = 'white';
            deliveredBtn.style.border = 'none';
            deliveredBtn.style.borderRadius = '4px';
            deliveredBtn.style.fontSize = '12px';
            deliveredBtn.style.fontWeight = '600';
            deliveredBtn.style.cursor = 'pointer';
            deliveredBtn.style.transition = 'background 0.2s';
            deliveredBtn.style.whiteSpace = 'nowrap';
            deliveredBtn.innerHTML = '‚úì Entregue';

            // Armazenar fun√ß√µes de hover para poder remov√™-las depois
            deliveredBtn._hoverIn = () => { deliveredBtn.style.background = '#2d8e47'; };
            deliveredBtn._hoverOut = () => { deliveredBtn.style.background = '#34A853'; };
            deliveredBtn.addEventListener('mouseenter', deliveredBtn._hoverIn);
            deliveredBtn.addEventListener('mouseleave', deliveredBtn._hoverOut);

            // Handler do clique - alterna entre entregar e desfazer
            deliveredBtn.addEventListener('click', async () => {
                if (marker.isDelivered) {
                    console.log('‚Ü© Bot√£o Desfazer clicado (marcador vermelho)');
                    await undoDelivery(marker, deliveredBtn);
                } else {
                    console.log('üîò Bot√£o Entregue clicado (marcador vermelho)');
                    await markAsDelivered(locationData.deliveries, null, marker, coordKey, deliveredBtn);
                }
            });

            buttonsContainer.appendChild(navigateBtn);
            buttonsContainer.appendChild(deliveredBtn);

            bounds.extend(position);
        } catch (error) {
            console.error('Erro ao criar marcador vermelho:', error);
        }
    });

    console.log(`‚úÖ Total: ${registeredMarkersCount + unregisteredMarkersCount} marcadores criados`);
    console.log(`‚úÖ Cadastrados: ${registeredMarkersCount} (verde) | N√£o cadastrados: ${unregisteredMarkersCount} (vermelho)`);

    // Ajustar mapa para mostrar todos os marcadores
    if (!bounds.isEmpty()) {
        map.fitBounds(bounds, {
            padding: 80 // Adicionar margem de 80px ao redor
        });
        console.log('üó∫Ô∏è Mapa ajustado para mostrar todos os marcadores');
    }

    // Mostrar toast com estat√≠sticas
    const totalLocations = registeredMarkersCount + unregisteredMarkersCount;
    showToast(
        `üìç ${totalLocations} Locais de entrega`,
        `‚úÖ ${registeredMarkersCount} cadastrado${registeredMarkersCount !== 1 ? 's' : ''} ‚ùå ${unregisteredMarkersCount} n√£o cadastrado${unregisteredMarkersCount !== 1 ? 's' : ''}`,
        'info',
        6000
    );
}

// ===========================
// ANIMA√á√ÉO 2D ‚áÑ 3D
// ===========================

function animateValue(start, end, duration, onUpdate, onFinish) {
    const startTime = performance.now();
    let frameCount = 0;

    function frame(time) {
        const progress = Math.min((time - startTime) / duration, 1);

        // Easing function para anima√ß√£o mais suave (easeInOutCubic)
        const eased = progress < 0.5
            ? 4 * progress * progress * progress
            : 1 - Math.pow(-2 * progress + 2, 3) / 2;

        const value = start + (end - start) * eased;

        // Limitar updates para 60fps m√°ximo
        frameCount++;
        if (frameCount % 1 === 0) { // Atualiza a cada frame
            onUpdate(value);
        }

        if (progress < 1) {
            requestAnimationFrame(frame);
        } else {
            onUpdate(end); // Garantir valor final exato
            if (onFinish) onFinish();
        }
    }

    requestAnimationFrame(frame);
}

document.getElementById("btnToggle3D").onclick = () => {
    const btn = document.getElementById("btnToggle3D");

    if (_animating3D) return;
    _animating3D = true;

    btn.classList.add('loading');
    btn.disabled = true;

    if (!is3D) {
        is3D = true;

        animateValue(map.getTilt(), 67, 600, val => map.setTilt(val));
        animateValue(map.getHeading(), 45, 600, val => map.setHeading(val), () => {
            _animating3D = false;
            btn.classList.remove('loading');
            btn.classList.add('active');
            btn.textContent = "2D";
            btn.disabled = false;
            showToast('Modo 3D ativado', 'Arraste para rotacionar', 'success', 2000);
        });

    } else {
        is3D = false;

        animateValue(map.getTilt(), 0, 600, val => map.setTilt(val));
        animateValue(map.getHeading(), 0, 600, val => map.setHeading(val), () => {
            _animating3D = false;
            btn.classList.remove('loading', 'active');
            btn.textContent = "3D";
            btn.disabled = false;
            showToast('Modo 2D ativado', '', 'success', 2000);
        });
    }
};

// ===========================
// BOT√ÉO PARAR NAVEGA√á√ÉO
// ===========================

document.getElementById("btnStopNavigation").onclick = () => {
    stopNavigationMode();
};

// ===========================
// CENTRALIZAR LOCALIZA√á√ÉO (BOT√ÉO ANTIGO - REMOVIDO)
// ===========================
// Agora usa o bot√£o GPS customizado adicionado via addGPSCenterButton()

/* C√ìDIGO ANTIGO COMENTADO - Bot√£o removido do HTML
document.getElementById("btnCenterLocation").onclick = () => {
    const btn = document.getElementById("btnCenterLocation");

    // Usar GPS Tracker modular se dispon√≠vel
    if (gpsTracker) {
        gpsTracker.centerOnUser();
        showToast('Centralizado', 'Mapa centralizado na sua localiza√ß√£o', 'info', 2000);
        return;
    }

    // Fallback para c√≥digo legado
    if (!userLocationMarker) {
        showToast('Localiza√ß√£o n√£o dispon√≠vel', 'Aguarde obter sua posi√ß√£o GPS', 'warning', 3000);
        return;
    }

    // Pega a posi√ß√£o atual do marcador (compat√≠vel com ambos os tipos)
    let currentPosition;
    if (userLocationMarker.position) {
        currentPosition = userLocationMarker.position;
    } else if (userLocationMarker.getPosition) {
        currentPosition = userLocationMarker.getPosition();
    }

    if (!currentPosition) {
        showToast('Erro ao centralizar', 'Posi√ß√£o n√£o encontrada', 'error', 3000);
        return;
    }

    // Feedback visual no bot√£o
    btn.classList.add('loading');
    btn.disabled = true;

    // Anima o zoom e centraliza
    map.panTo(currentPosition);

    // Se estiver muito distante, ajusta o zoom
    const currentZoom = map.getZoom();
    if (currentZoom < 16) {
        map.setZoom(17);
    }

    // Remove o loading ap√≥s a anima√ß√£o
    setTimeout(() => {
        btn.classList.remove('loading');
        btn.disabled = false;
        showToast(
            'Centralizado!',
            `Precis√£o: ${Math.round(locationAccuracy)}m`,
            'success',
            2000
        );
    }, 400);
};
*/

// ===========================
// MODAL E QR CODE SCANNER
// ===========================

const modal = document.getElementById('modal-add-client');
const btnAddClient = document.getElementById('btn-add-client');
const btnModalClose = document.getElementById('modal-close');
const btnCancel = document.getElementById('btn-cancel');
const btnSave = document.getElementById('btn-save');
const form = document.getElementById('form-add-client');

const addressDisplay = document.getElementById('address-display');
const addressText = document.getElementById('address-text');

const inputName = document.getElementById('input-name');
const inputPhone = document.getElementById('input-phone');

// Elementos do dropdown customizado
const addressDropdown = document.getElementById('address-dropdown');
const dropdownHeader = document.getElementById('dropdown-header');
const dropdownList = document.getElementById('dropdown-list');

let scannedAddress = '';
let scannedQRCode = ''; // Armazena o c√≥digo QR escaneado
let scannedLatLng = null; // Armazena coordenadas do endere√ßo escaneado

// Popular lista de endere√ßos da planilha do dia (Supabase) no dropdown customizado
// Exibe apenas endere√ßos N√ÉO cadastrados
async function populateAddressSelect() {
    if (!dropdownList) return;

    // Limpar itens anteriores
    dropdownList.innerHTML = '';

    try {
        // Buscar dados da planilha do dia no Supabase
        const { data: deliveryData, error } = await supabase
            .from('delivery_data')
            .select('*')
            .order('sequence', { ascending: true });

        if (error) {
            console.error('Erro ao buscar endere√ßos da planilha:', error);
            return;
        }

        if (!deliveryData || deliveryData.length === 0) {
            const emptyItem = document.createElement('div');
            emptyItem.className = 'dropdown-item-empty';
            emptyItem.textContent = '‚ö†Ô∏è Nenhuma planilha carregada';
            dropdownList.appendChild(emptyItem);
            return;
        }

        // Buscar clientes j√° cadastrados
        const { data: clients, error: clientsError } = await supabase
            .from('clients')
            .select('address');

        if (clientsError) {
            console.warn('Erro ao buscar clientes:', clientsError);
        }

        // Criar Set de endere√ßos j√° cadastrados (normalizados)
        const registeredAddresses = new Set();
        if (clients && clients.length > 0) {
            clients.forEach(client => {
                if (client.address) {
                    // Normalizar: primeira linha, lowercase, sem espa√ßos extras
                    const firstLine = client.address.split('\n')[0].toLowerCase().trim();
                    registeredAddresses.add(firstLine);
                }
            });
        }

        // Filtrar apenas endere√ßos N√ÉO cadastrados
        let addedCount = 0;
        deliveryData.forEach((item, index) => {
            // Verificar se j√° est√° cadastrado
            const addressFirstLine = (item.destination_address || '').split('\n')[0].toLowerCase().trim();

            if (registeredAddresses.has(addressFirstLine)) {
                // Endere√ßo j√° cadastrado - pular
                return;
            }

            // Montar endere√ßo completo
            const fullAddress = [
                item.destination_address,
                item.bairro ? `Bairro: ${item.bairro}` : '',
                item.city,
                item.zipcode
            ].filter(Boolean).join('\n');

            // Pegar primeira linha do endere√ßo para exibi√ß√£o
            const displayAddress = (item.destination_address || '').split('\n')[0].trim();

            // Usar sequence da planilha ou √≠ndice + 1
            const seq = item.sequence || (index + 1);

            // Criar item do dropdown
            const dropdownItem = document.createElement('div');
            dropdownItem.className = 'dropdown-item';
            dropdownItem.dataset.value = item.spx_tn || item.id;
            dropdownItem.dataset.address = fullAddress;
            dropdownItem.dataset.lat = item.latitude || 0;
            dropdownItem.dataset.lng = item.longitude || 0;
            dropdownItem.dataset.spxTn = item.spx_tn || '';

            dropdownItem.innerHTML = `
                <span class="dropdown-item-number">${seq}.</span>
                <span class="dropdown-item-address">${escapeHtml(displayAddress)}</span>
            `;

            // Evento de clique no item
            dropdownItem.addEventListener('click', () => selectDropdownItem(dropdownItem));

            dropdownList.appendChild(dropdownItem);
            addedCount++;
        });

        // Se todos j√° est√£o cadastrados
        if (addedCount === 0) {
            const successItem = document.createElement('div');
            successItem.className = 'dropdown-item-empty dropdown-item-success';
            successItem.textContent = '‚úÖ Todos os endere√ßos j√° cadastrados';
            dropdownList.appendChild(successItem);
        }

        console.log(`üìã ${addedCount} endere√ßos n√£o cadastrados dispon√≠veis (${deliveryData.length - addedCount} j√° cadastrados)`);

    } catch (err) {
        console.error('Erro ao popular dropdown de endere√ßos:', err);
    }
}

// Fun√ß√£o para selecionar item do dropdown
function selectDropdownItem(item) {
    const qrCode = item.dataset.spxTn || item.dataset.value;
    const address = item.dataset.address;
    const lat = parseFloat(item.dataset.lat) || 0;
    const lng = parseFloat(item.dataset.lng) || 0;

    // Atualizar vari√°veis como se tivesse escaneado o QR Code
    scannedQRCode = qrCode;
    scannedAddress = address;
    if (lat && lng) {
        scannedLatLng = { lat, lng };
    }

    // Atualizar header do dropdown com o item selecionado
    const numberSpan = item.querySelector('.dropdown-item-number');
    const addressSpan = item.querySelector('.dropdown-item-address');
    dropdownHeader.innerHTML = `
        <span><span style="color: #EA4335; font-weight: 700;">${numberSpan.textContent}</span> ${addressSpan.textContent}</span>
        <span class="dropdown-arrow">‚ñº</span>
    `;

    // Fechar dropdown
    addressDropdown.classList.remove('open');

    // Mostrar endere√ßo selecionado
    addressDisplay.classList.add('active');
    addressText.textContent = address;

    // Parar c√¢mera (n√£o precisa mais escanear)
    stopCamera();

    // Focar no campo nome para preenchimento
    setTimeout(() => {
        inputName.focus();
    }, 100);

    showToast(
        'üìç Endere√ßo selecionado',
        'Preencha os dados do cliente',
        'info',
        3000
    );

    console.log(`‚úÖ Endere√ßo selecionado manualmente: ${qrCode}`);
}

// Evento de toggle do dropdown customizado
if (dropdownHeader) {
    dropdownHeader.addEventListener('click', function() {
        const isOpen = addressDropdown.classList.toggle('open');

        if (isOpen) {
            // Parar c√¢mera ao abrir dropdown
            stopCamera();
            const qrStatus = document.getElementById('qr-status');
            if (qrStatus) {
                qrStatus.textContent = '‚è∏Ô∏è Aguardando sele√ß√£o manual...';
            }
            console.log('üìã Modo sele√ß√£o manual ativado - c√¢mera pausada');
        }
    });
}

// Fechar dropdown ao clicar fora
document.addEventListener('click', function(e) {
    if (addressDropdown && !addressDropdown.contains(e.target)) {
        addressDropdown.classList.remove('open');
    }
});

// Mostrar bot√£o ap√≥s carregar o mapa
function showAddClientButton() {
    setTimeout(() => {
        btnAddClient.classList.add('visible');
    }, 800);
}

// Abrir modal
async function openModal() {
    modal.classList.add('active');
    document.body.style.overflow = 'hidden';

    // Popular lista de endere√ßos da planilha
    populateAddressSelect();

    // Verificar se c√¢mera est√° dispon√≠vel
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        showToast(
            'C√¢mera n√£o dispon√≠vel',
            'Seu navegador n√£o suporta acesso √† c√¢mera',
            'error',
            5000
        );
        return;
    }

    // Abrir c√¢mera automaticamente
    try {
        await startCamera();
    } catch (error) {
        console.error('Erro ao abrir c√¢mera:', error);

        let errorMessage = 'Verifique as permiss√µes do navegador';

        // Mensagens de erro mais espec√≠ficas
        if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
            errorMessage = 'Permiss√£o negada. Permita o acesso √† c√¢mera nas configura√ß√µes do navegador.';
        } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
            errorMessage = 'Nenhuma c√¢mera encontrada no dispositivo.';
        } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
            errorMessage = 'C√¢mera j√° est√° em uso por outro aplicativo.';
        } else if (error.name === 'OverconstrainedError') {
            errorMessage = 'C√¢mera n√£o atende aos requisitos necess√°rios.';
        } else if (error.name === 'SecurityError') {
            errorMessage = 'Acesso √† c√¢mera bloqueado por pol√≠tica de seguran√ßa.';
        }

        showToast(
            'Erro ao abrir c√¢mera',
            errorMessage,
            'error',
            7000
        );
    }
}

// Fechar modal
function closeModal() {
    modal.classList.remove('active');
    document.body.style.overflow = '';
    resetForm();
    // Restaurar formul√°rio normal (caso esteja mostrando painel de atualiza√ß√£o)
    showNormalRegistrationForm();
}

// Resetar formul√°rio
function resetForm() {
    form.reset();
    addressDisplay.classList.remove('active');
    addressText.textContent = '';
    scannedAddress = '';
    scannedQRCode = '';
    scannedLatLng = null;
    stopCamera(); // Parar c√¢mera ao fechar modal

    // Resetar dropdown customizado de endere√ßo manual
    if (addressDropdown) {
        addressDropdown.classList.remove('open');
        if (dropdownHeader) {
            dropdownHeader.innerHTML = `
                <span class="dropdown-placeholder">-- Escolha um endere√ßo da planilha --</span>
                <span class="dropdown-arrow">‚ñº</span>
            `;
        }
    }

    // Resetar modo de edi√ß√£o
    isEditMode = false;
    editingClientId = null;
    btnSave.textContent = 'Salvar Cliente';

    // Restaurar t√≠tulo do scanner
    const scannerTitle = document.querySelector('.scanner-title span');
    if (scannerTitle) {
        scannerTitle.textContent = 'üì∏ Aponte a c√¢mera para o QR Code';
    }
}

// Event listeners do modal
btnAddClient.addEventListener('click', async () => {
    // Verificar se est√° em modo de atualiza√ß√£o de localiza√ß√£o
    if (btnAddClient.dataset.updateMode === 'true' && pendingLocationUpdate) {
        await updateClientLocation(pendingLocationUpdate.clientId, pendingLocationUpdate.clientName);
    } else {
        openModal();
    }
});
btnModalClose.addEventListener('click', closeModal);
btnCancel.addEventListener('click', closeModal);

// Fechar modal ao clicar fora
modal.addEventListener('click', (e) => {
    if (e.target === modal) {
        closeModal();
    }
});

// ===========================
// M√ÅSCARA DE TELEFONE
// ===========================

inputPhone.addEventListener('input', (e) => {
    let value = e.target.value.replace(/\D/g, ''); // Remove tudo que n√£o √© n√∫mero

    // Limita a 11 d√≠gitos
    if (value.length > 11) {
        value = value.slice(0, 11);
    }

    // Aplica a m√°scara conforme o usu√°rio digita
    let formatted = '';

    if (value.length > 0) {
        formatted = '(' + value.substring(0, 2); // (DD
    }
    if (value.length >= 3) {
        formatted += ')' + value.substring(2, 3); // (DD)D
    }
    if (value.length >= 4) {
        formatted += ' ' + value.substring(3, 7); // (DD)D DDDD
    }
    if (value.length >= 8) {
        formatted += '-' + value.substring(7, 11); // (DD)D DDDD-DDDD
    }

    e.target.value = formatted;
});

// Permitir apenas n√∫meros e teclas de controle
inputPhone.addEventListener('keydown', (e) => {
    const allowedKeys = ['Backspace', 'Delete', 'Tab', 'ArrowLeft', 'ArrowRight', 'Home', 'End'];
    const isNumber = /^[0-9]$/.test(e.key);

    if (!isNumber && !allowedKeys.includes(e.key) && !e.ctrlKey && !e.metaKey) {
        e.preventDefault();
    }
});

// ===========================
// QR CODE SCANNER COM C√ÇMERA
// ===========================

const btnStopCamera = document.getElementById('btn-stop-camera');
const btnSwitchCamera = document.getElementById('btn-switch-camera');
const qrCameraContainer = document.getElementById('qr-camera-container');
const qrVideo = document.getElementById('qr-video');
const qrCanvas = document.getElementById('qr-canvas');
const qrStatus = document.getElementById('qr-status');

let videoStream = null;
let scanningInterval = null;
let currentFacingMode = 'environment'; // Come√ßa com c√¢mera traseira
let lastScannedCode = null;

// Fechar c√¢mera
btnStopCamera.addEventListener('click', () => {
    stopCamera();
});

// Trocar c√¢mera (frontal/traseira)
btnSwitchCamera.addEventListener('click', async () => {
    currentFacingMode = currentFacingMode === 'environment' ? 'user' : 'environment';
    stopCamera();
    await startCamera();
});

// Iniciar c√¢mera
async function startCamera() {
    // Parar c√¢mera existente antes de iniciar nova
    stopCamera();

    // üöÄ LAZY LOADING: Carregar jsQR apenas quando necess√°rio
    if (!lazyLoader.isLoaded('jsQR')) {
        console.log('üì¶ [LAZY] Carregando jsQR pela primeira vez...');
        try {
            await lazyLoader.loadJsQR();
        } catch (error) {
            showToast('Erro ao carregar scanner', 'N√£o foi poss√≠vel carregar a biblioteca QR', 'error', 4000);
            return;
        }
    }

    // üéØ CONSTRAINTS EXATAMENTE COMO O GEMINI ESPECIFICA
    const constraints = {
        video: {
            facingMode: "environment", // Prioriza a c√¢mera traseira (como Gemini especificou)
            // Resolu√ß√£o otimizada para QR Code
            width: { ideal: 640 },  // Gemini: usar 640x480 para melhor performance
            height: { ideal: 480 },
            // ‚ú® Configura√ß√µes DIRETAS (sem { ideal: ... }) como Gemini especificou
            focusMode: "continuous",      // Mant√©m foco no objeto
            exposureMode: "continuous",   // Ajusta exposi√ß√£o automaticamente
            whiteBalanceMode: "continuous"
        }
    };

    try {
        videoStream = await navigator.mediaDevices.getUserMedia(constraints);

        // Garantir que o v√≠deo recebe o stream
        qrVideo.srcObject = videoStream;

        // ‚ú® Deixar o sistema operacional gerenciar exposi√ß√£o automaticamente
        // (removido c√≥digo que for√ßava brilho alto e causava superexposi√ß√£o)

        // Mostrar container da c√¢mera
        qrCameraContainer.classList.add('active');

        // Aguardar v√≠deo carregar e iniciar reprodu√ß√£o
        return new Promise((resolve, reject) => {
            qrVideo.onloadedmetadata = async () => {
                try {
                    // For√ßar play do v√≠deo
                    await qrVideo.play();

                    // Iniciar scanning ap√≥s v√≠deo come√ßar
                    startScanning();

                    resolve();
                } catch (playError) {
                    console.error('Erro ao iniciar reprodu√ß√£o do v√≠deo:', playError);
                    reject(playError);
                }
            };

            qrVideo.onerror = (error) => {
                console.error('Erro no elemento de v√≠deo:', error);
                reject(error);
            };

            // Timeout de seguran√ßa
            setTimeout(() => {
                if (qrVideo.readyState < 2) {
                    reject(new Error('Timeout ao carregar v√≠deo'));
                }
            }, 10000);
        });

    } catch (error) {
        // Limpar em caso de erro
        stopCamera();
        qrCameraContainer.classList.remove('active');
        throw error;
    }
}

// Parar c√¢mera
function stopCamera() {
    // Parar todas as tracks do stream
    if (videoStream) {
        videoStream.getTracks().forEach(track => {
            track.stop();
            track.enabled = false;
        });
        videoStream = null;
    }

    // Parar intervalo de scanning
    if (scanningInterval) {
        clearInterval(scanningInterval);
        scanningInterval = null;
    }

    // Limpar v√≠deo completamente
    qrVideo.pause();
    qrVideo.srcObject = null;
    qrVideo.load(); // For√ßa reload do elemento de v√≠deo

    // Remover event listeners antigos
    qrVideo.onloadedmetadata = null;
    qrVideo.onerror = null;

    // Esconder container
    qrCameraContainer.classList.remove('active');

    // Resetar status
    qrStatus.textContent = 'Procurando QR Code...';
    qrStatus.classList.remove('success');
    lastScannedCode = null;
}

// Vari√°veis para valida√ß√£o de leitura
let consecutiveReads = 0;
let lastReadData = null;
const REQUIRED_CONSECUTIVE_READS = 2; // Precisa ler 2x consecutivo para confirmar

// Validar se o c√≥digo lido parece ser um c√≥digo de pacote v√°lido
function isValidPackageCode(code) {
    if (!code || typeof code !== 'string') return false;

    // Remover espa√ßos
    const trimmed = code.trim();

    // Verificar comprimento m√≠nimo (c√≥digos podem ter a partir de 4 caracteres)
    if (trimmed.length < 4) return false;

    // Rejeitar strings vazias ou apenas espa√ßos
    if (trimmed.length === 0) return false;

    // Rejeitar URLs completas (falsos positivos de propagandas)
    if (trimmed.startsWith('http://') || trimmed.startsWith('https://')) return false;

    // Rejeitar c√≥digos extremamente longos (> 100 caracteres - provavelmente erro)
    if (trimmed.length > 100) return false;

    // Aceitar qualquer c√≥digo alfanum√©rico com s√≠mbolos comuns de pacotes
    // Inclui: letras, n√∫meros, h√≠fen, underscore, ponto, barra, dois pontos, espa√ßos
    const validPattern = /^[A-Za-z0-9\-_\.\/\:\s\#\@\+\=]+$/;
    if (!validPattern.test(trimmed)) {
        // Se falhar, ainda aceitar se tiver pelo menos 50% alfanum√©rico
        const alphanumCount = (trimmed.match(/[A-Za-z0-9]/g) || []).length;
        if (alphanumCount / trimmed.length < 0.5) return false;
    }

    return true;
}

// Iniciar loop de scanning otimizado
function startScanning() {
    const canvasContext = qrCanvas.getContext('2d', { willReadFrequently: true });

    // Resetar contadores
    consecutiveReads = 0;
    lastReadData = null;

    scanningInterval = setInterval(() => {
        if (qrVideo.readyState === qrVideo.HAVE_ENOUGH_DATA) {
            // ‚ú® OTIMIZA√á√ÉO GEMINI 1: Reduzir resolu√ß√£o de processamento
            // Em vez de processar a resolu√ß√£o nativa (ex: 1920x1080 = 2M pixels),
            // processar apenas 640x480 (300k pixels) - 85% mais r√°pido!
            const processWidth = 640;
            const processHeight = (qrVideo.videoHeight / qrVideo.videoWidth) * processWidth;

            qrCanvas.width = processWidth;
            qrCanvas.height = processHeight;

            // Desenhar v√≠deo redimensionado no canvas
            canvasContext.drawImage(qrVideo, 0, 0, processWidth, processHeight);

            // ‚ú® OTIMIZA√á√ÉO GEMINI 2: ROI (Region of Interest)
            // Processar apenas o centro da imagem (quadrado de 400x400px)
            // Isso reduz ainda mais o processamento em ~70%
            const scanSize = Math.min(400, processWidth, processHeight);
            const centerX = processWidth / 2;
            const centerY = processHeight / 2;

            // Capturar apenas a regi√£o central
            const imageData = canvasContext.getImageData(
                centerX - scanSize / 2,
                centerY - scanSize / 2,
                scanSize,
                scanSize
            );

            // ‚ú® OTIMIZA√á√ÉO GEMINI 3: attemptBoth (j√° implementado)
            // Tenta ler QR codes normais E invertidos
            const code = jsQR(imageData.data, scanSize, scanSize, {
                inversionAttempts: "attemptBoth",
            });

            if (code && code.data) {
                const qrData = code.data.trim();

                // Validar se parece um c√≥digo de pacote v√°lido
                if (!isValidPackageCode(qrData)) {
                    // C√≥digo inv√°lido - ignorar silenciosamente
                    consecutiveReads = 0;
                    lastReadData = null;
                    return;
                }

                // Verificar tamanho m√≠nimo do QR code detectado (evitar falsos positivos)
                const qrSize = Math.abs(code.location.bottomRightCorner.x - code.location.topLeftCorner.x);
                if (qrSize < 20) {
                    // QR code muito pequeno - pode ser ru√≠do
                    return;
                }

                // Sistema de confirma√ß√£o: precisa ler o mesmo c√≥digo 2x consecutivo
                if (qrData === lastReadData) {
                    consecutiveReads++;
                } else {
                    consecutiveReads = 1;
                    lastReadData = qrData;
                }

                // Atualizar status visual
                qrStatus.textContent = `üîç Lendo... (${consecutiveReads}/${REQUIRED_CONSECUTIVE_READS})`;

                // S√≥ processar ap√≥s leituras consecutivas confirmadas
                if (consecutiveReads >= REQUIRED_CONSECUTIVE_READS && qrData !== lastScannedCode) {
                    lastScannedCode = qrData;
                    consecutiveReads = 0;
                    lastReadData = null;

                    console.log('‚úÖ QR Code confirmado:', qrData);

                    // Feedback visual
                    qrStatus.textContent = '‚úì QR Code detectado!';
                    qrStatus.classList.add('success');

                    // Som de beep
                    playBeep();

                    // Processar resultado
                    handleQRCodeResult(qrData);

                    // Parar scanning ap√≥s detectar
                    setTimeout(() => {
                        stopCamera();
                    }, 800);
                }
            } else {
                // Nenhum c√≥digo detectado - resetar contador
                if (consecutiveReads > 0) {
                    consecutiveReads = 0;
                    lastReadData = null;
                }
            }
        }
    }, 50); // Scan a cada 50ms (20 fps) - mais r√°pido para detectar
}

// Som de beep ao detectar QR code
function playBeep() {
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();

    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);

    oscillator.frequency.value = 800;
    oscillator.type = 'sine';

    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);

    oscillator.start(audioContext.currentTime);
    oscillator.stop(audioContext.currentTime + 0.2);
}

// Processar resultado do QR Code
async function handleQRCodeResult(qrData) {
    console.log('Processando QR Code:', qrData);

    // Buscar endere√ßo no banco de dados (delivery_data)
    const addressData = await lookupAddressData(qrData);

    if (addressData) {
        // Verificar se o endere√ßo J√Å EST√Å CADASTRADO na tabela clients
        const existingClient = await checkClientByAddress(addressData.address);

        if (existingClient) {
            // Cliente j√° cadastrado - mostrar op√ß√£o de atualizar localiza√ß√£o
            showUpdateLocationPanel(existingClient, addressData);
            return;
        }

        // Cliente N√ÉO cadastrado - fluxo normal de cadastro
        scannedAddress = addressData.address;
        scannedQRCode = qrData;
        scannedLatLng = {
            latitude: addressData.latitude,
            longitude: addressData.longitude
        };

        // Mostrar formul√°rio normal
        showNormalRegistrationForm();

        addressText.textContent = addressData.address;
        addressDisplay.classList.add('active');

        showToast(
            '‚úì Endere√ßo encontrado!',
            'Preencha o nome do cliente',
            'success',
            3000
        );

        // Focar automaticamente no campo de nome
        setTimeout(() => {
            inputName.focus();
        }, 500);
    } else {
        // Endere√ßo n√£o encontrado - mostrar c√≥digo
        scannedAddress = `C√≥digo QR: ${qrData} (Endere√ßo n√£o cadastrado)`;
        scannedQRCode = qrData;
        scannedLatLng = null; // Sem coordenadas

        // Mostrar formul√°rio normal
        showNormalRegistrationForm();

        addressText.textContent = scannedAddress;
        addressDisplay.classList.add('active');

        showToast(
            '‚ö†Ô∏è Endere√ßo n√£o cadastrado',
            'Este QR code n√£o est√° no banco de dados',
            'warning',
            4000
        );

        // Focar automaticamente no campo de nome
        setTimeout(() => {
            inputName.focus();
        }, 500);
    }
}

// Verificar se j√° existe cliente cadastrado com o endere√ßo
async function checkClientByAddress(address) {
    try {
        // Extrair a primeira linha do endere√ßo (rua e n√∫mero) para busca
        const addressFirstLine = address.split('\n')[0].trim();

        const { data, error } = await supabase
            .from('clients')
            .select('*')
            .ilike('address', `%${addressFirstLine}%`)
            .limit(1);

        if (error) {
            console.error('Erro ao verificar cliente:', error);
            return null;
        }

        return data && data.length > 0 ? data[0] : null;
    } catch (error) {
        console.error('Erro ao verificar cliente:', error);
        return null;
    }
}

// Vari√°vel global para armazenar dados do cliente a ser atualizado
let pendingLocationUpdate = null;

// Mostrar modo de atualiza√ß√£o de localiza√ß√£o (cliente j√° cadastrado)
function showUpdateLocationPanel(client, addressData) {
    // Fechar o modal do QR code
    closeModal();

    // Armazenar dados do cliente para atualiza√ß√£o
    pendingLocationUpdate = {
        clientId: client.id,
        clientName: client.name,
        clientAddress: client.address
    };

    // Criar banner no topo da tela com info do cliente
    createClientInfoBanner(client);

    // Transformar bot√£o "Adicionar Cliente" em "Atualizar Localiza√ß√£o"
    transformAddButtonToUpdate();

    // Centralizar no marcador do cliente se existir com zoom 80%
    if (client.latitude && client.longitude) {
        const clientPos = { lat: client.latitude, lng: client.longitude };
        map.panTo(clientPos);
        map.setZoom(20); // Zoom 80%
    }

    showToast(
        '‚úÖ Cliente j√° cadastrado!',
        'Aproxime o mapa e clique no bot√£o para atualizar',
        'info',
        4000
    );
}

// Criar banner no topo da tela com informa√ß√µes do cliente
function createClientInfoBanner(client) {
    // Remover banner anterior se existir
    const existingBanner = document.getElementById('client-info-banner');
    if (existingBanner) existingBanner.remove();

    const banner = document.createElement('div');
    banner.id = 'client-info-banner';
    banner.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        background: linear-gradient(135deg, #1976D2 0%, #1565C0 100%);
        color: white;
        padding: 12px 16px;
        z-index: 9999;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
    `;

    // Formatar endere√ßo completo
    const fullAddress = client.address.replace(/\n/g, ' ‚Ä¢ ');

    banner.innerHTML = `
        <div style="flex: 1; min-width: 0;">
            <div style="font-size: 14px; font-weight: 700; margin-bottom: 4px;">
                ${client.name}
            </div>
            <div style="font-size: 12px; opacity: 0.9; line-height: 1.3;">
                ${fullAddress}
            </div>
        </div>
        <button id="btn-cancel-location-update" style="
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            white-space: nowrap;
            flex-shrink: 0;
        ">
            ‚úï Cancelar
        </button>
    `;

    document.body.appendChild(banner);

    // Event listener para cancelar
    document.getElementById('btn-cancel-location-update').addEventListener('click', () => {
        cancelLocationUpdate();
    });
}

// Transformar bot√£o "Adicionar Cliente" em "Atualizar Localiza√ß√£o"
function transformAddButtonToUpdate() {
    const btnAddClient = document.getElementById('btn-add-client');
    if (!btnAddClient) return;

    // Salvar estado original
    btnAddClient.dataset.originalHtml = btnAddClient.innerHTML;
    btnAddClient.dataset.originalBackground = btnAddClient.style.background || '';

    // Transformar em bot√£o de atualiza√ß√£o
    btnAddClient.innerHTML = 'üîÑ Atualizar Localiza√ß√£o';
    btnAddClient.style.background = 'linear-gradient(135deg, #ff9800 0%, #f57c00 100%)';
    btnAddClient.style.animation = 'pulse-update 1.5s infinite';

    // Adicionar anima√ß√£o CSS se n√£o existir
    if (!document.getElementById('update-button-animation')) {
        const style = document.createElement('style');
        style.id = 'update-button-animation';
        style.textContent = `
            @keyframes pulse-update {
                0%, 100% { transform: translateX(-50%) scale(1); box-shadow: 0 4px 15px rgba(255, 152, 0, 0.4); }
                50% { transform: translateX(-50%) scale(1.05); box-shadow: 0 6px 20px rgba(255, 152, 0, 0.6); }
            }
        `;
        document.head.appendChild(style);
    }

    // Marcar como modo de atualiza√ß√£o
    btnAddClient.dataset.updateMode = 'true';
}

// Restaurar bot√£o "Adicionar Cliente" ao estado original
function restoreAddButton() {
    const btnAddClient = document.getElementById('btn-add-client');
    if (!btnAddClient) return;

    // Restaurar estado original
    if (btnAddClient.dataset.originalHtml) {
        btnAddClient.innerHTML = btnAddClient.dataset.originalHtml;
    } else {
        btnAddClient.innerHTML = '+ Adicionar Cliente';
    }

    btnAddClient.style.background = btnAddClient.dataset.originalBackground || '';
    btnAddClient.style.animation = '';

    // Remover marca√ß√£o de modo de atualiza√ß√£o
    delete btnAddClient.dataset.updateMode;
    delete btnAddClient.dataset.originalHtml;
    delete btnAddClient.dataset.originalBackground;
}

// Cancelar modo de atualiza√ß√£o de localiza√ß√£o
function cancelLocationUpdate() {
    pendingLocationUpdate = null;

    // Remover banner
    const banner = document.getElementById('client-info-banner');
    if (banner) banner.remove();

    // Restaurar bot√£o
    restoreAddButton();

    showToast(
        'Atualiza√ß√£o cancelada',
        'O bot√£o voltou ao estado original',
        'info',
        2000
    );
}

// Atualizar localiza√ß√£o do cliente no banco de dados
async function updateClientLocation(clientId, clientName) {
    // Obter posi√ß√£o GPS atual
    let currentPosition = null;

    if (gpsTracker && gpsTracker.markerCoords) {
        currentPosition = gpsTracker.markerCoords;
    } else if (userLocationMarker) {
        if (userLocationMarker.position) {
            currentPosition = userLocationMarker.position;
        } else if (userLocationMarker.getPosition) {
            const pos = userLocationMarker.getPosition();
            currentPosition = { lat: pos.lat(), lng: pos.lng() };
        }
    }

    if (!currentPosition || !currentPosition.lat || !currentPosition.lng) {
        showToast(
            '‚ùå Erro de GPS',
            'N√£o foi poss√≠vel obter sua localiza√ß√£o atual',
            'error',
            4000
        );
        return;
    }

    try {
        // Atualizar no banco de dados
        const { error } = await supabase
            .from('clients')
            .update({
                latitude: currentPosition.lat,
                longitude: currentPosition.lng
            })
            .eq('id', clientId);

        if (error) {
            throw error;
        }

        showToast(
            '‚úÖ Localiza√ß√£o Atualizada!',
            `${clientName} - Nova posi√ß√£o salva no mapa`,
            'success',
            5000
        );

        // Limpar modo de atualiza√ß√£o
        pendingLocationUpdate = null;

        // Remover banner do topo
        const banner = document.getElementById('client-info-banner');
        if (banner) banner.remove();

        // Restaurar bot√£o ao estado original
        restoreAddButton();

        // Recarregar marcadores para refletir a mudan√ßa
        if (typeof toggleClientsOnMap === 'function') {
            // Desligar e ligar novamente para atualizar
            if (clientsVisible) {
                await toggleClientsOnMap();
                await toggleClientsOnMap();
            }
        }

    } catch (error) {
        console.error('Erro ao atualizar localiza√ß√£o:', error);
        showToast(
            '‚ùå Erro ao atualizar',
            'N√£o foi poss√≠vel salvar a nova localiza√ß√£o',
            'error',
            4000
        );
    }
}

// Mostrar formul√°rio normal de cadastro
function showNormalRegistrationForm() {
    const form = document.getElementById('form-add-client');
    const formFooter = document.querySelector('#modal-add-client .form-footer');

    if (form) form.style.display = 'block';
    if (formFooter) formFooter.style.display = 'flex';

    // Remover painel de atualiza√ß√£o se existir
    const updatePanel = document.getElementById('update-location-panel');
    if (updatePanel) updatePanel.remove();
}


// Buscar dados completos do endere√ßo no banco de dados (delivery_data)
async function lookupAddressData(qrCode) {
    try {
        // Buscar na tabela delivery_data pelo SPX TN (c√≥digo QR)
        const { data, error } = await supabase
            .from('delivery_data')
            .select('*')
            .eq('spx_tn', qrCode)
            .single();

        if (error) {
            console.warn('Erro ao buscar QR code:', error);
            // Fallback: buscar no addressDatabase hardcoded (compatibilidade)
            if (addressDatabase[qrCode]) {
                return addressDatabase[qrCode];
            }
            return null;
        }

        if (data) {
            // Formatar endere√ßo no mesmo padr√£o
            let formattedAddress = data.destination_address || '';
            if (data.bairro) {
                formattedAddress += `\nBairro: ${data.bairro}`;
            }
            if (data.city && data.zipcode) {
                formattedAddress += `\n${data.city} - ${data.zipcode}`;
            }

            return {
                address: formattedAddress,
                latitude: data.latitude,
                longitude: data.longitude
            };
        }

        // Se n√£o encontrou no Supabase, tentar no addressDatabase
        if (addressDatabase[qrCode]) {
            return addressDatabase[qrCode];
        }

        return null;

    } catch (error) {
        console.error('Erro ao buscar endere√ßo:', error);
        // Fallback: buscar no addressDatabase
        if (addressDatabase[qrCode]) {
            return addressDatabase[qrCode];
        }
        return null;
    }
}

// Buscar endere√ßo no banco de dados (fun√ß√£o legada - mantida para compatibilidade)
async function lookupAddress(qrCode) {
    const data = await lookupAddressData(qrCode);
    return data ? data.address : null;
}

// ===========================
// SALVAR CLIENTE
// ===========================

form.addEventListener('submit', async (e) => {
    e.preventDefault();

    // Preparar dados do cliente
    const clientData = {
        name: inputName.value.trim(),
        phone: inputPhone.value.trim(),
        address: scannedAddress,
        created_at: new Date().toISOString()
    };

    // SEMPRE adicionar coordenadas da localiza√ß√£o atual do usu√°rio
    let currentPosition = null;
    if (userLocationMarker) {
        if (userLocationMarker.position) {
            currentPosition = userLocationMarker.position;
        } else if (userLocationMarker.getPosition) {
            currentPosition = userLocationMarker.getPosition();
        }
    }

    if (currentPosition) {
        clientData.latitude = currentPosition.lat;
        clientData.longitude = currentPosition.lng;
        console.log('üìç Salvando localiza√ß√£o atual:', currentPosition);
    } else {
        // Fallback: usar coordenadas do QR code se dispon√≠veis
        if (scannedLatLng) {
            clientData.latitude = scannedLatLng.latitude;
            clientData.longitude = scannedLatLng.longitude;
            console.log('üìç Usando coordenadas do QR code:', scannedLatLng);
        } else {
            console.warn('‚ö†Ô∏è Nenhuma coordenada dispon√≠vel para salvar');
        }
    }

    // Valida√ß√£o
    if (!clientData.name) {
        showToast(
            'Campo obrigat√≥rio',
            'Preencha o nome do cliente',
            'error',
            4000
        );
        return;
    }

    if (!clientData.address) {
        showToast(
            'Escaneie o QR Code',
            '√â necess√°rio escanear o QR Code do pacote primeiro',
            'error',
            4000
        );
        return;
    }

    // Loading
    btnSave.classList.add('loading');
    btnSave.disabled = true;

    try {
        if (isEditMode && editingClientId) {
            // MODO EDI√á√ÉO - Atualizar cliente existente
            const { data, error } = await supabase
                .from('clients')
                .update(clientData)
                .eq('id', editingClientId)
                .select();

            if (error) throw error;

            console.log('Cliente atualizado:', data);

            showToast(
                'Cliente atualizado!',
                `${clientData.name} foi atualizado com sucesso`,
                'success',
                4000
            );
        } else {
            // MODO CRIA√á√ÉO - Inserir novo cliente
            const { data, error } = await supabase
                .from('clients')
                .insert([clientData])
                .select();

            if (error) throw error;

            console.log('Cliente salvo:', data);

            showToast(
                'Cliente adicionado!',
                `${clientData.name} foi cadastrado com sucesso`,
                'success',
                4000
            );
        }

        // Atualizar lista de clientes no sidebar
        await loadClients();

        closeModal();

    } catch (error) {
        console.error('Erro ao salvar cliente:', error);
        showToast(
            'Erro ao salvar',
            error.message || 'N√£o foi poss√≠vel salvar o cliente',
            'error',
            5000
        );
    } finally {
        btnSave.classList.remove('loading');
        btnSave.disabled = false;
    }
});

// ===========================
// SIDEBAR - MENU LATERAL
// ===========================

const sidebar = document.getElementById('sidebar');
const sidebarOverlay = document.getElementById('sidebar-overlay');
const btnOpenSidebar = document.getElementById('btnOpenSidebar');
const btnCloseSidebar = document.getElementById('sidebar-close');
const clientsList = document.getElementById('clients-list');
const searchInput = document.getElementById('search-input');
const clientCount = document.getElementById('client-count');

let allClients = [];
let filteredClients = [];

// Abrir sidebar
btnOpenSidebar.addEventListener('click', () => {
    openSidebar();
    loadClients();
});

// Fechar sidebar
btnCloseSidebar.addEventListener('click', closeSidebar);
sidebarOverlay.addEventListener('click', closeSidebar);

function openSidebar() {
    sidebar.classList.add('open');
    sidebarOverlay.classList.add('active');
}

function closeSidebar() {
    sidebar.classList.remove('open');
    sidebarOverlay.classList.remove('active');
}

// Busca em tempo real
searchInput.addEventListener('input', (e) => {
    const searchTerm = e.target.value.toLowerCase().trim();

    if (searchTerm === '') {
        filteredClients = allClients;
    } else {
        filteredClients = allClients.filter(client => {
            const name = (client.name || '').toLowerCase();
            const address = (client.address || '').toLowerCase();
            const phone = (client.phone || '').toLowerCase();

            return name.includes(searchTerm) ||
                   address.includes(searchTerm) ||
                   phone.includes(searchTerm);
        });
    }

    renderClients(filteredClients);
});

// Carregar clientes do Supabase
async function loadClients() {
    try {
        const { data, error } = await supabase
            .from('clients')
            .select('*')
            .order('created_at', { ascending: false });

        if (error) {
            console.error('Erro do Supabase:', error);
            throw error;
        }

        allClients = data || [];
        filteredClients = allClients;

        renderClients(filteredClients);
        updateClientCount(allClients.length);

        console.log(`${allClients.length} cliente(s) carregado(s)`);

    } catch (error) {
        console.error('Erro ao carregar clientes:', error);

        // Mostrar mensagem mais espec√≠fica
        let errorMsg = 'N√£o foi poss√≠vel carregar a lista de clientes';

        if (error.message && error.message.includes('Failed to fetch')) {
            errorMsg = 'Verifique se a tabela "clients" existe no Supabase';
        } else if (error.code) {
            errorMsg = `Erro Supabase: ${error.message}`;
        }

        showToast(
            'Erro ao carregar',
            errorMsg,
            'error',
            6000
        );

        // Mostrar empty state mesmo com erro
        renderClients([]);
    }
}

// Renderizar lista de clientes
function renderClients(clients) {
    if (!clients || clients.length === 0) {
        clientsList.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon">üìã</div>
                <div class="empty-state-text">Nenhum cliente encontrado</div>
                <div class="empty-state-subtext">${searchInput.value ? 'Tente outra busca' : 'Adicione clientes para v√™-los aqui'}</div>
            </div>
        `;
        return;
    }

    const clientsHTML = clients.map(client => `
        <div class="client-card" data-client-id="${client.id}">
            <div class="client-card-header">
                <div class="client-name">
                    <span>üë§</span>
                    <span>${escapeHtml(client.name)}</span>
                </div>
                <div class="client-actions">
                    <button class="client-action-btn navigate-btn" data-client-id="${client.id}" title="Navegar at√© o cliente">
                        üß≠
                    </button>
                    <button class="client-action-btn edit-btn" data-client-id="${client.id}" title="Editar">
                        ‚úèÔ∏è
                    </button>
                    <button class="client-action-btn delete-btn" data-client-id="${client.id}" title="Excluir">
                        üóëÔ∏è
                    </button>
                </div>
            </div>
            ${client.phone ? `
                <div class="client-info phone-info">
                    <span class="client-info-icon">üìû</span>
                    <span>${escapeHtml(client.phone)}</span>
                    <div class="phone-actions">
                        <a href="tel:${client.phone.replace(/\D/g, '')}" class="phone-action-btn call-btn" title="Ligar" onclick="event.stopPropagation()">
                            <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M6.62 10.79c1.44 2.83 3.76 5.14 6.59 6.59l2.2-2.2c.27-.27.67-.36 1.02-.24 1.12.37 2.33.57 3.57.57.55 0 1 .45 1 1V20c0 .55-.45 1-1 1-9.39 0-17-7.61-17-17 0-.55.45-1 1-1h3.5c.55 0 1 .45 1 1 0 1.25.2 2.45.57 3.57.11.35.03.74-.25 1.02l-2.2 2.2z" fill="white"/>
                            </svg>
                        </a>
                        <a href="https://wa.me/55${client.phone.replace(/\D/g, '')}" target="_blank" class="phone-action-btn whatsapp-btn" title="WhatsApp" onclick="event.stopPropagation()">
                            <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M12.04 2c-5.46 0-9.91 4.45-9.91 9.91 0 1.75.46 3.45 1.32 4.95L2.05 22l5.25-1.38c1.45.79 3.08 1.21 4.74 1.21 5.46 0 9.91-4.45 9.91-9.91 0-2.65-1.03-5.14-2.9-7.01A9.816 9.816 0 0012.04 2m.01 1.67c2.2 0 4.26.86 5.82 2.42a8.225 8.225 0 012.41 5.83c0 4.54-3.7 8.23-8.24 8.23-1.48 0-2.93-.39-4.19-1.15l-.3-.17-3.12.82.83-3.04-.2-.32a8.188 8.188 0 01-1.26-4.38c.01-4.54 3.7-8.24 8.25-8.24M8.53 7.33c-.16 0-.43.06-.66.31-.22.25-.87.85-.87 2.07 0 1.22.89 2.39 1 2.56.14.17 1.76 2.67 4.25 3.73.59.27 1.05.42 1.41.53.59.19 1.13.16 1.56.1.48-.07 1.46-.6 1.67-1.18.21-.58.21-1.07.15-1.18-.07-.1-.23-.16-.48-.27-.25-.14-1.47-.74-1.69-.82-.23-.08-.37-.12-.56.12-.16.25-.64.81-.78.97-.15.17-.29.19-.53.07-.26-.13-1.06-.39-2-1.23-.74-.66-1.23-1.47-1.38-1.72-.14-.25-.02-.39.11-.5.11-.11.25-.29.37-.44.13-.14.17-.25.25-.41.08-.17.04-.31-.02-.43-.06-.11-.56-1.35-.76-1.84-.2-.48-.4-.42-.56-.43-.14 0-.3-.01-.47-.01z" fill="white"/>
                            </svg>
                        </a>
                    </div>
                </div>
            ` : ''}
            ${client.address ? `
                <div class="client-info">
                    <span class="client-info-icon">üìç</span>
                    <span>${escapeHtml(client.address.replace(/C√≥digo QR:.*?\(/g, '(').replace(/BR\d+/g, '').trim())}</span>
                </div>
            ` : ''}
        </div>
    `).join('');

    clientsList.innerHTML = clientsHTML;

    // Adicionar event listeners aos cards
    document.querySelectorAll('.client-card').forEach(card => {
        card.addEventListener('click', (e) => {
            // N√£o abrir detalhes se clicou em um bot√£o de a√ß√£o
            if (e.target.closest('.client-action-btn')) {
                return;
            }

            const clientId = card.getAttribute('data-client-id');
            const client = clients.find(c => c.id === clientId);
            if (client) {
                showClientDetails(client);
            }
        });
    });

    // Event listeners para bot√µes de navegar
    document.querySelectorAll('.navigate-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const clientId = btn.getAttribute('data-client-id');
            const client = clients.find(c => c.id === clientId);
            if (client) {
                // Buscar marker do cliente se existir
                const marker = clientMarkers[clientId] || null;
                navigateToClient(client, marker, null);
            }
        });
    });

    // Event listeners para bot√µes de editar
    document.querySelectorAll('.edit-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const clientId = btn.getAttribute('data-client-id');
            const client = clients.find(c => c.id === clientId);
            if (client) {
                editClient(client);
            }
        });
    });

    // Event listeners para bot√µes de excluir
    document.querySelectorAll('.delete-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const clientId = btn.getAttribute('data-client-id');
            const client = clients.find(c => c.id === clientId);
            if (client) {
                deleteClient(client);
            }
        });
    });

    // Event listeners para bot√µes de telefone - reset agressivo com class toggle
    document.querySelectorAll('.phone-action-btn').forEach(btn => {
        // Touchstart - preparar para reset
        btn.addEventListener('touchstart', function(e) {
            e.stopPropagation();
            this.setAttribute('data-touched', 'true');
        }, { passive: true });

        // Touch end - resetar com class toggle para for√ßar re-render
        btn.addEventListener('touchend', function(e) {
            e.stopPropagation();
            const element = this;

            // Reset imediato com requestAnimationFrame para for√ßar reflow
            requestAnimationFrame(() => {
                element.blur();

                // Remove e readiciona classe para for√ßar re-render
                element.classList.remove('btn-reset');
                void element.offsetWidth; // For√ßa reflow
                element.classList.add('btn-reset');

                // Remove todos os estilos inline
                element.removeAttribute('style');

                // Remove atributo de touch
                element.removeAttribute('data-touched');
            });

            // Segundo reset ap√≥s um delay
            setTimeout(() => {
                element.blur();
                element.removeAttribute('style');
                element.classList.remove('btn-reset');
                void element.offsetWidth;
                element.classList.add('btn-reset');
            }, 100);
        });

        // Click - reset similar
        btn.addEventListener('click', function(e) {
            const element = this;

            requestAnimationFrame(() => {
                element.blur();
                element.classList.remove('btn-reset');
                void element.offsetWidth;
                element.classList.add('btn-reset');
                element.removeAttribute('style');
            });

            setTimeout(() => {
                element.blur();
                element.removeAttribute('style');
            }, 150);
        });

        // Mouseout - limpar estados residuais
        btn.addEventListener('mouseout', function() {
            this.blur();
            this.removeAttribute('style');
        });
    });

    // Listener global para resetar quando volta do app externo
    window.removeEventListener('focus', resetPhoneButtonsFocus);
    window.addEventListener('focus', resetPhoneButtonsFocus);

    // Listener para quando a p√°gina fica vis√≠vel novamente
    document.removeEventListener('visibilitychange', resetPhoneButtonsFocus);
    document.addEventListener('visibilitychange', function() {
        if (!document.hidden) {
            resetPhoneButtonsFocus();
        }
    });
}

// Fun√ß√£o para resetar foco dos bot√µes de telefone - vers√£o agressiva
function resetPhoneButtonsFocus() {
    requestAnimationFrame(() => {
        // Resetar TODOS os bot√µes de telefone
        document.querySelectorAll('.phone-action-btn').forEach(btn => {
            // Remove foco
            btn.blur();

            // Remove todos os estilos inline
            btn.removeAttribute('style');

            // Remove e readiciona classe para for√ßar re-render
            btn.classList.remove('btn-reset');
            void btn.offsetWidth; // For√ßa reflow
            btn.classList.add('btn-reset');

            // Remove atributos residuais
            btn.removeAttribute('data-touched');
        });

        // Remover foco dos cards
        document.querySelectorAll('.client-card').forEach(card => {
            card.blur();
            card.style.outline = 'none';
        });

        // Criar input tempor√°rio para roubar foco completamente
        const tempInput = document.createElement('input');
        tempInput.style.cssText = 'position:absolute;opacity:0;height:0;width:0;left:-9999px;pointer-events:none;';
        tempInput.setAttribute('tabindex', '-1');
        tempInput.setAttribute('aria-hidden', 'true');
        document.body.appendChild(tempInput);

        tempInput.focus();

        setTimeout(() => {
            tempInput.blur();
            if (document.body.contains(tempInput)) {
                document.body.removeChild(tempInput);
            }

            // Reset final dos bot√µes
            document.querySelectorAll('.phone-action-btn').forEach(btn => {
                btn.removeAttribute('style');
                btn.blur();
            });
        }, 50);
    });
}

// Atualizar contador de clientes
function updateClientCount(count) {
    clientCount.textContent = count;
}

// Mostrar detalhes do cliente e centralizar no mapa
function showClientDetails(client) {
    // Fechar sidebar
    closeSidebar();

    let targetPosition = null;
    let qrCodeMatch = null;

    // Prioridade 1: Usar coordenadas salvas no cliente (se dispon√≠veis)
    if (client.latitude && client.longitude) {
        targetPosition = {
            lat: client.latitude,
            lng: client.longitude
        };
        console.log('Usando coordenadas do cliente:', targetPosition);
    } else {
        // Prioridade 2: Procurar nos dados da planilha pelo endere√ßo do cliente
        for (const [qrCode, data] of Object.entries(addressDatabase)) {
            if (client.address && client.address.includes(data.address.split('\n')[0])) {
                targetPosition = {
                    lat: data.latitude,
                    lng: data.longitude
                };
                qrCodeMatch = qrCode;
                console.log('Coordenadas encontradas na planilha:', targetPosition);
                break;
            }
        }
    }

    if (targetPosition) {
        // Centralizar no endere√ßo encontrado
        map.setCenter(targetPosition);
        map.setZoom(18);

        // Criar marcador tempor√°rio para mostrar a localiza√ß√£o do cliente
        const clientMarkerDiv = document.createElement('div');
        clientMarkerDiv.style.width = '40px';
        clientMarkerDiv.style.height = '40px';
        clientMarkerDiv.style.background = '#4285f4';
        clientMarkerDiv.style.border = '3px solid white';
        clientMarkerDiv.style.borderRadius = '50%';
        clientMarkerDiv.style.boxShadow = '0 2px 10px rgba(0,0,0,0.4)';
        clientMarkerDiv.style.display = 'flex';
        clientMarkerDiv.style.alignItems = 'center';
        clientMarkerDiv.style.justifyContent = 'center';
        clientMarkerDiv.style.fontSize = '20px';
        clientMarkerDiv.innerHTML = 'üë§';

        let tempMarker;
        try {
            if (google.maps.marker && google.maps.marker.AdvancedMarkerElement) {
                tempMarker = new google.maps.marker.AdvancedMarkerElement({
                    map,
                    position: targetPosition,
                    content: clientMarkerDiv,
                    title: client.name
                });
            } else {
                tempMarker = new google.maps.Marker({
                    map,
                    position: targetPosition,
                    title: client.name,
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 12,
                        fillColor: '#4285f4',
                        fillOpacity: 1,
                        strokeColor: 'white',
                        strokeWeight: 3
                    },
                    label: {
                        text: 'üë§',
                        color: 'white',
                        fontSize: '16px'
                    }
                });
            }

            // Remover marcador tempor√°rio ap√≥s 5 segundos
            setTimeout(() => {
                if (tempMarker.map !== undefined) {
                    tempMarker.map = null;
                } else if (tempMarker.setMap) {
                    tempMarker.setMap(null);
                }
            }, 5000);
        } catch (error) {
            console.warn('Erro ao criar marcador tempor√°rio:', error);
        }

        // Destacar o marcador correspondente (apenas se estiver no modo de rota)
        if (qrCodeMatch && deliveryMarkers[qrCodeMatch]) {
            try {
                // Verificar se √© AdvancedMarkerElement ou Marker cl√°ssico
                const marker = deliveryMarkers[qrCodeMatch];

                if (marker.content && marker.content.style) {
                    // AdvancedMarkerElement
                    const markerElement = marker.content;
                    markerElement.style.transform = 'scale(1.5)';
                    markerElement.style.background = '#fbbc04'; // Amarelo para destaque

                    setTimeout(() => {
                        markerElement.style.transform = 'scale(1)';
                        markerElement.style.background = '#ea4335'; // Voltar ao vermelho
                    }, 2000);
                } else if (marker.setIcon) {
                    // Marker cl√°ssico - trocar cor temporariamente
                    const originalIcon = marker.getIcon();
                    marker.setIcon({
                        ...originalIcon,
                        fillColor: '#fbbc04',
                        scale: 12
                    });

                    setTimeout(() => {
                        marker.setIcon(originalIcon);
                    }, 2000);
                }
            } catch (error) {
                console.warn('Erro ao destacar marcador:', error);
            }
        }

        showToast(
            `üìç ${client.name}`,
            client.address,
            'success',
            4000
        );
    } else {
        // Se n√£o encontrar coordenadas, apenas mostrar informa√ß√µes
        showToast(
            client.name,
            `üìû ${client.phone || 'Sem telefone'}\nüìç ${client.address}`,
            'info',
            5000
        );
    }
}

// ===========================
// EDITAR CLIENTE
// ===========================

let isEditMode = false;
let editingClientId = null;

async function editClient(client) {
    isEditMode = true;
    editingClientId = client.id;

    // Abrir modal (sem fechar sidebar)
    modal.classList.add('active');
    document.body.style.overflow = 'hidden';

    // Preencher campos com dados atuais
    inputName.value = client.name || '';
    inputPhone.value = client.phone || '';

    // Mostrar endere√ßo
    scannedAddress = client.address || '';
    addressText.textContent = scannedAddress;
    if (scannedAddress) {
        addressDisplay.classList.add('active');
    }

    // Salvar coordenadas existentes
    if (client.latitude && client.longitude) {
        scannedLatLng = {
            latitude: client.latitude,
            longitude: client.longitude
        };
    }

    // Trocar texto do bot√£o
    btnSave.textContent = 'Atualizar Cliente';

    // Modificar o t√≠tulo do scanner
    const scannerTitle = document.querySelector('.scanner-title span');
    if (scannerTitle) {
        scannerTitle.textContent = '‚úèÔ∏è Editando Cliente';
    }

    // Iniciar c√¢mera para o scanner QR Code
    try {
        await startCamera();
    } catch (error) {
        console.error('Erro ao abrir c√¢mera no modo de edi√ß√£o:', error);

        // Mensagem de erro para o usu√°rio
        let errorMessage = 'Verifique as permiss√µes do navegador';

        if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
            errorMessage = 'Permiss√£o negada. Permita o acesso √† c√¢mera nas configura√ß√µes do navegador.';
        } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
            errorMessage = 'Nenhuma c√¢mera encontrada no dispositivo.';
        } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
            errorMessage = 'C√¢mera j√° est√° em uso por outro aplicativo.';
        }

        showToast(
            'Erro ao abrir c√¢mera',
            errorMessage,
            'error',
            5000
        );
    }

    // Focar no nome
    setTimeout(() => {
        inputName.focus();
        inputName.select();
    }, 300);
}

// ===========================
// EXCLUIR CLIENTE
// ===========================

function deleteClient(client) {
    // Criar modal de confirma√ß√£o customizado
    const confirmModal = document.createElement('div');
    confirmModal.className = 'modal-overlay';
    confirmModal.style.zIndex = '10004';
    confirmModal.innerHTML = `
        <div class="modal-container" style="max-width: 400px;">
            <div class="modal-body" style="padding: 24px;">
                <h3 style="margin: 0 0 16px 0; color: #ea4335; font-size: 20px;">
                    üóëÔ∏è Confirmar Exclus√£o
                </h3>
                <p style="margin: 0 0 8px 0; color: #333; font-size: 16px;">
                    Deseja realmente excluir este cliente?
                </p>
                <div style="background: #f5f5f5; padding: 12px; border-radius: 8px; margin-top: 12px;">
                    <p style="margin: 0 0 4px 0; font-weight: 600; color: #333;">
                        ${escapeHtml(client.name)}
                    </p>
                    <p style="margin: 0; font-size: 14px; color: #666;">
                        ${client.phone ? 'üìû ' + escapeHtml(client.phone) : ''}
                    </p>
                </div>
                <p style="margin: 16px 0 0 0; font-size: 13px; color: #999;">
                    Esta a√ß√£o n√£o pode ser desfeita.
                </p>
            </div>
            <div class="form-footer">
                <button type="button" class="btn btn-secondary" id="btn-confirm-cancel">
                    Cancelar
                </button>
                <button type="button" class="btn btn-primary" id="btn-confirm-delete" style="background: #ea4335;">
                    Excluir
                </button>
            </div>
        </div>
    `;

    document.body.appendChild(confirmModal);

    // Animar entrada
    setTimeout(() => {
        confirmModal.classList.add('active');
    }, 10);

    // Bot√£o Cancelar
    const btnCancel = confirmModal.querySelector('#btn-confirm-cancel');
    btnCancel.addEventListener('click', () => {
        confirmModal.classList.remove('active');
        setTimeout(() => {
            confirmModal.remove();
        }, 300);
    });

    // Bot√£o Excluir
    const btnDelete = confirmModal.querySelector('#btn-confirm-delete');
    btnDelete.addEventListener('click', async () => {
        btnDelete.classList.add('loading');
        btnDelete.disabled = true;
        btnDelete.textContent = 'Excluindo...';

        try {
            // Excluir do Supabase
            const { error } = await supabase
                .from('clients')
                .delete()
                .eq('id', client.id);

            if (error) throw error;

            console.log('Cliente exclu√≠do:', client.id);

            showToast(
                'Cliente exclu√≠do!',
                `${client.name} foi removido com sucesso`,
                'success',
                3000
            );

            // Fechar modal de confirma√ß√£o
            confirmModal.classList.remove('active');
            setTimeout(() => {
                confirmModal.remove();
            }, 300);

            // Atualizar lista de clientes
            await loadClients();

        } catch (error) {
            console.error('Erro ao excluir cliente:', error);
            showToast(
                'Erro ao excluir',
                error.message || 'N√£o foi poss√≠vel excluir o cliente',
                'error',
                5000
            );
            btnDelete.classList.remove('loading');
            btnDelete.disabled = false;
            btnDelete.textContent = 'Excluir';
        }
    });

    // Fechar ao clicar fora
    confirmModal.addEventListener('click', (e) => {
        if (e.target === confirmModal) {
            confirmModal.classList.remove('active');
            setTimeout(() => {
                confirmModal.remove();
            }, 300);
        }
    });
}

// ===========================
// NAVEGAR AT√â O CLIENTE
// ===========================

async function navigateToClient(client, marker = null, infoWindow = null) {
    // Fechar sidebar
    closeSidebar();

    // Verificar se temos coordenadas do destino
    let destination = null;

    if (client.latitude && client.longitude) {
        destination = { lat: client.latitude, lng: client.longitude };
    } else {
        // Tentar encontrar no addressDatabase pelo endere√ßo
        const qrCodeMatch = Object.keys(addressDatabase).find(qr =>
            client.address && client.address.includes(qr)
        );

        if (qrCodeMatch && addressDatabase[qrCodeMatch]) {
            destination = {
                lat: addressDatabase[qrCodeMatch].latitude,
                lng: addressDatabase[qrCodeMatch].longitude
            };
        }
    }

    if (!destination) {
        showToast(
            '‚ö†Ô∏è Coordenadas n√£o encontradas',
            'Este cliente n√£o possui coordenadas GPS salvas',
            'error',
            4000
        );
        return;
    }

    // Obter localiza√ß√£o atual do usu√°rio
    let userPosition = null;
    if (userLocationMarker) {
        if (userLocationMarker.position) {
            userPosition = userLocationMarker.position;
        } else if (userLocationMarker.getPosition) {
            userPosition = userLocationMarker.getPosition();
        }
    }

    if (!userPosition) {
        showToast(
            '‚ö†Ô∏è Localiza√ß√£o n√£o dispon√≠vel',
            'Ative a localiza√ß√£o GPS para navegar',
            'error',
            4000
        );
        return;
    }

    showToast(
        'üß≠ Calculando rota...',
        `Tra√ßando caminho at√© ${client.name}`,
        'info',
        3000
    );

    try {
        // Usar Directions API para rota ponto-a-ponto
        const directionsService = new google.maps.DirectionsService();

        const request = {
            origin: userPosition,
            destination: destination,
            travelMode: google.maps.TravelMode.DRIVING,
            optimizeWaypoints: false,
            language: 'pt-BR',
            region: 'BR'
        };

        const result = await directionsService.route(request);

        if (result.status === 'OK') {
            // Limpar rotas antigas
            if (window.routePolylines && window.routePolylines.length > 0) {
                window.routePolylines.forEach(polyline => {
                    if (polyline.setMap) {
                        polyline.setMap(null);
                    }
                });
                window.routePolylines = [];
            }

            // Desenhar nova rota
            const route = result.routes[0];
            const leg = route.legs[0];

            // Criar polyline para a rota
            const polyline = new google.maps.Polyline({
                path: route.overview_path,
                geodesic: true,
                strokeColor: '#4285f4',
                strokeOpacity: 0.8,
                strokeWeight: 5,
                map: map
            });

            window.routePolylines = [polyline];

            // Ajustar mapa para mostrar toda a rota
            const bounds = new google.maps.LatLngBounds();
            bounds.extend(userPosition);
            bounds.extend(destination);
            map.fitBounds(bounds);

            // Formatar dist√¢ncia e dura√ß√£o
            const distance = leg.distance.text;
            const duration = leg.duration.text;

            showToast(
                `üéØ Rota para ${client.name}`,
                `üìè Dist√¢ncia: ${distance}\n‚è±Ô∏è Tempo estimado: ${duration}`,
                'success',
                5000
            );

            console.log('‚úÖ Rota calculada:', {
                distance: leg.distance,
                duration: leg.duration,
                steps: leg.steps.length
            });

            // Iniciar modo de navega√ß√£o em tempo real
            startNavigationMode(destination, client.name, marker, infoWindow);

        } else {
            throw new Error(`Directions API retornou status: ${result.status}`);
        }

    } catch (error) {
        console.error('Erro ao calcular rota:', error);
        showToast(
            '‚ùå Erro ao calcular rota',
            error.message || 'N√£o foi poss√≠vel tra√ßar o caminho',
            'error',
            5000
        );
    }
}

// Fun√ß√£o helper para escape HTML
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Carregar clientes ao inicializar e verificar se h√° dados da planilha
setTimeout(async () => {
    loadClients();

    // Verificar se h√° dados da planilha salvos no Supabase
    try {
        const { data, error } = await supabase
            .from('delivery_data')
            .select('id')
            .limit(1);

        if (!error && data && data.length > 0) {
            // Se h√° dados da planilha, mudar bot√£o para modo "Limpar"
            setButtonToClearMode();
            console.log('üìä Planilha detectada no banco de dados');
        } else {
            // Sem dados, manter bot√£o em modo "Upload"
            setButtonToUploadMode();
            console.log('üìã Nenhuma planilha no banco de dados');
        }
    } catch (error) {
        console.error('Erro ao verificar dados da planilha:', error);
    }
}, 2000);

// ===========================
// SISTEMA DE ROTAS DE ENTREGA
// ===========================

const btnToggleRoute = document.getElementById('btnToggleRoute');

btnToggleRoute.addEventListener('click', () => {
    if (!routeMode) {
        // Ativar modo de rota
        activateRouteMode();
    } else {
        // Desativar modo de rota
        deactivateRouteMode();
    }
});

// Bot√£o de limpar rotas e marcadores
const btnClearRoute = document.getElementById('btnClearRoute');
btnClearRoute.addEventListener('click', () => {
    clearAllRoutesAndMarkers();
});

async function activateRouteMode() {
    routeMode = true;
    btnToggleRoute.classList.add('active');

    // Esconder bot√£o de planejar rota e mostrar bot√£o de limpar
    btnToggleRoute.style.display = 'none';
    document.getElementById('btnClearRoute').style.display = 'flex';

    // Reativar DirectionsRenderer se necess√°rio
    if (directionsRenderer && !directionsRenderer.getMap()) {
        console.log('üîµ Reativando DirectionsRenderer...');
        directionsRenderer.setMap(map);
    }

    // Obter posi√ß√£o atual do usu√°rio
    let currentPosition;
    if (userLocationMarker) {
        if (userLocationMarker.position) {
            currentPosition = userLocationMarker.position;
        } else if (userLocationMarker.getPosition) {
            currentPosition = userLocationMarker.getPosition();
        }
    }

    if (!currentPosition) {
        showToast(
            'Localiza√ß√£o n√£o dispon√≠vel',
            'Aguarde obter sua posi√ß√£o GPS para calcular rotas',
            'warning',
            4000
        );
        deactivateRouteMode();
        return;
    }

    // NOVO: Adicionar marcadores do Supabase SOMENTE quando clicar
    await addDeliveryMarkers();

    // Rota otimizada desabilitada (Fleet Routing API quota esgotada)
    // await calculateOptimizedRouteFromDB(currentPosition);
}

function deactivateRouteMode() {
    routeMode = false;
    btnToggleRoute.classList.remove('active');

    // Mostrar bot√£o de planejar rota e esconder bot√£o de limpar
    btnToggleRoute.style.display = 'flex';
    document.getElementById('btnClearRoute').style.display = 'none';

    // Limpar rota do mapa COMPLETAMENTE
    if (directionsRenderer) {
        directionsRenderer.setDirections({routes: []});
        directionsRenderer.setMap(null);
    }

    // Limpar polylines (rotas em segmentos)
    if (window.routePolylines) {
        window.routePolylines.forEach(polyline => {
            polyline.setMap(null);
        });
        window.routePolylines = [];
    }

    // Remover marcadores de entrega
    Object.values(deliveryMarkers).forEach(marker => {
        if (marker.map) {
            marker.map = null; // Remove do mapa
        } else if (marker.setMap) {
            marker.setMap(null);
        }
    });

    showToast(
        'Modo de rota desativado',
        'Marcadores de entrega ocultados',
        'info',
        2000
    );
}

// Nova fun√ß√£o: Limpar TUDO (marcadores + rotas + cluster)
function clearAllRoutesAndMarkers() {
    console.log('üóëÔ∏è ========================================');
    console.log('üóëÔ∏è INICIANDO LIMPEZA COMPLETA...');
    console.log('üóëÔ∏è ========================================');

    // Desativar modo de rota se estiver ativo
    if (routeMode) {
        console.log('üî¥ Desativando modo de rota...');
        routeMode = false;
        btnToggleRoute.classList.remove('active');
    }

    // Esconder bot√£o de limpar e mostrar bot√£o de planejar rota novamente
    document.getElementById('btnClearRoute').style.display = 'none';
    btnToggleRoute.style.display = 'flex';

    // 1. Limpar DirectionsRenderer COMPLETAMENTE
    if (directionsRenderer) {
        console.log('üóëÔ∏è Limpando DirectionsRenderer...');
        try {
            directionsRenderer.setDirections({routes: []});
            directionsRenderer.setMap(null);
            directionsRenderer.setPanel(null);
            // Recriar DirectionsRenderer limpo
            directionsRenderer = new google.maps.DirectionsRenderer({
                map: null, // Inicialmente sem mapa
                suppressMarkers: false,
                polylineOptions: {
                    strokeColor: '#4285f4',
                    strokeWeight: 5,
                    strokeOpacity: 0.7
                }
            });
        } catch (e) {
            console.warn('Erro ao limpar DirectionsRenderer:', e);
        }
    }

    // 2. Limpar TODAS as polylines (array + verifica√ß√£o extra)
    let polylinesRemoved = 0;

    if (window.routePolylines && window.routePolylines.length > 0) {
        console.log(`üóëÔ∏è Removendo ${window.routePolylines.length} polylines do array...`);
        window.routePolylines.forEach(polyline => {
            try {
                if (polyline && polyline.setMap) {
                    polyline.setMap(null);
                    polylinesRemoved++;
                }
            } catch (e) {
                console.warn('Erro ao remover polyline:', e);
            }
        });
        window.routePolylines = [];
    } else {
        console.log('üóëÔ∏è Nenhuma polyline encontrada no array');
    }

    console.log(`‚úÖ ${polylinesRemoved} polylines removidas`);

    // 3. Remover TODOS os marcadores de entrega
    const markerCount = Object.keys(deliveryMarkers).length;
    if (markerCount > 0) {
        console.log(`üóëÔ∏è Removendo ${markerCount} marcadores de entrega...`);
        Object.values(deliveryMarkers).forEach(marker => {
            try {
                if (marker.map !== undefined) {
                    marker.map = null; // AdvancedMarkerElement
                } else if (marker.setMap) {
                    marker.setMap(null); // Marker cl√°ssico
                }
            } catch (e) {
                console.warn('Erro ao remover marcador:', e);
            }
        });
    }

    // 4. RESETAR completamente o objeto de marcadores
    deliveryMarkers = {};

    console.log('‚úÖ ========================================');
    console.log('‚úÖ LIMPEZA COMPLETA REALIZADA!');
    console.log('‚úÖ ========================================');

    showToast(
        'üóëÔ∏è Tudo limpo!',
        'Rotas e marcadores removidos do mapa',
        'success',
        3000
    );
}

async function calculateOptimizedRoute(origin) {
    // Marcadores j√° foram adicionados em activateRouteMode()
    // Removido: addDeliveryMarkers();

    showToast(
        'Calculando rota otimizada...',
        'Usando Fleet Routing API para todos os 73 endere√ßos',
        'info',
        4000
    );

    // Verificar se Project ID foi configurado
    if (GOOGLE_CLOUD_PROJECT_ID === "SEU_PROJECT_ID_AQUI") {
        showToast(
            '‚ö†Ô∏è Configura√ß√£o necess√°ria',
            'Configure o GOOGLE_CLOUD_PROJECT_ID no c√≥digo (linha 1799)',
            'error',
            8000
        );
        deactivateRouteMode();
        return;
    }

    // Obter todos os pontos de entrega
    let deliveryPoints = Object.values(addressDatabase).map(data => ({
        location: {lat: data.latitude, lng: data.longitude},
        address: data.address
    }));

    console.log(`Total de endere√ßos na planilha: ${deliveryPoints.length}`);

    // Remover pontos duplicados (mesmas coordenadas)
    const uniquePoints = [];
    const seenCoords = new Set();

    deliveryPoints.forEach(point => {
        const coordKey = `${point.location.lat.toFixed(6)},${point.location.lng.toFixed(6)}`;
        if (!seenCoords.has(coordKey)) {
            seenCoords.add(coordKey);
            uniquePoints.push(point);
        }
    });

    console.log(`Endere√ßos √∫nicos (sem duplicatas): ${uniquePoints.length}`);

    if (uniquePoints.length === 0) {
        showToast(
            'Nenhuma entrega encontrada',
            'N√£o h√° endere√ßos cadastrados para criar uma rota',
            'warning',
            4000
        );
        deactivateRouteMode();
        return;
    }

    // Usar Fleet Routing API para TODOS os pontos
    try {
        await calculateFleetRoute(origin, uniquePoints);
    } catch (error) {
        console.error('‚ùå ERRO ao calcular rota com Fleet API:', error);
        console.error('Mensagem do erro:', error.message);

        // Fallback para Directions API com limite de 23 pontos
        console.log('‚ö†Ô∏è USANDO FALLBACK: Directions API (limite de 23 pontos)...');

        showToast(
            '‚ö†Ô∏è Usando modo fallback',
            'Fleet API falhou. Calculando com 23 pontos mais pr√≥ximos.',
            'warning',
            6000
        );

        await calculateDirectionsRoute(origin, uniquePoints);
    }
}

// Nova fun√ß√£o: Calcular rota usando dados do Supabase
async function calculateOptimizedRouteFromDB(origin) {
    showToast(
        'Calculando rota otimizada...',
        'Buscando dados da planilha de entregas',
        'info',
        4000
    );

    try {
        // Buscar todos os dados da planilha do Supabase
        const { data: deliveryData, error } = await supabase
            .from('delivery_data')
            .select('*')
            .order('sequence', { ascending: true });

        if (error) throw error;

        if (!deliveryData || deliveryData.length === 0) {
            showToast(
                'Nenhuma entrega encontrada',
                'Fa√ßa upload de uma planilha para planejar rotas',
                'warning',
                4000
            );
            deactivateRouteMode();
            return;
        }

        // Criar array de pontos de entrega com endere√ßos formatados
        let deliveryPoints = deliveryData
            .filter(delivery => delivery.latitude && delivery.longitude)
            .map(delivery => {
                let address = delivery.destination_address || '';
                if (delivery.bairro) address += `, ${delivery.bairro}`;
                if (delivery.city) address += `, ${delivery.city}`;

                return {
                    location: { lat: delivery.latitude, lng: delivery.longitude },
                    address: address,
                    spx_tn: delivery.spx_tn,
                    sequence: delivery.sequence
                };
            });

        console.log(`Total de entregas na planilha: ${deliveryPoints.length}`);

        // Remover pontos duplicados (mesmas coordenadas)
        const uniquePoints = [];
        const seenCoords = new Set();

        deliveryPoints.forEach(point => {
            const coordKey = `${point.location.lat.toFixed(6)},${point.location.lng.toFixed(6)}`;
            if (!seenCoords.has(coordKey)) {
                seenCoords.add(coordKey);
                uniquePoints.push(point);
            }
        });

        console.log(`Endere√ßos √∫nicos (sem duplicatas): ${uniquePoints.length}`);

        if (uniquePoints.length === 0) {
            showToast(
                'Nenhuma entrega encontrada',
                'N√£o h√° clientes com coordenadas v√°lidas',
                'warning',
                4000
            );
            deactivateRouteMode();
            return;
        }

        // Verificar configura√ß√£o do Project ID
        if (typeof GOOGLE_CLOUD_PROJECT_ID !== 'undefined' && GOOGLE_CLOUD_PROJECT_ID !== "SEU_PROJECT_ID_AQUI") {
            // Usar Fleet Routing API se configurado
            await calculateFleetRoute(origin, uniquePoints);
        } else {
            // Fallback: usar Directions API (limitado a 23 pontos)
            if (uniquePoints.length > 23) {
                showToast(
                    '‚ö†Ô∏è Limite de endere√ßos',
                    `Voc√™ tem ${uniquePoints.length} entregas. Configure o Fleet Routing API para otimizar todas.`,
                    'warning',
                    6000
                );
                // Usar apenas os 23 primeiros
                const limitedPoints = uniquePoints.slice(0, 23);
                await calculateDirectionsRoute(origin, limitedPoints);
            } else {
                await calculateDirectionsRoute(origin, uniquePoints);
            }
        }

    } catch (error) {
        console.error('Erro ao calcular rota:', error);
        showToast(
            'Erro ao calcular rota',
            error.message || 'N√£o foi poss√≠vel processar os dados',
            'error',
            5000
        );
        deactivateRouteMode();
    }
}

// Nova fun√ß√£o: Fleet Routing API via Backend (suporta todos os pontos)
async function calculateFleetRoute(origin, deliveryPoints) {
    console.log(`üöÄ Chamando backend para otimizar ${deliveryPoints.length} pontos`);
    console.log(`Project ID: ${GOOGLE_CLOUD_PROJECT_ID}`);

    // Chamar API serverless do backend (Cloudflare Pages Function)
    const backendUrl = '/api/optimize-route';

    // Transformar deliveryPoints para o formato esperado pelo backend
    const formattedPoints = deliveryPoints.map(point => ({
        lat: point.location.lat,
        lng: point.location.lng,
        address: point.address || ''
    }));

    const payload = {
        origin: origin,
        deliveryPoints: formattedPoints,
        projectId: GOOGLE_CLOUD_PROJECT_ID
    };

    console.log('üì§ Enviando requisi√ß√£o para backend...');
    console.log('URL:', backendUrl);
    console.log(`Pontos: ${deliveryPoints.length}`);

    const response = await fetch(backendUrl, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
    });

    console.log(`üì• Resposta backend: Status ${response.status}`);

    if (!response.ok) {
        const errorData = await response.json();
        console.error('‚ùå ERRO do Backend:');
        console.error('Status:', response.status);
        console.error('Erro completo:', JSON.stringify(errorData, null, 2));

        // Logar detalhes espec√≠ficos se existirem
        if (errorData.details) {
            console.error('Detalhes do Google:', errorData.details);
        }
        if (errorData.requestModel) {
            console.error('Modelo enviado:', JSON.stringify(errorData.requestModel, null, 2));
        }

        showToast(
            '‚ùå Erro no Backend',
            errorData.message || 'N√£o foi poss√≠vel calcular a rota',
            'error',
            10000
        );

        throw new Error(`Backend falhou: ${response.status} - ${errorData.message}`);
    }

    const data = await response.json();

    if (!data.success || !data.result) {
        console.error('‚ùå Resposta inv√°lida do backend:', data);
        throw new Error('Resposta inv√°lida do backend');
    }

    console.log('‚úÖ Fleet Routing result:', data.result);
    console.log(`Rotas retornadas: ${data.result.routes?.length || 0}`);

    // Renderizar rota otimizada no mapa (passar deliveryPoints originais para mapear shipmentIndex)
    renderFleetRoute(data.result, origin, deliveryPoints);
}

// Renderizar resultado da Fleet Routing API
async function renderFleetRoute(fleetResult, origin, deliveryPoints) {
    const route = fleetResult.routes[0];

    if (!route || !route.visits) {
        showToast(
            'Erro ao processar rota',
            'N√£o foi poss√≠vel obter rota otimizada',
            'error',
            5000
        );
        deactivateRouteMode();
        return;
    }

    // Criar lista de pontos otimizados (origem + visitas + volta √† origem)
    const allPoints = [origin];

    console.log(`üìç Processando ${route.visits.length} visitas na ordem otimizada...`);

    route.visits.forEach((visit, index) => {
        // A Fleet API retorna apenas o shipmentIndex, n√£o as coordenadas
        // Precisamos buscar as coordenadas nos deliveryPoints originais
        let shipmentIndex = visit.shipmentIndex;

        // Fallback: se shipmentIndex n√£o existe, extrair do shipmentLabel
        if (shipmentIndex === undefined && visit.shipmentLabel) {
            // shipmentLabel √© "Entrega N" -> extrair N e converter para √≠ndice (N-1)
            const match = visit.shipmentLabel.match(/Entrega (\d+)/);
            if (match) {
                shipmentIndex = parseInt(match[1]) - 1; // Label come√ßa em 1, √≠ndice em 0
                console.log(`üîÑ Usando label para obter √≠ndice: ${visit.shipmentLabel} -> √≠ndice ${shipmentIndex}`);
            }
        }

        if (shipmentIndex !== undefined && deliveryPoints[shipmentIndex]) {
            const point = deliveryPoints[shipmentIndex].location;
            allPoints.push({
                lat: point.lat,
                lng: point.lng
            });
            console.log(`‚úÖ Visita ${index + 1}: Entrega #${shipmentIndex + 1} - ${visit.shipmentLabel}`);
        } else {
            console.warn(`‚ö†Ô∏è Visita ${index} sem shipmentIndex v√°lido:`, visit);
        }
    });

    // Adicionar retorno √† origem
    allPoints.push(origin);

    console.log(`Rota otimizada com ${route.visits.length} pontos de entrega`);
    console.log(`Total de pontos na rota: ${allPoints.length} (incluindo origem e retorno)`);

    // Desenhar a rota DIRETAMENTE usando m√∫ltiplas requisi√ß√µes √† Directions API
    // Dividir em segmentos de at√© 25 pontos cada
    await drawRouteInSegments(allPoints, route.visits.length);
}

// Desenhar rota em m√∫ltiplos segmentos (para mais de 25 pontos)
async function drawRouteInSegments(allPoints, totalDeliveries) {
    console.log(`üîµ Desenhando rota com ${allPoints.length} pontos totais`);

    // PASSO 1: Limpar TODAS as rotas anteriores COMPLETAMENTE
    if (directionsRenderer) {
        directionsRenderer.setMap(null);
    }

    // PASSO 2: Limpar polylines antigas se existirem
    if (window.routePolylines && window.routePolylines.length > 0) {
        console.log(`üóëÔ∏è Removendo ${window.routePolylines.length} polylines antigas antes de desenhar...`);
        window.routePolylines.forEach(polyline => {
            try {
                polyline.setMap(null);
            } catch (e) {
                console.warn('Erro ao remover polyline antiga:', e);
            }
        });
    }

    // PASSO 3: Resetar array de polylines
    window.routePolylines = [];

    // Dividir pontos em segmentos de at√© 25 (origem + 23 waypoints + destino)
    const segments = [];
    const maxWaypoints = 23;

    for (let i = 0; i < allPoints.length - 1; i += maxWaypoints + 1) {
        const segmentStart = i;
        const segmentEnd = Math.min(i + maxWaypoints + 1, allPoints.length - 1);

        const origin = allPoints[segmentStart];
        const destination = allPoints[segmentEnd];
        const waypoints = [];

        for (let j = segmentStart + 1; j < segmentEnd; j++) {
            waypoints.push({
                location: allPoints[j],
                stopover: true
            });
        }

        segments.push({ origin, destination, waypoints });
    }

    console.log(`Rota dividida em ${segments.length} segmento(s)`);

    // Desenhar todos os segmentos
    const polylines = [];
    const bounds = new google.maps.LatLngBounds();
    let totalDistance = 0;
    let totalDuration = 0;

    for (let i = 0; i < segments.length; i++) {
        const segment = segments[i];

        try {
            const result = await new Promise((resolve, reject) => {
                directionsService.route({
                    origin: segment.origin,
                    destination: segment.destination,
                    waypoints: segment.waypoints,
                    optimizeWaypoints: false, // J√Å otimizado pela Fleet API
                    travelMode: google.maps.TravelMode.DRIVING
                }, (result, status) => {
                    if (status === 'OK') {
                        resolve(result);
                    } else {
                        reject(new Error(`Segment ${i + 1} failed: ${status}`));
                    }
                });
            });

            // Calcular dist√¢ncia e tempo
            result.routes[0].legs.forEach(leg => {
                totalDistance += leg.distance.value;
                totalDuration += leg.duration.value;
            });

            // Criar polyline para este segmento
            const path = result.routes[0].overview_path;
            const polyline = new google.maps.Polyline({
                path: path,
                strokeColor: '#4285f4',
                strokeWeight: 5,
                strokeOpacity: 0.7,
                map: map
            });

            polylines.push(polyline);

            // Expandir bounds
            path.forEach(point => bounds.extend(point));

            console.log(`Segmento ${i + 1}/${segments.length} desenhado: ${segment.waypoints.length + 2} pontos`);

        } catch (error) {
            console.error(`Erro no segmento ${i + 1}:`, error);
        }

        // Pequeno delay entre requisi√ß√µes para evitar rate limit
        if (i < segments.length - 1) {
            await new Promise(resolve => setTimeout(resolve, 300));
        }
    }

    // Armazenar polylines para limpeza posterior
    window.routePolylines = polylines;
    console.log(`‚úÖ ${polylines.length} polylines armazenadas para limpeza futura`);

    // Ajustar zoom para mostrar toda a rota com padding
    if (!bounds.isEmpty()) {
        map.fitBounds(bounds, {
            padding: 100 // Margem de 100px ao redor da rota
        });
        console.log('üó∫Ô∏è Mapa ajustado para mostrar toda a rota otimizada');
    }

    // Mostrar estat√≠sticas
    const distanceKm = (totalDistance / 1000).toFixed(1);
    const durationMin = Math.round(totalDuration / 60);

    showToast(
        '‚úì Rota otimizada completa!',
        `${totalDeliveries} entregas ‚Ä¢ ${distanceKm} km ‚Ä¢ ${durationMin} min`,
        'success',
        10000
    );

    console.log(`‚úì Rota completa: ${totalDeliveries} entregas, ${distanceKm}km, ${durationMin}min`);
}

// Fallback: Directions API (at√© 23 pontos)
async function calculateDirectionsRoute(origin, deliveryPoints) {
    console.log(`Usando Directions API (fallback) com limite de 23 pontos`);

    const nearestPoints = deliveryPoints
        .map(point => ({
            ...point,
            distance: google.maps.geometry.spherical.computeDistanceBetween(
                new google.maps.LatLng(origin.lat, origin.lng),
                new google.maps.LatLng(point.location.lat, point.location.lng)
            )
        }))
        .sort((a, b) => a.distance - b.distance)
        .slice(0, 23);

    const waypoints = nearestPoints.slice(0, -1).map(point => ({
        location: point.location,
        stopover: true
    }));

    const destination = nearestPoints[nearestPoints.length - 1].location;

    const request = {
        origin: origin,
        destination: destination,
        waypoints: waypoints,
        optimizeWaypoints: true,
        travelMode: google.maps.TravelMode.DRIVING
    };

    directionsService.route(request, (result, status) => {
        if (status === 'OK') {
            directionsRenderer.setDirections(result);

            let totalDistance = 0;
            let totalDuration = 0;

            result.routes[0].legs.forEach(leg => {
                totalDistance += leg.distance.value;
                totalDuration += leg.duration.value;
            });

            const distanceKm = (totalDistance / 1000).toFixed(1);
            const durationMin = Math.round(totalDuration / 60);
            const totalPoints = waypoints.length + 2;

            showToast(
                '‚úì Rota calculada (Directions API)!',
                `${totalPoints} pontos de entrega ‚Ä¢ ${distanceKm} km ‚Ä¢ ${durationMin} min`,
                'success',
                8000
            );

            const bounds = new google.maps.LatLngBounds();
            result.routes[0].overview_path.forEach(point => bounds.extend(point));
            map.fitBounds(bounds);
        } else {
            console.error('Erro ao calcular rota:', status);
            showToast('Erro ao calcular rota', 'Tente novamente', 'error', 5000);
            deactivateRouteMode();
        }
    });
}

// ===========================
// SCANNER DE PACOTES
// ===========================

const modalScanPackage = document.getElementById('modal-scan-package');
const btnScanPackage = document.getElementById('btn-scan-package');
const btnModalScanClose = document.getElementById('modal-scan-close');
const btnPackageClose = document.getElementById('btn-package-close');
const btnPackageStopCamera = document.getElementById('btn-package-stop-camera');
const btnPackageSwitchCamera = document.getElementById('btn-package-switch-camera');
const qrPackageCameraContainer = document.getElementById('qr-package-camera-container');
const qrPackageVideo = document.getElementById('qr-package-video');
const qrPackageCanvas = document.getElementById('qr-package-canvas');
const qrPackageStatus = document.getElementById('qr-package-status');
const scanResult = document.getElementById('scan-result');
const scanResultText = document.getElementById('scan-result-text');

let packageVideoStream = null;
let packageScanningInterval = null;
let packageCurrentFacingMode = 'environment';
let packageLastScannedCode = null;

// Abrir modal de scanner de pacotes
async function openPackageScanner() {
    modalScanPackage.classList.add('active');
    document.body.style.overflow = 'hidden';

    // Resetar resultado anterior
    scanResult.classList.remove('active');
    scanResultText.textContent = '';

    // Verificar se c√¢mera est√° dispon√≠vel
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        showToast(
            'C√¢mera n√£o dispon√≠vel',
            'Seu navegador n√£o suporta acesso √† c√¢mera',
            'error',
            5000
        );
        return;
    }

    // Abrir c√¢mera automaticamente
    try {
        await startPackageCamera();
    } catch (error) {
        console.error('Erro ao abrir c√¢mera:', error);

        let errorMessage = 'Verifique as permiss√µes do navegador';

        if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
            errorMessage = 'Permiss√£o negada. Permita o acesso √† c√¢mera nas configura√ß√µes do navegador.';
        } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
            errorMessage = 'Nenhuma c√¢mera encontrada no dispositivo.';
        } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
            errorMessage = 'C√¢mera j√° est√° em uso por outro aplicativo.';
        }

        showToast(
            'Erro ao abrir c√¢mera',
            errorMessage,
            'error',
            7000
        );
    }
}

// Fechar modal de scanner de pacotes
function closePackageScanner() {
    modalScanPackage.classList.remove('active');
    document.body.style.overflow = '';
    stopPackageCamera();
}

// Iniciar c√¢mera do scanner de pacotes
async function startPackageCamera() {
    stopPackageCamera();

    // üöÄ LAZY LOADING: Carregar jsQR apenas quando necess√°rio
    if (!lazyLoader.isLoaded('jsQR')) {
        console.log('üì¶ [LAZY] Carregando jsQR pela primeira vez...');
        try {
            await lazyLoader.loadJsQR();
        } catch (error) {
            showToast('Erro ao carregar scanner', 'N√£o foi poss√≠vel carregar a biblioteca QR', 'error', 4000);
            return;
        }
    }

    // üéØ CONSTRAINTS EXATAMENTE COMO O GEMINI ESPECIFICA
    const constraints = {
        video: {
            facingMode: "environment", // Prioriza a c√¢mera traseira (como Gemini especificou)
            // Resolu√ß√£o otimizada para QR Code
            width: { ideal: 640 },  // Gemini: usar 640x480 para melhor performance
            height: { ideal: 480 },
            // ‚ú® Configura√ß√µes DIRETAS (sem { ideal: ... }) como Gemini especificou
            focusMode: "continuous",      // Mant√©m foco no objeto
            exposureMode: "continuous",   // Ajusta exposi√ß√£o automaticamente
            whiteBalanceMode: "continuous"
        }
    };

    try {
        packageVideoStream = await navigator.mediaDevices.getUserMedia(constraints);
        qrPackageVideo.srcObject = packageVideoStream;

        // ‚ú® Deixar o sistema operacional gerenciar exposi√ß√£o automaticamente
        // (removido c√≥digo que for√ßava brilho alto e causava superexposi√ß√£o)

        qrPackageCameraContainer.classList.add('active');

        return new Promise((resolve, reject) => {
            qrPackageVideo.onloadedmetadata = async () => {
                try {
                    await qrPackageVideo.play();
                    startPackageScanning();
                    resolve();
                } catch (playError) {
                    console.error('Erro ao iniciar reprodu√ß√£o do v√≠deo:', playError);
                    reject(playError);
                }
            };

            qrPackageVideo.onerror = (error) => {
                console.error('Erro no elemento de v√≠deo:', error);
                reject(error);
            };

            setTimeout(() => {
                if (qrPackageVideo.readyState < 2) {
                    reject(new Error('Timeout ao carregar v√≠deo'));
                }
            }, 10000);
        });

    } catch (error) {
        stopPackageCamera();
        qrPackageCameraContainer.classList.remove('active');
        throw error;
    }
}

// Parar c√¢mera do scanner de pacotes
function stopPackageCamera() {
    if (packageVideoStream) {
        packageVideoStream.getTracks().forEach(track => {
            track.stop();
            track.enabled = false;
        });
        packageVideoStream = null;
    }

    if (packageScanningInterval) {
        clearInterval(packageScanningInterval);
        packageScanningInterval = null;
    }

    qrPackageVideo.pause();
    qrPackageVideo.srcObject = null;
    qrPackageVideo.load();

    qrPackageVideo.onloadedmetadata = null;
    qrPackageVideo.onerror = null;

    qrPackageCameraContainer.classList.remove('active');
    qrPackageStatus.textContent = 'Procurando c√≥digo QR...';
    qrPackageStatus.classList.remove('success');
    packageLastScannedCode = null;
}

// Vari√°veis para valida√ß√£o de leitura do scanner de pacotes
let packageConsecutiveReads = 0;
let packageLastReadData = null;
const PACKAGE_REQUIRED_READS = 2;

// Iniciar loop de scanning do pacote (otimizado)
function startPackageScanning() {
    const canvasContext = qrPackageCanvas.getContext('2d', { willReadFrequently: true });

    // Resetar contadores
    packageConsecutiveReads = 0;
    packageLastReadData = null;

    packageScanningInterval = setInterval(() => {
        if (qrPackageVideo.readyState === qrPackageVideo.HAVE_ENOUGH_DATA) {
            // ‚ú® OTIMIZA√á√ÉO GEMINI 1: Reduzir resolu√ß√£o de processamento
            // Processar apenas 640x480 em vez da resolu√ß√£o nativa
            const processWidth = 640;
            const processHeight = (qrPackageVideo.videoHeight / qrPackageVideo.videoWidth) * processWidth;

            qrPackageCanvas.width = processWidth;
            qrPackageCanvas.height = processHeight;

            // Desenhar v√≠deo redimensionado
            canvasContext.drawImage(qrPackageVideo, 0, 0, processWidth, processHeight);

            // ‚ú® OTIMIZA√á√ÉO GEMINI 2: ROI (Region of Interest)
            // Processar apenas o centro da imagem (quadrado de 400x400px)
            const scanSize = Math.min(400, processWidth, processHeight);
            const centerX = processWidth / 2;
            const centerY = processHeight / 2;

            // Capturar apenas a regi√£o central
            const imageData = canvasContext.getImageData(
                centerX - scanSize / 2,
                centerY - scanSize / 2,
                scanSize,
                scanSize
            );

            // ‚ú® OTIMIZA√á√ÉO GEMINI 3: attemptBoth para suportar QR Model 1 e 2
            const code = jsQR(imageData.data, scanSize, scanSize, {
                inversionAttempts: "attemptBoth",
            });

            if (code && code.data) {
                const qrData = code.data.trim();

                // Validar c√≥digo
                if (!isValidPackageCode(qrData)) {
                    packageConsecutiveReads = 0;
                    packageLastReadData = null;
                    return;
                }

                // Verificar tamanho m√≠nimo do QR
                const qrSize = Math.abs(code.location.bottomRightCorner.x - code.location.topLeftCorner.x);
                if (qrSize < 20) return;

                // Sistema de confirma√ß√£o
                if (qrData === packageLastReadData) {
                    packageConsecutiveReads++;
                } else {
                    packageConsecutiveReads = 1;
                    packageLastReadData = qrData;
                }

                qrPackageStatus.textContent = `üîç Lendo... (${packageConsecutiveReads}/${PACKAGE_REQUIRED_READS})`;

                if (packageConsecutiveReads >= PACKAGE_REQUIRED_READS && qrData !== packageLastScannedCode) {
                    packageLastScannedCode = qrData;
                    packageConsecutiveReads = 0;
                    packageLastReadData = null;

                    console.log('‚úÖ QR Code do pacote confirmado:', qrData);

                    qrPackageStatus.textContent = '‚úÖ C√≥digo detectado!';
                    qrPackageStatus.classList.add('success');

                    // Buscar cliente pelo c√≥digo QR
                    findClientByQRCode(qrData);
                }
            } else {
                if (packageConsecutiveReads > 0) {
                    packageConsecutiveReads = 0;
                    packageLastReadData = null;
                }
            }
        }
    }, 50); // 20 fps para leitura mais r√°pida
}

// Buscar cliente pelo c√≥digo QR do pacote
async function findClientByQRCode(qrCode) {
    try {
        // PASSO 1: Buscar o pacote na planilha do dia (delivery_data)
        const { data: deliveryData, error: deliveryError } = await supabase
            .from('delivery_data')
            .select('*')
            .eq('spx_tn', qrCode)
            .single();

        if (deliveryError && deliveryError.code !== 'PGRST116') {
            console.error('Erro ao buscar na planilha:', deliveryError);
        }

        if (!deliveryData) {
            // Pacote n√£o encontrado na planilha do dia
            scanResult.classList.add('active');
            scanResultText.innerHTML = `
                <strong style="color: #ea4335;">‚ùå Pacote n√£o encontrado</strong><br>
                O c√≥digo <code>${escapeHtml(qrCode)}</code> n√£o est√° na planilha do dia.
            `;

            showToast(
                'Pacote n√£o encontrado',
                'Este c√≥digo QR n√£o est√° na planilha de entregas do dia',
                'error',
                4000
            );

            // Resetar scanner
            setTimeout(() => {
                packageLastScannedCode = null;
                qrPackageStatus.textContent = 'Procurando c√≥digo QR...';
                qrPackageStatus.classList.remove('success');
            }, 3000);
            return;
        }

        // PASSO 2: Buscar clientes cadastrados
        const { data: clients, error: clientsError } = await supabase
            .from('clients')
            .select('*');

        if (clientsError) throw clientsError;

        if (!clients || clients.length === 0) {
            // Nenhum cliente cadastrado
            scanResult.classList.add('active');
            scanResultText.innerHTML = `
                <strong style="color: #ff9800;">‚ö†Ô∏è Nenhum cliente cadastrado</strong><br>
                Pacote encontrado na planilha, mas n√£o h√° clientes cadastrados para verificar.
            `;

            showToast(
                'Nenhum cliente cadastrado',
                'Adicione clientes para verificar correspond√™ncia',
                'warning',
                4000
            );

            setTimeout(() => {
                packageLastScannedCode = null;
                qrPackageStatus.textContent = 'Procurando c√≥digo QR...';
                qrPackageStatus.classList.remove('success');
            }, 3000);
            return;
        }

        // PASSO 3: Verificar se algum cliente tem endere√ßo que bate com o da planilha
        const deliveryAddress = (deliveryData.destination_address || '').toLowerCase().trim();

        let matchedClient = null;

        for (const client of clients) {
            const clientAddress = (client.address || '').toLowerCase().trim();

            // Verificar se os endere√ßos batem (compara√ß√£o flex√≠vel)
            if (clientAddress.includes(deliveryAddress) || deliveryAddress.includes(clientAddress)) {
                matchedClient = client;
                break;
            }

            // Verificar tamb√©m por coordenadas pr√≥ximas (mesma latitude/longitude)
            if (client.latitude && client.longitude && deliveryData.latitude && deliveryData.longitude) {
                const latDiff = Math.abs(client.latitude - deliveryData.latitude);
                const lngDiff = Math.abs(client.longitude - deliveryData.longitude);

                // Se diferen√ßa menor que 0.0001 graus (~11 metros), considera mesmo endere√ßo
                if (latDiff < 0.0001 && lngDiff < 0.0001) {
                    matchedClient = client;
                    break;
                }
            }
        }

        if (matchedClient) {
            // ‚úÖ CLIENTE ENCONTRADO - Endere√ßo bate!
            scanResult.classList.add('active');
            scanResultText.innerHTML = `
                <strong style="color: #4caf50;">‚úÖ Cliente encontrado!</strong><br>
                <strong>${escapeHtml(matchedClient.name)}</strong><br>
                üìû ${escapeHtml(matchedClient.phone || 'Sem telefone')}<br>
                üì¶ SPX TN: ${escapeHtml(qrCode)}<br>
                üìç ${escapeHtml(deliveryData.destination_address || 'Sem endere√ßo')}
            `;

            // Filtrar lista para mostrar apenas este cliente
            highlightClientInList(matchedClient);

            // Parar c√¢mera
            stopPackageCamera();

            // Toast de sucesso
            showToast(
                '‚úÖ Endere√ßo confirmado!',
                `Cliente: ${matchedClient.name}`,
                'success',
                3000
            );

            // Fechar modal ap√≥s 2 segundos
            setTimeout(() => {
                closePackageScanner();
            }, 2000);

        } else {
            // ‚ùå PACOTE NA PLANILHA MAS CLIENTE N√ÉO CADASTRADO
            scanResult.classList.add('active');
            scanResultText.innerHTML = `
                <strong style="color: #ff9800;">‚ö†Ô∏è Cliente n√£o cadastrado</strong><br>
                üì¶ SPX TN: ${escapeHtml(qrCode)}<br>
                üìç Endere√ßo da planilha:<br>
                ${escapeHtml(deliveryData.destination_address || 'Sem endere√ßo')}<br>
                <small style="color: #666;">Nenhum cliente cadastrado corresponde a este endere√ßo.</small>
            `;

            showToast(
                'Cliente n√£o cadastrado',
                'O pacote existe na planilha mas o cliente n√£o foi cadastrado ainda',
                'warning',
                4000
            );

            // Resetar scanner
            setTimeout(() => {
                packageLastScannedCode = null;
                qrPackageStatus.textContent = 'Procurando c√≥digo QR...';
                qrPackageStatus.classList.remove('success');
            }, 3000);
        }

    } catch (error) {
        console.error('Erro ao buscar cliente:', error);
        showToast(
            'Erro na busca',
            'N√£o foi poss√≠vel buscar o cliente',
            'error',
            4000
        );
    }
}

// Destacar cliente na lista
function highlightClientInList(client) {
    // Filtrar lista para mostrar apenas este cliente
    searchInput.value = client.name;

    // Disparar evento de busca
    const event = new Event('input', { bubbles: true });
    searchInput.dispatchEvent(event);

    // Scroll at√© o cliente na lista
    setTimeout(() => {
        const clientCard = document.querySelector(`[data-client-id="${client.id}"]`);
        if (clientCard) {
            clientCard.scrollIntoView({ behavior: 'smooth', block: 'center' });

            // Adicionar destaque visual tempor√°rio
            clientCard.style.animation = 'highlight-pulse 1.5s ease-in-out';

            setTimeout(() => {
                clientCard.style.animation = '';
            }, 1500);
        }
    }, 100);
}

// Event listeners do scanner de pacotes
btnScanPackage.addEventListener('click', openPackageScanner);
btnModalScanClose.addEventListener('click', closePackageScanner);
btnPackageClose.addEventListener('click', closePackageScanner);

btnPackageStopCamera.addEventListener('click', () => {
    stopPackageCamera();
});

btnPackageSwitchCamera.addEventListener('click', async () => {
    packageCurrentFacingMode = packageCurrentFacingMode === 'environment' ? 'user' : 'environment';
    stopPackageCamera();
    await startPackageCamera();
});

// Fechar modal ao clicar fora
modalScanPackage.addEventListener('click', (e) => {
    if (e.target === modalScanPackage) {
        closePackageScanner();
    }
});

// ===========================
// MOSTRAR/OCULTAR CLIENTES NO MAPA
// ===========================

const btnToggleClients = document.getElementById('btnToggleClients');
let clientMarkers = {};
let clientsVisible = false;

// Toggle clientes no mapa
btnToggleClients.addEventListener('click', async () => {
    if (clientsVisible) {
        // Ocultar clientes
        hideClientMarkers();
    } else {
        // Mostrar clientes
        await showClientMarkers();
    }
});

// Mostrar marcadores dos clientes cadastrados
async function showClientMarkers() {
    try {
        // Buscar todos os clientes do banco
        const { data: clients, error } = await supabase
            .from('clients')
            .select('*')
            .order('created_at', { ascending: true });

        if (error) throw error;

        if (!clients || clients.length === 0) {
            showToast(
                'Nenhum cliente cadastrado',
                'Adicione clientes para visualiz√°-los no mapa',
                'warning',
                3000
            );
            return;
        }

        // Criar marcador para cada cliente
        clients.forEach((client, index) => {
            if (!client.latitude || !client.longitude) {
                console.warn(`Cliente ${client.name} n√£o tem coordenadas v√°lidas`);
                return;
            }

            const position = { lat: client.latitude, lng: client.longitude };

            // Criar elemento do marcador com pin azul (diferente dos vermelhos de entrega)
            const markerDiv = document.createElement('div');
            markerDiv.style.cursor = 'pointer';
            markerDiv.style.transition = 'transform 0.2s';

            // Criar pin azul para clientes
            const pinImg = document.createElement('div');
            pinImg.style.width = '28px';
            pinImg.style.height = '28px';
            pinImg.style.background = '#2196F3';
            pinImg.style.border = '3px solid white';
            pinImg.style.borderRadius = '50% 50% 50% 0';
            pinImg.style.transform = 'rotate(-45deg)';
            pinImg.style.boxShadow = '0 2px 5px rgba(0,0,0,0.3)';
            pinImg.style.display = 'flex';
            pinImg.style.alignItems = 'center';
            pinImg.style.justifyContent = 'center';

            const innerCircle = document.createElement('div');
            innerCircle.style.width = '16px';
            innerCircle.style.height = '16px';
            innerCircle.style.background = 'white';
            innerCircle.style.borderRadius = '50%';
            innerCircle.style.transform = 'rotate(45deg)';
            innerCircle.style.fontSize = '10px';
            innerCircle.style.display = 'flex';
            innerCircle.style.alignItems = 'center';
            innerCircle.style.justifyContent = 'center';
            innerCircle.textContent = 'üë§';

            pinImg.appendChild(innerCircle);
            markerDiv.appendChild(pinImg);

            // Efeito hover
            markerDiv.addEventListener('mouseenter', () => {
                markerDiv.style.transform = 'scale(1.15)';
            });
            markerDiv.addEventListener('mouseleave', () => {
                markerDiv.style.transform = 'scale(1)';
            });

            // Criar InfoWindow
            const infoWindowContent = document.createElement('div');
            infoWindowContent.style.padding = '10px';
            infoWindowContent.style.maxWidth = '250px';

            const nameDiv = document.createElement('div');
            nameDiv.style.fontWeight = 'bold';
            nameDiv.style.fontSize = '14px';
            nameDiv.style.color = '#2196F3';
            nameDiv.style.marginBottom = '6px';
            nameDiv.textContent = `üë§ ${client.name}`;

            const phoneDiv = document.createElement('div');
            phoneDiv.style.fontSize = '12px';
            phoneDiv.style.color = '#666';
            phoneDiv.style.marginBottom = '4px';
            phoneDiv.innerHTML = `üìû ${client.phone || 'Sem telefone'}`;

            const addressDiv = document.createElement('div');
            addressDiv.style.fontSize = '12px';
            addressDiv.style.color = '#333';
            addressDiv.style.lineHeight = '1.4';
            addressDiv.innerHTML = `üìç ${client.address.replace(/\n/g, '<br>')}`;

            infoWindowContent.appendChild(nameDiv);
            infoWindowContent.appendChild(phoneDiv);
            infoWindowContent.appendChild(addressDiv);

            const infoWindow = new google.maps.InfoWindow({
                content: infoWindowContent,
                maxWidth: 280,
                disableAutoPan: true
            });

            try {
                // Criar marcador usando AdvancedMarkerElement
                if (google.maps.marker && google.maps.marker.AdvancedMarkerElement) {
                    const marker = new google.maps.marker.AdvancedMarkerElement({
                        map,
                        position,
                        content: markerDiv,
                        title: client.name
                    });

                    marker.addListener('click', () => {
                        if (currentInfoWindow) {
                            currentInfoWindow.close();
                        }
                        infoWindow.open(map, marker);
                        currentInfoWindow = infoWindow;
                        map.panTo(position);
                        markUserInteraction(); // Detectar intera√ß√£o durante navega√ß√£o
                    });

                    clientMarkers[client.id] = marker;
                } else {
                    // Fallback: Marcador cl√°ssico
                    const marker = new google.maps.Marker({
                        map,
                        position,
                        title: client.name,
                        icon: {
                            path: google.maps.SymbolPath.CIRCLE,
                            fillColor: '#2196F3',
                            fillOpacity: 1,
                            strokeColor: 'white',
                            strokeWeight: 2,
                            scale: 8
                        }
                    });

                    marker.addListener('click', () => {
                        if (currentInfoWindow) {
                            currentInfoWindow.close();
                        }
                        infoWindow.open(map, marker);
                        currentInfoWindow = infoWindow;
                        map.panTo(position);
                        markUserInteraction(); // Detectar intera√ß√£o durante navega√ß√£o
                    });

                    clientMarkers[client.id] = marker;
                }
            } catch (error) {
                console.error('Erro ao criar marcador:', error);
            }
        });

        clientsVisible = true;
        btnToggleClients.classList.add('active');

        showToast(
            `${clients.length} cliente${clients.length > 1 ? 's' : ''} exibido${clients.length > 1 ? 's' : ''}`,
            'Clientes cadastrados mostrados no mapa',
            'success',
            3000
        );

    } catch (error) {
        console.error('Erro ao carregar clientes:', error);
        showToast(
            'Erro ao carregar clientes',
            'N√£o foi poss√≠vel buscar os dados do banco',
            'error',
            4000
        );
    }
}

// Ocultar marcadores dos clientes
function hideClientMarkers() {
    Object.values(clientMarkers).forEach(marker => {
        try {
            if (marker.map !== undefined) {
                marker.map = null; // AdvancedMarkerElement
            } else if (marker.setMap) {
                marker.setMap(null); // Marker cl√°ssico
            }
        } catch (e) {
            console.warn('Erro ao remover marcador:', e);
        }
    });

    clientMarkers = {};
    clientsVisible = false;
    btnToggleClients.classList.remove('active');

    showToast(
        'Clientes ocultados',
        'Marcadores removidos do mapa',
        'info',
        2000
    );
}

// ===========================
// MOSTRAR CLIENTES IDENTIFICADOS NA PLANILHA
// ===========================

const btnShowMatchedClients = document.getElementById('btnShowMatchedClients');
let matchedClientMarkers = {};
let matchedClientsVisible = false;

// Toggle clientes identificados na planilha
btnShowMatchedClients.addEventListener('click', async () => {
    if (matchedClientsVisible) {
        hideMatchedClientMarkers();
    } else {
        await showMatchedClientMarkers();
    }
});

// Fun√ß√£o para normalizar endere√ßo (mesma usada na compara√ß√£o)
function normalizeAddressForComparison(address) {
    return address
        .toLowerCase()
        .trim()
        .replace(/\s+/g, ' ')
        .replace(/[.,;:\-]/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
}

// Mostrar marcadores dos clientes identificados na planilha
async function showMatchedClientMarkers() {
    try {
        // 1. Buscar dados da planilha (delivery_data) do Supabase
        const { data: deliveryData, error: deliveryError } = await supabase
            .from('delivery_data')
            .select('*');

        if (deliveryError) {
            console.error('Erro ao buscar delivery_data:', deliveryError);
            throw deliveryError;
        }

        if (!deliveryData || deliveryData.length === 0) {
            showToast(
                'Nenhuma planilha carregada',
                'Fa√ßa upload de uma planilha primeiro',
                'warning',
                4000
            );
            return;
        }

        // 2. Buscar todos os clientes do banco
        const { data: clients, error: clientsError } = await supabase
            .from('clients')
            .select('*')
            .order('created_at', { ascending: true });

        if (clientsError) throw clientsError;

        if (!clients || clients.length === 0) {
            showToast(
                'Nenhum cliente cadastrado',
                'N√£o h√° clientes para exibir',
                'warning',
                3000
            );
            return;
        }

        // 3. Criar Set de endere√ßos da planilha (normalizados)
        const deliveryAddresses = new Set();
        deliveryData.forEach(delivery => {
            const addr = delivery.destination_address || '';
            if (addr) {
                deliveryAddresses.add(normalizeAddressForComparison(addr));
            }
        });

        // 4. Filtrar apenas clientes cujos endere√ßos batem com a planilha
        const matchedClients = clients.filter(client => {
            const clientAddress = client.address || '';
            const clientAddressFirstLine = clientAddress.split('\n')[0];
            const normalizedClient = normalizeAddressForComparison(clientAddressFirstLine);

            return deliveryAddresses.has(normalizedClient);
        });

        if (matchedClients.length === 0) {
            showToast(
                'Nenhum cliente identificado',
                'Os endere√ßos da planilha n√£o correspondem aos clientes cadastrados',
                'warning',
                4000
            );
            return;
        }

        console.log(`üìç Mostrando ${matchedClients.length} clientes identificados na planilha`);

        // Criar marcador para cada cliente identificado
        matchedClients.forEach((client) => {
            if (!client.latitude || !client.longitude) {
                console.warn(`Cliente ${client.name} n√£o tem coordenadas v√°lidas`);
                return;
            }

            const position = { lat: client.latitude, lng: client.longitude };

            // Buscar pacotes/entregas deste cliente na planilha
            const clientAddressFirstLine = (client.address || '').split('\n')[0];
            const normalizedClientAddress = normalizeAddressForComparison(clientAddressFirstLine);

            const clientDeliveries = deliveryData.filter(delivery => {
                const deliveryAddr = delivery.destination_address || '';
                const normalizedDeliveryAddr = normalizeAddressForComparison(deliveryAddr);
                return normalizedDeliveryAddr === normalizedClientAddress;
            });

            const deliveryCount = clientDeliveries.length;

            // Criar elemento do marcador com pin VERDE (para diferenciar)
            const markerDiv = document.createElement('div');
            markerDiv.style.cursor = 'pointer';
            markerDiv.style.transition = 'transform 0.2s';

            // Criar pin verde para clientes identificados na planilha
            const pinImg = document.createElement('div');
            pinImg.style.width = '32px';
            pinImg.style.height = '32px';
            pinImg.style.background = '#4CAF50'; // Verde
            pinImg.style.border = '3px solid white';
            pinImg.style.borderRadius = '50% 50% 50% 0';
            pinImg.style.transform = 'rotate(-45deg)';
            pinImg.style.boxShadow = '0 3px 6px rgba(0,0,0,0.4)';
            pinImg.style.display = 'flex';
            pinImg.style.alignItems = 'center';
            pinImg.style.justifyContent = 'center';

            const innerCircle = document.createElement('div');
            innerCircle.style.width = '18px';
            innerCircle.style.height = '18px';
            innerCircle.style.background = 'white';
            innerCircle.style.borderRadius = '50%';
            innerCircle.style.transform = 'rotate(45deg)';
            innerCircle.style.fontSize = '11px';
            innerCircle.style.display = 'flex';
            innerCircle.style.alignItems = 'center';
            innerCircle.style.justifyContent = 'center';
            innerCircle.textContent = '‚úì';

            pinImg.appendChild(innerCircle);
            markerDiv.appendChild(pinImg);

            // Efeito hover
            markerDiv.addEventListener('mouseenter', () => {
                markerDiv.style.transform = 'scale(1.2)';
            });
            markerDiv.addEventListener('mouseleave', () => {
                markerDiv.style.transform = 'scale(1)';
            });

            // Criar InfoWindow
            const infoWindowContent = document.createElement('div');
            infoWindowContent.style.padding = '12px';
            infoWindowContent.style.maxWidth = '280px';

            const badgeDiv = document.createElement('div');
            badgeDiv.style.background = '#4CAF50';
            badgeDiv.style.color = 'white';
            badgeDiv.style.padding = '4px 8px';
            badgeDiv.style.borderRadius = '4px';
            badgeDiv.style.fontSize = '11px';
            badgeDiv.style.fontWeight = 'bold';
            badgeDiv.style.marginBottom = '8px';
            badgeDiv.style.display = 'inline-block';
            badgeDiv.textContent = '‚úì IDENTIFICADO NA PLANILHA';

            const nameDiv = document.createElement('div');
            nameDiv.style.fontWeight = 'bold';
            nameDiv.style.fontSize = '14px';
            nameDiv.style.color = '#4CAF50';
            nameDiv.style.marginBottom = '6px';
            nameDiv.textContent = `üë§ ${client.name}`;

            const phoneDiv = document.createElement('div');
            phoneDiv.style.fontSize = '12px';
            phoneDiv.style.color = '#666';
            phoneDiv.style.marginBottom = '4px';
            phoneDiv.innerHTML = `üìû ${client.phone || 'Sem telefone'}`;

            const addressDiv = document.createElement('div');
            addressDiv.style.fontSize = '12px';
            addressDiv.style.color = '#333';
            addressDiv.style.lineHeight = '1.5';
            addressDiv.style.marginBottom = '8px';
            addressDiv.style.padding = '8px';
            addressDiv.style.background = '#f5f5f5';
            addressDiv.style.borderRadius = '4px';
            addressDiv.innerHTML = `üìç ${client.address.replace(/\n/g, '<br>')}`;

            infoWindowContent.appendChild(badgeDiv);
            infoWindowContent.appendChild(nameDiv);
            infoWindowContent.appendChild(phoneDiv);
            infoWindowContent.appendChild(addressDiv);

            // Adicionar informa√ß√µes de pacotes se houver entregas
            if (clientDeliveries.length > 0) {
                // T√≠tulo da lista de pacotes
                const packagesTitle = document.createElement('div');
                packagesTitle.style.fontWeight = 'bold';
                packagesTitle.style.fontSize = '11px';
                packagesTitle.style.color = '#666';
                packagesTitle.style.marginTop = '8px';
                packagesTitle.style.marginBottom = '6px';
                packagesTitle.style.borderTop = '1px solid #eee';
                packagesTitle.style.paddingTop = '8px';
                packagesTitle.textContent = `üì¶ ${deliveryCount} pacote${deliveryCount > 1 ? 's' : ''}:`;
                infoWindowContent.appendChild(packagesTitle);

                // Adicionar cada pacote
                clientDeliveries.forEach((delivery, index) => {
                    const deliveryDiv = document.createElement('div');
                    deliveryDiv.style.fontSize = '11px';
                    deliveryDiv.style.color = '#333';
                    deliveryDiv.style.lineHeight = '1.4';
                    deliveryDiv.style.marginBottom = '4px';
                    deliveryDiv.style.paddingBottom = '4px';
                    deliveryDiv.style.paddingLeft = '8px';

                    if (index < clientDeliveries.length - 1) {
                        deliveryDiv.style.borderBottom = '1px solid #eee';
                    }

                    // Linha com Ordem e C√≥digo QR
                    const qrDiv = document.createElement('div');
                    qrDiv.style.display = 'flex';
                    qrDiv.style.justifyContent = 'space-between';
                    qrDiv.style.alignItems = 'center';
                    qrDiv.style.gap = '8px';

                    const sequenceSpan = document.createElement('span');
                    sequenceSpan.style.color = '#4CAF50';
                    sequenceSpan.style.fontWeight = 'bold';
                    sequenceSpan.textContent = `Ordem: ${delivery.sequence || (index + 1)}`;

                    const qrSpan = document.createElement('span');
                    qrSpan.style.fontSize = '10px';
                    qrSpan.style.color = '#666';
                    qrSpan.style.fontFamily = 'monospace';
                    qrSpan.textContent = delivery.spx_tn || 'N/A';

                    qrDiv.appendChild(sequenceSpan);
                    qrDiv.appendChild(qrSpan);

                    deliveryDiv.appendChild(qrDiv);
                    infoWindowContent.appendChild(deliveryDiv);
                });
            }

            // Bot√£o de navega√ß√£o
            const navigateBtn = document.createElement('button');
            navigateBtn.style.width = '100%';
            navigateBtn.style.padding = '8px 12px';
            navigateBtn.style.marginTop = '8px';
            navigateBtn.style.background = '#4285f4';
            navigateBtn.style.color = 'white';
            navigateBtn.style.border = 'none';
            navigateBtn.style.borderRadius = '6px';
            navigateBtn.style.fontSize = '13px';
            navigateBtn.style.fontWeight = 'bold';
            navigateBtn.style.cursor = 'pointer';
            navigateBtn.style.transition = 'background 0.2s';
            navigateBtn.innerHTML = 'üß≠ Navegar at√© cliente';

            navigateBtn.addEventListener('mouseenter', () => {
                navigateBtn.style.background = '#3367d6';
            });
            navigateBtn.addEventListener('mouseleave', () => {
                navigateBtn.style.background = '#4285f4';
            });

            infoWindowContent.appendChild(navigateBtn);

            const infoWindow = new google.maps.InfoWindow({
                content: infoWindowContent,
                maxWidth: 300,
                disableAutoPan: true
            });

            // Vari√°vel para armazenar refer√™ncia ao marker
            let currentMarkerRef = null;

            try {
                // Criar marcador usando AdvancedMarkerElement
                if (google.maps.marker && google.maps.marker.AdvancedMarkerElement) {
                    const marker = new google.maps.marker.AdvancedMarkerElement({
                        map,
                        position,
                        content: markerDiv,
                        title: client.name
                    });

                    marker.addListener('click', () => {
                        if (currentInfoWindow) {
                            currentInfoWindow.close();
                        }
                        infoWindow.open(map, marker);
                        currentInfoWindow = infoWindow;
                        map.panTo(position);
                        markUserInteraction(); // Detectar intera√ß√£o durante navega√ß√£o
                    });

                    matchedClientMarkers[client.id] = marker;
                    currentMarkerRef = marker;
                } else {
                    // Fallback: Marcador cl√°ssico
                    const marker = new google.maps.Marker({
                        map,
                        position,
                        title: client.name,
                        icon: {
                            path: google.maps.SymbolPath.CIRCLE,
                            fillColor: '#4CAF50',
                            fillOpacity: 1,
                            strokeColor: 'white',
                            strokeWeight: 2,
                            scale: 10
                        }
                    });

                    marker.addListener('click', () => {
                        if (currentInfoWindow) {
                            currentInfoWindow.close();
                        }
                        infoWindow.open(map, marker);
                        currentInfoWindow = infoWindow;
                        map.panTo(position);
                        markUserInteraction(); // Detectar intera√ß√£o durante navega√ß√£o
                    });

                    matchedClientMarkers[client.id] = marker;
                    currentMarkerRef = marker;
                }
            } catch (error) {
                console.error('Erro ao criar marcador:', error);
            }

            // Atribuir evento de navega√ß√£o ap√≥s criar marker e infoWindow
            navigateBtn.addEventListener('click', () => {
                navigateToClient(client, currentMarkerRef, infoWindow);
            });
        });

        matchedClientsVisible = true;
        btnShowMatchedClients.classList.add('active');

        showToast(
            `${matchedClients.length} cliente${matchedClients.length > 1 ? 's' : ''} identificado${matchedClients.length > 1 ? 's' : ''}`,
            'Clientes da planilha mostrados no mapa',
            'success',
            4000
        );

    } catch (error) {
        console.error('Erro ao carregar clientes identificados:', error);
        showToast(
            'Erro ao carregar',
            'N√£o foi poss√≠vel mostrar os clientes',
            'error',
            4000
        );
    }
}

// Ocultar marcadores dos clientes identificados
function hideMatchedClientMarkers() {
    Object.values(matchedClientMarkers).forEach(marker => {
        try {
            if (marker.map !== undefined) {
                marker.map = null; // AdvancedMarkerElement
            } else if (marker.setMap) {
                marker.setMap(null); // Marker cl√°ssico
            }
        } catch (e) {
            console.warn('Erro ao remover marcador:', e);
        }
    });

    matchedClientMarkers = {};
    matchedClientsVisible = false;
    btnShowMatchedClients.classList.remove('active');

    showToast(
        'Clientes identificados ocultados',
        'Marcadores removidos do mapa',
        'info',
        2000
    );
}

// ===========================
// UPLOAD DE PLANILHA
// ===========================

const modalUploadSpreadsheet = document.getElementById('modal-upload-spreadsheet');
const btnUploadSpreadsheet = document.getElementById('btnUploadSpreadsheet');
const btnModalUploadClose = document.getElementById('modal-upload-close');
const uploadArea = document.getElementById('upload-area');
const fileInput = document.getElementById('file-input');
const uploadProgress = document.getElementById('upload-progress');
const progressBar = document.getElementById('progress-bar');
const progressText = document.getElementById('progress-text');
const uploadResult = document.getElementById('upload-result');
const resultIcon = document.getElementById('result-icon');
const resultText = document.getElementById('result-text');
const resultDetails = document.getElementById('result-details');

// Abrir modal de upload
function openUploadModal() {
    modalUploadSpreadsheet.classList.add('active');
    document.body.style.overflow = 'hidden';

    // Resetar estados
    uploadArea.style.display = 'block';
    uploadProgress.style.display = 'none';
    uploadResult.style.display = 'none';
    progressBar.style.width = '0%';
    fileInput.value = '';
}

// Fechar modal de upload
function closeUploadModal() {
    modalUploadSpreadsheet.classList.remove('active');
    document.body.style.overflow = '';
}

// Vari√°vel para controlar estado do bot√£o
let hasSpreadsheetData = false;

// Event listeners do modal
btnUploadSpreadsheet.addEventListener('click', () => {
    if (hasSpreadsheetData) {
        // Se h√° planilha carregada, limpar dados
        clearSpreadsheetData();
    } else {
        // Se n√£o h√° planilha, abrir modal de upload
        openUploadModal();
    }
});
btnModalUploadClose.addEventListener('click', closeUploadModal);

// Fun√ß√£o para mudar bot√£o para modo "Limpar planilha"
function setButtonToClearMode() {
    hasSpreadsheetData = true;
    btnUploadSpreadsheet.textContent = 'üóëÔ∏è';
    btnUploadSpreadsheet.title = 'Limpar planilha do dia';
    btnUploadSpreadsheet.classList.add('active');
}

// Fun√ß√£o para mudar bot√£o para modo "Upload planilha"
function setButtonToUploadMode() {
    hasSpreadsheetData = false;
    btnUploadSpreadsheet.textContent = 'üìä';
    btnUploadSpreadsheet.title = 'Atualizar planilha do dia';
    btnUploadSpreadsheet.classList.remove('active');
}

// Fun√ß√£o para limpar dados da planilha
async function clearSpreadsheetData() {
    // Criar modal de confirma√ß√£o customizado
    const modal = document.createElement('div');
    modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
    modal.style.position = 'fixed';
    modal.style.top = '0';
    modal.style.left = '0';
    modal.style.right = '0';
    modal.style.bottom = '0';
    modal.style.backgroundColor = 'rgba(0,0,0,0.5)';
    modal.style.display = 'flex';
    modal.style.alignItems = 'center';
    modal.style.justifyContent = 'center';
    modal.style.zIndex = '10000';

    modal.innerHTML = `
        <div style="background: white; padding: 24px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 400px; width: 90%;">
            <div style="font-size: 20px; font-weight: 600; color: #333; margin-bottom: 16px;">‚ö†Ô∏è Confirmar exclus√£o</div>
            <div style="color: #666; margin-bottom: 20px; line-height: 1.6;">
                <p style="margin-bottom: 12px;">Tem certeza que deseja limpar todos os dados da planilha?</p>
                <p style="margin-bottom: 8px; font-weight: 600;">Isso ir√° remover:</p>
                <ul style="margin-left: 20px;">
                    <li>‚úì Todos os dados de entrega</li>
                    <li>‚úì Marcadores no mapa</li>
                    <li>‚úì Rotas planejadas</li>
                </ul>
                <p style="margin-top: 12px; color: #e53e3e; font-weight: 600;">‚ö†Ô∏è Essa a√ß√£o n√£o pode ser desfeita!</p>
            </div>
            <div style="display: flex; justify-content: flex-end; gap: 12px;">
                <button id="btn-cancel-clear" style="padding: 10px 20px; background: #e5e7eb; color: #333; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Cancelar</button>
                <button id="btn-confirm-clear" style="padding: 10px 20px; background: #dc2626; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Limpar tudo</button>
            </div>
        </div>
    `;

    document.body.appendChild(modal);

    // Criar promise para aguardar resposta do usu√°rio
    const userResponse = await new Promise((resolve) => {
        const btnCancel = modal.querySelector('#btn-cancel-clear');
        const btnConfirm = modal.querySelector('#btn-confirm-clear');

        btnCancel.addEventListener('click', () => {
            modal.remove();
            resolve(false);
        });

        btnConfirm.addEventListener('click', () => {
            modal.remove();
            resolve(true);
        });

        // Clicar fora do modal cancela
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                modal.remove();
                resolve(false);
            }
        });
    });

    if (!userResponse) {
        return;
    }

    try {
        // Limpar dados da planilha do Supabase
        const { error: deleteError } = await supabase
            .from('delivery_data')
            .delete()
            .neq('id', '00000000-0000-0000-0000-000000000000');

        if (deleteError) {
            console.error('Erro ao limpar delivery_data:', deleteError);
            showToast(
                'Erro ao limpar planilha',
                'N√£o foi poss√≠vel remover os dados',
                'error',
                4000
            );
            return;
        }

        // Limpar marcadores do mapa
        Object.values(deliveryMarkers).forEach(marker => {
            try {
                if (marker.map !== undefined) {
                    marker.map = null;
                } else if (marker.setMap) {
                    marker.setMap(null);
                }
            } catch (e) {
                console.warn('Erro ao remover marcador:', e);
            }
        });
        deliveryMarkers = {};

        // Limpar rotas
        if (directionsRenderer) {
            directionsRenderer.setDirections({routes: []});
            directionsRenderer.setMap(null);
        }
        if (window.routePolylines) {
            window.routePolylines.forEach(polyline => polyline.setMap(null));
            window.routePolylines = [];
        }

        // Voltar bot√£o para modo upload
        setButtonToUploadMode();

        showToast(
            'üóëÔ∏è Planilha limpa!',
            'Todos os dados foram removidos. Sistema pronto para nova planilha.',
            'success',
            4000
        );

        console.log('‚úÖ Planilha limpa com sucesso');

    } catch (error) {
        console.error('Erro ao limpar planilha:', error);
        showToast(
            'Erro ao limpar',
            'Ocorreu um erro ao limpar os dados',
            'error',
            4000
        );
    }
}

modalUploadSpreadsheet.addEventListener('click', (e) => {
    if (e.target === modalUploadSpreadsheet) {
        closeUploadModal();
    }
});

// Click na √°rea de upload
uploadArea.addEventListener('click', () => {
    fileInput.click();
});

// Drag and drop
uploadArea.addEventListener('dragover', (e) => {
    e.preventDefault();
    uploadArea.classList.add('dragover');
});

uploadArea.addEventListener('dragleave', () => {
    uploadArea.classList.remove('dragover');
});

uploadArea.addEventListener('drop', (e) => {
    e.preventDefault();
    uploadArea.classList.remove('dragover');

    const files = e.dataTransfer.files;
    if (files.length > 0) {
        handleFile(files[0]);
    }
});

// Sele√ß√£o de arquivo
fileInput.addEventListener('change', (e) => {
    const files = e.target.files;
    if (files.length > 0) {
        handleFile(files[0]);
    }
});

// Processar arquivo
async function handleFile(file) {
    const fileName = file.name.toLowerCase();

    // Validar tipo de arquivo
    if (!fileName.endsWith('.xlsx') && !fileName.endsWith('.xls') && !fileName.endsWith('.csv')) {
        showToast(
            'Formato inv√°lido',
            'Por favor, selecione um arquivo Excel (.xlsx, .xls) ou CSV (.csv)',
            'error',
            5000
        );
        return;
    }

    // Mostrar progresso
    uploadArea.style.display = 'none';
    uploadProgress.style.display = 'block';
    progressBar.style.width = '30%';
    progressText.textContent = 'Lendo arquivo...';

    try {
        const data = await file.arrayBuffer();
        progressBar.style.width = '50%';
        progressText.textContent = 'Processando dados...';

        // Processar planilha
        const workbook = XLSX.read(data, { type: 'array' });
        const sheetName = workbook.SheetNames[0];
        const worksheet = workbook.Sheets[sheetName];
        const jsonData = XLSX.utils.sheet_to_json(worksheet);

        progressBar.style.width = '70%';
        progressText.textContent = 'Atualizando banco de dados...';

        // Processar e salvar dados
        const result = await processSpreadsheetData(jsonData);

        progressBar.style.width = '100%';
        progressText.textContent = 'Conclu√≠do!';

        // Mostrar resultado de sucesso
        setTimeout(() => {
            uploadProgress.style.display = 'none';
            uploadResult.style.display = 'block';
            resultIcon.textContent = '‚úÖ';
            resultText.textContent = 'Planilha atualizada com sucesso!';
            resultText.style.color = '#4caf50';

            // Exibir estat√≠sticas de compara√ß√£o de endere√ßos
            let detailsHTML = `${result.count} registros processados<br><br>`;
            detailsHTML += `<strong>üìä An√°lise de Endere√ßos:</strong><br>`;
            detailsHTML += `‚úÖ <strong>${result.matchedCount}</strong> endere√ßo${result.matchedCount !== 1 ? 's' : ''} j√° cadastrado${result.matchedCount !== 1 ? 's' : ''}<br>`;
            detailsHTML += `‚ö†Ô∏è <strong>${result.notRegisteredCount}</strong> endere√ßo${result.notRegisteredCount !== 1 ? 's' : ''} n√£o cadastrado${result.notRegisteredCount !== 1 ? 's' : ''}`;

            resultDetails.innerHTML = detailsHTML;

            // Fechar modal ap√≥s 5 segundos (tempo maior para ler as estat√≠sticas)
            setTimeout(() => {
                closeUploadModal();

                // Recarregar dados
                loadClients();

                // Mudar bot√£o para modo "Limpar planilha"
                setButtonToClearMode();

                showToast(
                    'Planilha atualizada!',
                    `${result.matchedCount} cadastrados, ${result.notRegisteredCount} n√£o cadastrados`,
                    'success',
                    5000
                );
            }, 5000);
        }, 500);

    } catch (error) {
        console.error('Erro ao processar planilha:', error);

        uploadProgress.style.display = 'none';
        uploadResult.style.display = 'block';
        resultIcon.textContent = '‚ùå';
        resultText.textContent = 'Erro ao processar planilha';
        resultText.style.color = '#ea4335';
        resultDetails.textContent = error.message || 'Verifique o formato do arquivo';

        showToast(
            'Erro no upload',
            'N√£o foi poss√≠vel processar a planilha',
            'error',
            5000
        );
    }
}

// Processar dados da planilha e salvar no Supabase
async function processSpreadsheetData(jsonData) {
    try {
        if (!jsonData || jsonData.length === 0) {
            throw new Error('Planilha vazia ou sem dados v√°lidos');
        }

        console.log('Processando', jsonData.length, 'linhas da planilha...');

        // 1. Limpar tabela delivery_data
        const { error: deleteDeliveryError } = await supabase
            .from('delivery_data')
            .delete()
            .neq('id', '00000000-0000-0000-0000-000000000000');

        if (deleteDeliveryError) {
            console.warn('Erro ao limpar delivery_data (talvez a tabela n√£o exista ainda):', deleteDeliveryError);
        }

        // 2. Limpar rotas existentes
        if (typeof currentRoute !== 'undefined' && currentRoute) {
            currentRoute.setMap(null);
            currentRoute = null;
        }
        if (typeof directionsRenderer !== 'undefined' && directionsRenderer) {
            directionsRenderer.setMap(null);
        }
        if (typeof window.routePolylines !== 'undefined' && window.routePolylines) {
            window.routePolylines.forEach(polyline => polyline.setMap(null));
            window.routePolylines = [];
        }

        // 3. Processar dados da planilha
        const deliveryDataRecords = [];

        for (const row of jsonData) {
            // Mapear colunas da planilha para o banco
            const spxTn = row['SPX TN'] || row['spx_tn'] || row['QR Code'] || '';
            const destinationAddress = row['Destination Address'] || row['destination_address'] || row['Endere√ßo'] || '';
            const bairro = row['Bairro'] || row['bairro'] || '';
            const city = row['City'] || row['city'] || row['Cidade'] || '';
            const zipcode = row['Zipcode/Postal code'] || row['zipcode'] || row['CEP'] || '';
            const latitude = parseFloat(row['Latitude'] || row['latitude'] || 0);
            const longitude = parseFloat(row['Longitude'] || row['longitude'] || 0);
            const sequence = parseInt(row['Sequence'] || row['sequence'] || 0);

            if (!spxTn) {
                console.warn('Linha sem SPX TN, pulando:', row);
                continue;
            }

            deliveryDataRecords.push({
                spx_tn: spxTn,
                destination_address: destinationAddress,
                bairro: bairro,
                city: city,
                zipcode: zipcode,
                latitude: latitude || null,
                longitude: longitude || null,
                sequence: sequence || null,
                status: 'pending' // Status inicial
            });
        }

        if (deliveryDataRecords.length === 0) {
            throw new Error('Nenhum registro v√°lido encontrado na planilha. Verifique se as colunas est√£o corretas: SPX TN, Destination Address, Bairro, City, Zipcode/Postal code, Latitude, Longitude');
        }

        // 4. Inserir na tabela delivery_data
        const { data: insertedData, error: insertDeliveryError } = await supabase
            .from('delivery_data')
            .insert(deliveryDataRecords)
            .select();

        if (insertDeliveryError) {
            console.error('Erro ao inserir em delivery_data:', insertDeliveryError);
            throw new Error(`Erro ao salvar na tabela delivery_data: ${insertDeliveryError.message}`);
        }

        console.log(`‚úì ${deliveryDataRecords.length} registros salvos na tabela delivery_data`);

        // 5. Buscar clientes cadastrados para compara√ß√£o
        const { data: clients, error: clientsError } = await supabase
            .from('clients')
            .select('*');

        if (clientsError) {
            console.warn('Erro ao buscar clientes:', clientsError);
        }

        // 6. Comparar endere√ßos da planilha com clientes cadastrados (APENAS endere√ßo)
        // Usar Sets para contar ENDERE√áOS √öNICOS (n√£o pacotes duplicados)
        const matchedAddresses = new Set();
        const notRegisteredAddresses = new Set();

        // Fun√ß√£o para normalizar endere√ßo (remove espa√ßos extras, pontua√ß√£o, lowercase)
        const normalizeAddress = (address) => {
            return address
                .toLowerCase()
                .trim()
                // Remove m√∫ltiplos espa√ßos
                .replace(/\s+/g, ' ')
                // Remove pontua√ß√£o (v√≠rgulas, pontos, etc.)
                .replace(/[.,;:\-]/g, ' ')
                // Remove espa√ßos novamente ap√≥s remover pontua√ß√£o
                .replace(/\s+/g, ' ')
                .trim();
        };

        if (clients && clients.length > 0) {
            console.log(`üîç Iniciando compara√ß√£o de ${deliveryDataRecords.length} pacotes da planilha com ${clients.length} clientes cadastrados...`);

            for (const delivery of deliveryDataRecords) {
                const deliveryAddress = delivery.destination_address || '';
                const normalizedDelivery = normalizeAddress(deliveryAddress);

                // Pular endere√ßos vazios
                if (!normalizedDelivery) continue;

                let isMatched = false;

                // Verificar se o endere√ßo da planilha bate com algum cliente cadastrado
                for (const client of clients) {
                    const clientAddress = client.address || '';

                    // Extrair APENAS a primeira linha do endere√ßo (antes do \n que separa bairro/cidade)
                    const clientAddressFirstLine = clientAddress.split('\n')[0];
                    const normalizedClient = normalizeAddress(clientAddressFirstLine);

                    // Compara√ß√£o APENAS por endere√ßo normalizado (ignora nome, telefone, bairro, cidade, CEP)
                    if (normalizedClient && normalizedDelivery && normalizedClient === normalizedDelivery) {
                        isMatched = true;

                        // Adicionar ao Set de endere√ßos cadastrados (n√£o duplica)
                        if (!matchedAddresses.has(normalizedDelivery)) {
                            console.log(`‚úÖ MATCH: "${deliveryAddress}" === "${clientAddressFirstLine}"`);
                            matchedAddresses.add(normalizedDelivery);
                        }
                        break;
                    }
                }

                if (!isMatched && deliveryAddress) {
                    // Adicionar ao Set de endere√ßos n√£o cadastrados (n√£o duplica)
                    if (!notRegisteredAddresses.has(normalizedDelivery)) {
                        console.log(`‚ö†Ô∏è NO MATCH: "${deliveryAddress}"`);
                        notRegisteredAddresses.add(normalizedDelivery);
                    }
                }
            }
        } else {
            // Se n√£o h√° clientes cadastrados, contar endere√ßos √∫nicos da planilha
            const uniqueAddresses = new Set();
            deliveryDataRecords.forEach(delivery => {
                const normalized = normalizeAddress(delivery.destination_address || '');
                if (normalized) {
                    uniqueAddresses.add(normalized);
                }
            });
            uniqueAddresses.forEach(addr => notRegisteredAddresses.add(addr));
        }

        const matchedCount = matchedAddresses.size;
        const notRegisteredCount = notRegisteredAddresses.size;

        console.log(`üìä An√°lise de endere√ßos:`);
        console.log(`   ‚úÖ Cadastrados: ${matchedCount}`);
        console.log(`   ‚ö†Ô∏è N√£o cadastrados: ${notRegisteredCount}`);

        // Armazenar endere√ßos matched globalmente para uso posterior
        window.matchedAddressesFromSpreadsheet = Array.from(matchedAddresses);

        return {
            success: true,
            count: deliveryDataRecords.length,
            matchedCount: matchedCount,
            notRegisteredCount: notRegisteredCount,
            matchedAddresses: Array.from(matchedAddresses),
            message: `${deliveryDataRecords.length} registros salvos com sucesso`
        };

    } catch (error) {
        console.error('Erro ao processar dados da planilha:', error);
        throw error;
    }
}

// ===========================
// CLEANUP
// ===========================

window.addEventListener('beforeunload', () => {
    if (watchId) navigator.geolocation.clearWatch(watchId);
});

// Resetar bot√µes quando usu√°rio volta de app externo (tel: ou whatsapp:)
window.addEventListener('pageshow', function(event) {
    // Executar reset quando p√°gina √© mostrada novamente
    if (event.persisted || performance.getEntriesByType('navigation')[0]?.type === 'back_forward') {
        resetPhoneButtonsFocus();
    }
    // Reset tamb√©m ao voltar de link externo
    setTimeout(() => {
        resetPhoneButtonsFocus();
    }, 100);
});

// Tratamento de erro de carregamento do mapa
window.addEventListener('error', (e) => {
    if (e.message.includes('Google Maps')) {
        hideLoadingScreen();
        showToast(
            'Erro ao carregar mapa',
            'Verifique sua conex√£o com a internet',
            'error',
            8000
        );
    }
}, true);

/* ===========================
   SERVICE WORKER REGISTRATION
   =========================== */
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        // Service Worker inline para cache
        const swCode = `
// Service Worker - Cache Offline v1.2
const CACHE_NAME = 'mapa-clientes-v1.2';

self.addEventListener('install', (event) => {
    console.log('[SW] Instalando Service Worker...');
    event.waitUntil(
        caches.open(CACHE_NAME).then(() => self.skipWaiting())
    );
});

self.addEventListener('activate', (event) => {
    console.log('[SW] Ativando Service Worker...');
    event.waitUntil(
        caches.keys().then((cacheNames) => {
            return Promise.all(
                cacheNames.map((cacheName) => {
                    if (cacheName !== CACHE_NAME) {
                        return caches.delete(cacheName);
                    }
                })
            );
        }).then(() => self.clients.claim())
    );
});

self.addEventListener('fetch', (event) => {
    if (event.request.method !== 'GET') return;

    // Ignorar APIs externas
    const url = event.request.url;
    if (url.includes('googleapis.com') ||
        url.includes('supabase.co') ||
        url.includes('cdn.jsdelivr.net')) {
        return;
    }

    event.respondWith(
        fetch(event.request)
            .then((response) => {
                if (response && response.status === 200) {
                    const responseClone = response.clone();
                    caches.open(CACHE_NAME).then((cache) => {
                        cache.put(event.request, responseClone);
                    });
                }
                return response;
            })
            .catch(() => {
                return caches.match(event.request).then((cached) => {
                    if (cached) {
                        console.log('[SW] Cache:', event.request.url);
                        return cached;
                    }
                    return new Response('Offline', { status: 503 });
                });
            })
    );
});
`;

        const blob = new Blob([swCode], { type: 'application/javascript' });
        const swUrl = URL.createObjectURL(blob);

        navigator.serviceWorker.register(swUrl)
            .then((reg) => {
                console.log('‚úÖ Service Worker registrado');
                console.log('üì¶ Cache offline ativo');
            })
            .catch((err) => console.warn('‚ö†Ô∏è SW falhou:', err));
    });
}
</script>

</body>
</html>
